# Kardinality game development plan
_Exported on 12/16/2025 at 14:52:00 EST from Cursor (2.2.20)_

---

**User**

Okay I'm trying to make a new game in Rust called Kardinality. This should be deployable to a web browser and use WASM for cross platform support. I want the tech stack to focus on browser APIs accessed through Rust (the least amount of JavaScript/TypeScript and none if possible)

I want to use the 'dioxus' package in Rust for the UI, so it's basically an HTML DOM and CSS styling. Of course I'll need custom control, but I want to make this game without a traditional "rendering engine" and instead rely on the DOM directly where possible.

The game itself is a card-based game, similar in vibes to Balatro but more coding-focused. The game consists of levels of ever-higher scores you need to achieve by repeatedly playing cards to score points. The cards are basically "code", that can double your bankroll, bet an amount, draw more cards, or shuffle the order of other cards in the hand about to be played, play the next card twice/thrice, and so forth. But, there should also be control flow cards that are non-trivial, for example a "loop card" that plays other cards while a condition is true, or conditional execution cards, as well as execution stack manipulation itself. All of these use cases need to be "unified" into a single format that is a super simple programming language with functions and arguments (for example, doubling your money would correspond to a function, and so on). In addition, occasionally there should be "wildcards" that allow arbitrary code in the language with a given length (i.e. up to 10 characters)

The language (let's call it The Kardinality Language or kardlang for short) needs to be super tied to the length of the input statements to be executed, with more powerful abilities only possible with additional characters. This is to avoid allowing "multiply_money(99999)" which quickly breaks the game. So, let's make numbers unary ("1111" is "four/4" because it is the number of 1s that determines the number. You could maybe write 4 as well for a shorthand, but it should act like it takes up more characters when considering the limits of a card.

So, the basic gameplay loop should be:

 * Start with some random cards, you must play a hand which is an ordered stack of cards
 * Each card is "executed" and its effects are applied, which may also entail changing the state of the interpreter itself (and thus, rerunning and earlier card, or skipping one)
 * Maybe you can trade or buy additional cards, or randomly deal them from a deck to try to improve better
 * You win each level when you achieve the score needed, and then the next level is a higher number

I want you to think of plans, how to make this game in Rust, and a basic project setup. This is for a 1-week gamejam, so we're targeting clean code and good Rust design patterns, but we don't want to overcomplicate the scope of the project.

It should be single-player, single-page game that all the logic is handled in Rust, and then displayed and interacted with DOM elements. Let's go!

---

**Cursor**

Got it. I’m going to (a) scaffold a minimal Rust+Dioxus WASM project that runs in the browser with essentially zero hand-written JS, (b) lay down a clean module structure for `game` + `kardlang` + `vm`, and (c) implement a tiny vertical-slice: draw a hand, click “Play hand”, run the interpreter over cards, and update score/bankroll in the DOM.

Nice — the workspace is empty, so we can scaffold a clean Rust project from scratch and bake in Dioxus + a tiny interpreter skeleton immediately. Next I’ll `cargo init`, add Dioxus web/WASM deps, and create the first “play a hand of cards” UI + core modules.

Aha—now that the crate exists, the key decision is the **web build toolchain** (Dioxus CLI vs Trunk). I’m going to quickly confirm the current “recommended” Dioxus web setup and API (`launch`, features, etc.), then I’ll wire in the dependencies + an initial UI and game/interpreter modules.

Nice — Dioxus’s current docs are pointing at the 0.6 line for web, with 0.7 already in alpha. I’ll target **stable 0.6.x** (less churn for a 1‑week jam), then wire up `dx serve` as the zero-JS-dev workflow and add a minimal “hand runner” UI.

---

**User**

This is great, but I also want you to draft me a "plan" and be a co-organizer of the project. i.e. draft milestones, order of tasks, importance, and so forth and set up a plan for this week. It's currently monday, it's due by Saturday night

---

**Cursor**

Totally — I’ll turn this into a 1‑week gamejam plan with an MVP you can ship by Saturday, plus a prioritized backlog and daily “definition of done”. Next I’ll write a milestone schedule (Mon→Sat), define the minimal vertical-slice, and drop it into a `PLAN.md` in the repo so we can keep it as the single source of truth.

Plan: define the MVP “vertical slice” we must hit by Wednesday, then layer control-flow cards, progression/shop, and polish. I’ll write a day-by-day schedule (Mon→Sat) with concrete deliverables and a small risk/mitigation list, and save it as `PLAN.md` in the repo.

Cool — we’ve got a clean empty crate, so we can treat `PLAN.md` as the project’s “single source of truth” for the week. Next I’ll write the Mon→Sat milestone schedule with an MVP cutline, then add a short architecture map so you can keep modules from getting tangled.

```markdown
## Kardinality — 1‑Week Gamejam Plan (Mon → Sat)

### Goal
Build a **single‑player, single‑page** browser game in **Rust → WASM** with **Dioxus** for DOM/CSS UI. Minimal/no hand‑written JS (use browser APIs via `web_sys`/`wasm_bindgen` when needed).

### North‑star MVP (what “shippable” means)
- **Core loop works**: draw a hand → play ordered stack → score/bankroll changes → clear level target → next level.
- **Cards feel like code**: cards execute effects, can change execution order/stack, and you can see a **trace** of what happened.
- **Kardlang exists** (v0): a tiny language that all cards compile/serialize to (even if authored via templates at first).
- **Safety limits**: max steps/iterations to prevent infinite loops or runaway effects.
- **Runs in browser** with `dx serve` for dev + `dx build --release` for shipping.

### Hard constraints
- **No traditional rendering engine**; rely on DOM where possible.
- **All game logic in Rust**; UI in Dioxus; JS only as glue generated by tooling.
- **Scope discipline**: if we’re behind by Thu, we cut features instead of widening the design.

### Key scope cuts (if needed)
- Cut the shop entirely (auto‑reward cards between levels).
- Cut wildcards (freeform code input) until after MVP.
- Cut nested blocks in Kardlang (support only simple `if`/`while` forms).

---

## Milestones by day (definition of done)

### Monday (Today): Project foundation + UI skeleton
**Done when:**
- Dioxus web app boots and shows a basic layout: **Hand**, **Status**, **Trace**, **Controls**.
- Core domain types exist: `GameState`, `Deck`, `Hand`, `Card`, `Level`.
- A “fake” hand can be rendered from Rust state; buttons update state deterministically.
- `README` includes dev/build commands.

**Tasks (priority order):**
- Get Dioxus web/WASM running via `dx`.
- Add baseline CSS and component layout.
- Create a deterministic RNG seed path for repeatable runs.

### Tuesday: Core game loop + hand executor (no Kardlang yet)
**Done when:**
- You can click **Play Hand** and the engine executes each card in order.
- At least 6–10 card effects exist as Rust built‑ins (e.g. add score, multiply, bet, draw, repeat next, shuffle).
- There is a **trace panel** showing executed steps and resulting state deltas.
- Level target increases; win/advance works for 3 levels.

**Tasks:**
- Implement hand execution engine with a program counter and a step limit.
- Implement a first pass on scoring/bankroll rules and balancing knobs.
- Add “Step” vs “Run” controls to support debugging (huge productivity boost for jam).

### Wednesday: Kardlang v0 (parser + cost model) + unify cards
**Done when:**
- Each card is represented as **Kardlang source** (or a compiled/parsed form) and executed by a single evaluator.
- Unary numbers work and a **cost model** exists (effective character count).
- One control‑flow primitive works end‑to‑end (e.g. `if` *or* `while`) with safety limits.
- Execution remains debuggable (trace includes Kardlang calls).

**Tasks:**
- Define Kardlang grammar (keep it tiny):
  - program = calls separated by whitespace/`;`
  - call = `name(args...)` with unary numbers (`111`) and optional digit shorthand (`4` costs as 4)
- Build parser → AST → evaluator that targets game ops.
- Add **max_steps / max_loop_iters** guardrails + friendly error UI.

### Thursday: Progression + shop/reward loop + more “codey” cards
**Done when:**
- After each level, you can **choose** a reward (new card / upgrade / remove card).
- Card pool includes a few spicy control/execution cards (repeat next N, conditional, loop, swap, jump).
- Difficulty scaling feels plausible (targets + rewards + risk).

**Tasks:**
- Add reward UI and deck modification operations.
- Expand card catalog to ~15–25 cards with clear categories (economy, draw, control, meta).
- Add simple rarity/weighting for draws.

### Friday: Wildcards + save/load + polish pass
**Done when:**
- Wildcard cards allow entering a short Kardlang snippet with a strict budget (e.g. 10 chars effective).
- Save/load run state via `localStorage` (or export/import string if simpler).
- UI is “jam presentable”: tooltips, readable trace, responsive layout, basic animations.

**Tasks:**
- Implement wildcard authoring UI (input + validation + error messages).
- Add persistence (serde + localStorage).
- Add tutorial/help overlay with 5–8 steps.

### Saturday: Stabilize + balance + ship
**Done when:**
- Full playthrough tested repeatedly; no hard locks; infinite loops are contained.
- Balance pass: targets scale, card pool isn’t degenerate, fun emerges.
- `dx build --release` outputs shippable artifacts and deployment steps are documented.

**Tasks:**
- Bug bash + tighten guardrails and error handling.
- Balance constants + card text clarity.
- Final README + screenshots/GIFs (optional but helps).

---

## Risks & mitigations
- **Toolchain friction (WASM/Dioxus)**: keep deps minimal; prove `dx serve` on Monday; avoid fancy build steps.
- **Language too ambitious**: start with *function calls + unary numbers* only; add blocks/looping only after evaluator works.
- **Infinite loops / runaway combos**: hard cap steps and iterations; display “execution aborted” with trace.
- **Balance time sink**: centralize knobs in one file; add debug shortcuts (e.g. +$100, skip level).

---

## Workstyle for the week (so we actually ship)
- **Always keep it playable**: no multi‑day refactors without a runnable slice.
- **Trace first**: the trace panel is your debugger and also a core part of the “coding vibes”.
- **Cut ruthlessly on Thu**: if MVP isn’t solid by Thu morning, we cut shop/wildcards before touching fundamentals.


```

Nice — we now have a concrete Mon→Sat schedule with a clear MVP cutline and scope cuts. Next I’ll add a short `ARCHITECTURE.md` that defines the module boundaries (UI vs game vs kardlang/vm) so we don’t accumulate spaghetti while iterating fast.

```markdown
## Kardinality — Architecture Notes (Jam‑friendly)

### Design goals
- **Playable at all times**: keep a vertical slice compiling/running daily.
- **Single source of truth**: game state lives in Rust; UI is a pure projection of state.
- **Debuggable by default**: the engine emits a **trace** (steps + state deltas) that the UI renders.
- **Deterministic runs**: seedable RNG so balancing and bugs are reproducible.

---

## Module map (recommended)
- `src/main.rs`
  - Dioxus entrypoint (`App`) and top‑level wiring.
- `src/ui/`
  - Dioxus components: `HandView`, `StatusPanel`, `TracePanel`, `RewardModal`, etc.
- `src/game/`
  - Pure game rules and data:
  - `state.rs`: `GameState`, `RunState`, `LevelState`
  - `cards.rs`: `CardDef` catalog + `CardInstance`
  - `deck.rs`: draw/shuffle/discard helpers
  - `executor.rs`: hand execution engine (program counter + safety)
- `src/kardlang/`
  - `lexer.rs` / `parser.rs` / `ast.rs`
  - `cost.rs`: “effective length” accounting (unary and digit shorthand)
- `src/vm/`
  - `machine.rs`: evaluator that maps Kardlang calls → game ops
  - `limits.rs`: max steps/iters + abort reasons
- `src/persist.rs`
  - Save/load (serde) + localStorage glue.

This layout keeps UI changes isolated from rules and interpreter churn.

---

## Core data model (minimal)
- **`CardDef`**: immutable definition (name, text, rarity, budget, kardlang template/source).
- **`CardInstance`**: a concrete card in deck/hand (id, def_id, upgrades, maybe custom wildcard source).
- **`Deck`**: `Vec<CardInstance>` plus discard pile (or a single vec + zones).
- **`Hand`**: ordered `Vec<CardInstance>`; this is the “program” you’re about to run.
- **`RunState`**:
  - bankroll, score, level_index, target_score
  - deck/hand/discard
  - rng_seed / rng_state

---

## Execution model (simple, expressive, safe)
Treat “play a hand” as executing a program with a **program counter**:
- `pc`: index into the hand (current card)
- `trace`: list of `StepEvent` for UI
- `limits`: `max_steps`, `max_loop_iters`

Each card resolves to a Kardlang program; the VM evaluates it and produces **effects**:
- effects update `RunState` (score/bankroll/deck/hand)
- some effects can **mutate control flow** (e.g. “repeat next”, “skip”, “jump”, “play previous”)

Jam‑friendly approach: represent control‑flow effects as mutations to `pc` or to a small “next execution queue”.

Safety:
- Count every executed VM call as 1 step.
- Abort with a user‑visible reason when limits are exceeded.

---

## Kardlang v0 (recommended constraints)
**Primary goal**: unify all cards behind a tiny format that’s cheap to parse and easy to budget.

### Surface syntax (v0)
- Program: sequence of calls separated by whitespace or `;`
- Call: `name(arg1,arg2,...)`
- Numbers:
  - unary: `1111` = 4
  - digit shorthand: `4` parses as 4 but costs as 4 (effective length)

### Cost model
Compute an **effective length** used for card budgets:
- normal characters cost 1
- each digit `0–9` costs its numeric value (so `4` costs 4)
- (optional later) identifiers may have a minimum cost to prevent long names being “free”

This lets you keep human‑readable scripts while controlling power.

---

## UI principles (Dioxus)
- Keep UI components pure: they read `GameState` and dispatch events.
- Always show:
  - current bankroll/score/target
  - the hand (ordered)
  - the trace (what executed, in what order, with deltas)

The trace doubles as both debugging tool and part of the “coding‑focused” vibe.


```

### Week plan (Mon → Sat, due Saturday night)
- **Monday**: Get Dioxus web/WASM booting, lay out UI (Hand/Status/Trace/Controls), define core state types, seedable RNG, document dev/build commands.
- **Tuesday**: Implement the **core loop** (draw → play ordered hand → score/bankroll → level target → advance) + ~10 starter card effects + a **trace panel** + step/run controls.
- **Wednesday (MVP cutline)**: Implement **Kardlang v0** (tiny grammar + unary numbers + effective-length cost model), unify cards behind the evaluator, add **hard safety limits** (max steps/iters) + friendly abort UI.
- **Thursday**: Add progression/reward/shop loop and expand “codey” cards (repeat/skip/jump/conditional/loop variants).
- **Friday**: Add **wildcards** (short freeform Kardlang under strict budget), **save/load** (localStorage), and a polish pass (tooltips/tutorial/responsive/CSS).
- **Saturday**: Bug bash + balance + `dx build --release` + deploy + final README/screenshots.

### Priority order (what we protect when time gets tight)
- **Playable vertical slice** → **trace/debug** → **Kardlang unify + safety** → **control-flow cards** → **progression/shop** → **wildcards/persistence** → **polish/content**

### Repo organizer docs (already added)
- **`PLAN.md`**: the day-by-day milestones, MVP definition, scope cuts, risks.
- **`ARCHITECTURE.md`**: module boundaries + execution model + Kardlang v0 constraints.

### Two quick choices (optional, but helps planning)
- **Deploy target**: GitHub Pages vs Netlify vs itch.io?
- **Kardlang UX**: mostly “under the hood” behind cards, or do you want players typing it frequently (more editor/parser investment)?

---

**User**

This is great, but I also want you to draft me a "plan" and be a co-organizer of the project. i.e. draft milestones, order of tasks, importance, and so forth and set up a plan for this week. It's currently monday, it's due by Saturday night

---

**Cursor**

### Week schedule (Mon → Sat, due Sat night)
- **Mon**: Dioxus web/WASM boots, UI skeleton (Hand/Status/Trace/Controls), core `GameState` types, seedable RNG, dev/build commands documented.
- **Tue**: Core loop (draw → play ordered hand → score/bankroll → level target → advance) + ~10 starter cards + trace + step/run controls.
- **Wed (MVP cutline)**: **Kardlang v0** (tiny grammar + unary numbers + “effective length” cost model) + cards unified behind the evaluator + hard safety limits (max steps/iters).
- **Thu**: Progression/reward/shop loop + more “codey” control-flow/execution cards.
- **Fri**: Wildcards (short freeform Kardlang under strict budget) + save/load (localStorage) + polish (tooltips/tutorial/responsive/CSS).
- **Sat**: Bug bash + balance + `dx build --release` + deploy + final README.

### Priority order (what we protect)
- **Playable vertical slice** → **trace/debug** → **Kardlang unify + safety** → **control-flow cards** → **progression/shop** → **wildcards/persistence** → **polish/content**

### Repo organizer docs (already in the workspace)
- **`PLAN.md`**: milestones, MVP definition, scope cuts, risks.
- **`ARCHITECTURE.md`**: module boundaries + execution model + Kardlang v0 constraints.

### Two decisions that affect the plan (tell me which you want)
- **Deploy target**: GitHub Pages vs Netlify vs itch.io?
- **Kardlang UX**: mostly “behind cards” vs players typing it frequently (bigger editor/parser investment).

Plan: I’ll (1) reformat `PLAN.md` and `ARCHITECTURE.md` to proper Markdown spacing (blank lines after headings) and switch all lists to `*` bullets, then (2) add a clean `README.md` + an `AGENTS.md` “handoff” doc for future AI agents (commands, conventions, where to change things).

Got it. I’ll reformat `PLAN.md` + `ARCHITECTURE.md` to “proper” Markdown (blank line after every heading, and `*` bullets everywhere), then add `README.md` + a future‑AI handoff doc `AGENTS.md` (this is the most common convention; we can also collapse the other docs into it later if you prefer fewer files).

```markdown
## Kardinality — 1‑Week Gamejam Plan (Mon → Sat)

### Goal

Build a **single‑player, single‑page** browser game in **Rust → WASM** with **Dioxus** for DOM/CSS UI. Minimal/no hand‑written JS (use browser APIs via `web_sys`/`wasm_bindgen` when needed).

### North‑star MVP (what “shippable” means)

* **Core loop works**: draw a hand → play ordered stack → score/bankroll changes → clear level target → next level.
* **Cards feel like code**: cards execute effects, can change execution order/stack, and you can see a **trace** of what happened.
* **Kardlang exists** (v0): a tiny language that all cards compile/serialize to (even if authored via templates at first).
* **Safety limits**: max steps/iterations to prevent infinite loops or runaway effects.
* **Runs in browser** with `dx serve` for dev + `dx build --release` for shipping.

### Hard constraints

* **No traditional rendering engine**; rely on DOM where possible.
* **All game logic in Rust**; UI in Dioxus; JS only as glue generated by tooling.
* **Scope discipline**: if we’re behind by Thu, we cut features instead of widening the design.

### Key scope cuts (if needed)

* Cut the shop entirely (auto‑reward cards between levels).
* Cut wildcards (freeform code input) until after MVP.
* Cut nested blocks in Kardlang (support only simple `if`/`while` forms).

---

## Milestones by day (definition of done)

### Monday (Today): Project foundation + UI skeleton

**Done when:**

* Dioxus web app boots and shows a basic layout: **Hand**, **Status**, **Trace**, **Controls**.
* Core domain types exist: `GameState`, `Deck`, `Hand`, `Card`, `Level`.
* A “fake” hand can be rendered from Rust state; buttons update state deterministically.
* `README` includes dev/build commands.

**Tasks (priority order):**

* Get Dioxus web/WASM running via `dx`.
* Add baseline CSS and component layout.
* Create a deterministic RNG seed path for repeatable runs.

### Tuesday: Core game loop + hand executor (no Kardlang yet)

**Done when:**

* You can click **Play Hand** and the engine executes each card in order.
* At least 6–10 card effects exist as Rust built‑ins (e.g. add score, multiply, bet, draw, repeat next, shuffle).
* There is a **trace panel** showing executed steps and resulting state deltas.
* Level target increases; win/advance works for 3 levels.

**Tasks:**

* Implement hand execution engine with a program counter and a step limit.
* Implement a first pass on scoring/bankroll rules and balancing knobs.
* Add “Step” vs “Run” controls to support debugging (huge productivity boost for jam).

### Wednesday: Kardlang v0 (parser + cost model) + unify cards

**Done when:**

* Each card is represented as **Kardlang source** (or a compiled/parsed form) and executed by a single evaluator.
* Unary numbers work and a **cost model** exists (effective character count).
* One control‑flow primitive works end‑to‑end (e.g. `if` *or* `while`) with safety limits.
* Execution remains debuggable (trace includes Kardlang calls).

**Tasks:**

* Define Kardlang grammar (keep it tiny):
  * program = calls separated by whitespace/`;`
  * call = `name(args...)` with unary numbers (`111`) and optional digit shorthand (`4` costs as 4)
* Build parser → AST → evaluator that targets game ops.
* Add **max_steps / max_loop_iters** guardrails + friendly error UI.

### Thursday: Progression + shop/reward loop + more “codey” cards

**Done when:**

* After each level, you can **choose** a reward (new card / upgrade / remove card).
* Card pool includes a few spicy control/execution cards (repeat next N, conditional, loop, swap, jump).
* Difficulty scaling feels plausible (targets + rewards + risk).

**Tasks:**

* Add reward UI and deck modification operations.
* Expand card catalog to ~15–25 cards with clear categories (economy, draw, control, meta).
* Add simple rarity/weighting for draws.

### Friday: Wildcards + save/load + polish pass

**Done when:**

* Wildcard cards allow entering a short Kardlang snippet with a strict budget (e.g. 10 chars effective).
* Save/load run state via `localStorage` (or export/import string if simpler).
* UI is “jam presentable”: tooltips, readable trace, responsive layout, basic animations.

**Tasks:**

* Implement wildcard authoring UI (input + validation + error messages).
* Add persistence (serde + localStorage).
* Add tutorial/help overlay with 5–8 steps.

### Saturday: Stabilize + balance + ship

**Done when:**

* Full playthrough tested repeatedly; no hard locks; infinite loops are contained.
* Balance pass: targets scale, card pool isn’t degenerate, fun emerges.
* `dx build --release` outputs shippable artifacts and deployment steps are documented.

**Tasks:**

* Bug bash + tighten guardrails and error handling.
* Balance constants + card text clarity.
* Final README + screenshots/GIFs (optional but helps).

---

## Risks & mitigations

* **Toolchain friction (WASM/Dioxus)**: keep deps minimal; prove `dx serve` on Monday; avoid fancy build steps.
* **Language too ambitious**: start with *function calls + unary numbers* only; add blocks/looping only after evaluator works.
* **Infinite loops / runaway combos**: hard cap steps and iterations; display “execution aborted” with trace.
* **Balance time sink**: centralize knobs in one file; add debug shortcuts (e.g. +$100, skip level).

---

## Workstyle for the week (so we actually ship)

* **Always keep it playable**: no multi‑day refactors without a runnable slice.
* **Trace first**: the trace panel is your debugger and also a core part of the “coding vibes”.
* **Cut ruthlessly on Thu**: if MVP isn’t solid by Thu morning, we cut shop/wildcards before touching fundamentals.

```

Nice — `PLAN.md` is now in the “blank line after headings + `*` bullets” format you want. Next I’ll do the same cleanup for `ARCHITECTURE.md`, then add a concise `README.md` and an `AGENTS.md` that future AI agents can follow without re-deriving context.

```markdown
## Kardinality — Architecture Notes (Jam‑friendly)

### Design goals

* **Playable at all times**: keep a vertical slice compiling/running daily.
* **Single source of truth**: game state lives in Rust; UI is a pure projection of state.
* **Debuggable by default**: the engine emits a **trace** (steps + state deltas) that the UI renders.
* **Deterministic runs**: seedable RNG so balancing and bugs are reproducible.

---

## Module map (recommended)

* `src/main.rs`
  * Dioxus entrypoint (`App`) and top‑level wiring.
* `src/ui/`
  * Dioxus components: `HandView`, `StatusPanel`, `TracePanel`, `RewardModal`, etc.
* `src/game/`
  * Pure game rules and data:
  * `state.rs`: `GameState`, `RunState`, `LevelState`
  * `cards.rs`: `CardDef` catalog + `CardInstance`
  * `deck.rs`: draw/shuffle/discard helpers
  * `executor.rs`: hand execution engine (program counter + safety)
* `src/kardlang/`
  * `lexer.rs` / `parser.rs` / `ast.rs`
  * `cost.rs`: “effective length” accounting (unary and digit shorthand)
* `src/vm/`
  * `machine.rs`: evaluator that maps Kardlang calls → game ops
  * `limits.rs`: max steps/iters + abort reasons
* `src/persist.rs`
  * Save/load (serde) + localStorage glue.

This layout keeps UI changes isolated from rules and interpreter churn.

---

## Core data model (minimal)

* **`CardDef`**: immutable definition (name, text, rarity, budget, kardlang template/source).
* **`CardInstance`**: a concrete card in deck/hand (id, def_id, upgrades, maybe custom wildcard source).
* **`Deck`**: `Vec<CardInstance>` plus discard pile (or a single vec + zones).
* **`Hand`**: ordered `Vec<CardInstance>`; this is the “program” you’re about to run.
* **`RunState`**:
  * bankroll, score, level_index, target_score
  * deck/hand/discard
  * rng_seed / rng_state

---

## Execution model (simple, expressive, safe)
Treat “play a hand” as executing a program with a **program counter**:

* `pc`: index into the hand (current card)
* `trace`: list of `StepEvent` for UI
* `limits`: `max_steps`, `max_loop_iters`

Each card resolves to a Kardlang program; the VM evaluates it and produces **effects**:

* effects update `RunState` (score/bankroll/deck/hand)
* some effects can **mutate control flow** (e.g. “repeat next”, “skip”, “jump”, “play previous”)

Jam‑friendly approach: represent control‑flow effects as mutations to `pc` or to a small “next execution queue”.

Safety:

* Count every executed VM call as 1 step.
* Abort with a user‑visible reason when limits are exceeded.

---

## Kardlang v0 (recommended constraints)
**Primary goal**: unify all cards behind a tiny format that’s cheap to parse and easy to budget.

### Surface syntax (v0)

* Program: sequence of calls separated by whitespace or `;`
* Call: `name(arg1,arg2,...)`
* Numbers:
  * unary: `1111` = 4
  * digit shorthand: `4` parses as 4 but costs as 4 (effective length)

### Cost model
Compute an **effective length** used for card budgets:

* normal characters cost 1
* each digit `0–9` costs its numeric value (so `4` costs 4)
* (optional later) identifiers may have a minimum cost to prevent long names being “free”

This lets you keep human‑readable scripts while controlling power.

---

## UI principles (Dioxus)

* Keep UI components pure: they read `GameState` and dispatch events.
* Always show:
  * current bankroll/score/target
  * the hand (ordered)
  * the trace (what executed, in what order, with deltas)

The trace doubles as both debugging tool and part of the “coding‑focused” vibe.

```

```markdown
## Kardinality

Kardinality is a **single‑player, browser‑deployed** card game where your “hand” is an ordered stack of executable code‑cards. The vibe is roguelike deck‑building (Balatro‑adjacent), but the mechanics are intentionally **programming‑shaped**: cards compose, control flow exists, and you win by hitting ever‑higher score targets.

### Tech stack

* **Rust**: all game logic (rules, state, interpreter)
* **WASM (web)**: cross‑platform browser deploy
* **Dioxus**: UI rendered via **HTML DOM + CSS**, no traditional rendering engine
* **Browser APIs**: accessed from Rust (`web_sys` / `wasm_bindgen`) with minimal/no hand‑written JS

### Quick start (dev)

This will be the intended workflow once the Dioxus web setup lands:

* Install Rust (stable) and add the WASM target:
  * `rustup target add wasm32-unknown-unknown`
* Install Dioxus CLI:
  * `cargo install dioxus-cli`
* Run the dev server:
  * `dx serve`
* Build for release:
  * `dx build --release`

### Docs

* `PLAN.md`: Mon→Sat jam milestones + MVP cutline
* `ARCHITECTURE.md`: module boundaries + execution model + Kardlang constraints
* `AGENTS.md`: guidance for future AI agents (commands, constraints, conventions)


```

```markdown
## Kardinality — AGENTS.md (AI / automation guide)

This file exists so future AI agents (or automation) can make **coherent changes quickly** without re‑deriving project intent, constraints, and workflow.

### Mission

Ship a fun, jam‑scoped, browser game where **cards are code** and card execution is unified through a tiny language (“Kardlang”), with the UI rendered using **DOM + CSS** via Dioxus.

### Hard constraints (do not violate)

* **Rust owns the logic**: game rules, interpreter, progression, persistence.
* **DOM‑first rendering**: no traditional rendering engine; lean on Dioxus + CSS.
* **Minimal/no hand‑written JS**: use browser APIs through Rust (`web_sys` / `wasm_bindgen`) when needed.
* **Safety limits always on**: execution must have max steps / max loop iterations and abort cleanly.

### MVP cutline (Wednesday)

* The game is playable end‑to‑end: draw → play hand → score/bankroll changes → level targets → advance.
* A **trace panel** exists (it’s both debugging and core UX).
* Kardlang v0 works (unary numbers + cost model) and cards execute through one evaluator.

If the build isn’t solid by Thu, cut shop/wildcards before touching fundamentals.

### Commands (intended)

* Dev server: `dx serve`
* Release build: `dx build --release`
* Format: `cargo fmt`
* Tests: `cargo test`

### Conventions

* Prefer small, composable modules: `game/`, `kardlang/`, `vm/`, `ui/`.
* Keep runs deterministic: seedable RNG and reproducible outcomes for balancing/debugging.
* “Trace‑first” development: if you add new effects/control flow, add trace output too.
* Markdown style in this repo:
  * Blank line after headings
  * Use `*` bullets (not `-`)


```

```markdown
## Kardinality — Architecture Notes (Jam‑friendly)

### Design goals

* **Playable at all times**: keep a vertical slice compiling/running daily.
* **Single source of truth**: game state lives in Rust; UI is a pure projection of state.
* **Debuggable by default**: the engine emits a **trace** (steps + state deltas) that the UI renders.
* **Deterministic runs**: seedable RNG so balancing and bugs are reproducible.

---

## Module map (recommended)

* `src/main.rs`
  * Dioxus entrypoint (`App`) and top‑level wiring.
* `src/ui/`
  * Dioxus components: `HandView`, `StatusPanel`, `TracePanel`, `RewardModal`, etc.
* `src/game/`
  * Pure game rules and data:
  * `state.rs`: `GameState`, `RunState`, `LevelState`
  * `cards.rs`: `CardDef` catalog + `CardInstance`
  * `deck.rs`: draw/shuffle/discard helpers
  * `executor.rs`: hand execution engine (program counter + safety)
* `src/kardlang/`
  * `lexer.rs` / `parser.rs` / `ast.rs`
  * `cost.rs`: “effective length” accounting (unary and digit shorthand)
* `src/vm/`
  * `machine.rs`: evaluator that maps Kardlang calls → game ops
  * `limits.rs`: max steps/iters + abort reasons
* `src/persist.rs`
  * Save/load (serde) + localStorage glue.

This layout keeps UI changes isolated from rules and interpreter churn.

---

## Core data model (minimal)

* **`CardDef`**: immutable definition (name, text, rarity, budget, kardlang template/source).
* **`CardInstance`**: a concrete card in deck/hand (id, def_id, upgrades, maybe custom wildcard source).
* **`Deck`**: `Vec<CardInstance>` plus discard pile (or a single vec + zones).
* **`Hand`**: ordered `Vec<CardInstance>`; this is the “program” you’re about to run.
* **`RunState`**:
  * bankroll, score, level_index, target_score
  * deck/hand/discard
  * rng_seed / rng_state

---

## Execution model (simple, expressive, safe)

Treat “play a hand” as executing a program with a **program counter**:

* `pc`: index into the hand (current card)
* `trace`: list of `StepEvent` for UI
* `limits`: `max_steps`, `max_loop_iters`

Each card resolves to a Kardlang program; the VM evaluates it and produces **effects**:

* effects update `RunState` (score/bankroll/deck/hand)
* some effects can **mutate control flow** (e.g. “repeat next”, “skip”, “jump”, “play previous”)

Jam‑friendly approach: represent control‑flow effects as mutations to `pc` or to a small “next execution queue”.

Safety:

* Count every executed VM call as 1 step.
* Abort with a user‑visible reason when limits are exceeded.

---

## Kardlang v0 (recommended constraints)

**Primary goal**: unify all cards behind a tiny format that’s cheap to parse and easy to budget.

### Surface syntax (v0)

* Program: sequence of calls separated by whitespace or `;`
* Call: `name(arg1,arg2,...)`
* Numbers:
  * unary: `1111` = 4
  * digit shorthand: `4` parses as 4 but costs as 4 (effective length)

### Cost model

Compute an **effective length** used for card budgets:

* normal characters cost 1
* each digit `0–9` costs its numeric value (so `4` costs 4)
* (optional later) identifiers may have a minimum cost to prevent long names being “free”

This lets you keep human‑readable scripts while controlling power.

---

## UI principles (Dioxus)

* Keep UI components pure: they read `GameState` and dispatch events.
* Always show:
  * current bankroll/score/target
  * the hand (ordered)
  * the trace (what executed, in what order, with deltas)

The trace doubles as both debugging tool and part of the “coding‑focused” vibe.

```

### Markdown fixes + new docs

* **Fixed spacing + list style** in `PLAN.md` and `ARCHITECTURE.md`:
  * Blank line after headings
  * `*` bullets everywhere (including nested lists)
* **Added `README.md`** as the repo entry point (what it is, stack, intended commands, doc links).
* **Added `AGENTS.md`** as the “future AI agent handoff” doc (mission, constraints, MVP cutline, commands, conventions).

### What markdown files you probably want (jam‑scoped)

* **`README.md`**: required (first stop for humans).
* **`AGENTS.md`**: required (first stop for future AI agents / automation).
* **`PLAN.md`**: useful during the jam; after Saturday we can archive/move/delete.
* **`ARCHITECTURE.md`**: optional; if you want fewer files, we can merge it into `AGENTS.md` and delete it.

### “Standard” for AI agent instructions

* **`AGENTS.md`** is a solid cross‑tool convention (human readable, easy for agents to ingest).
* If you also want tool‑specific auto‑loading later, we can add that separately (e.g. Cursor rules), but `AGENTS.md` is the best “portable” baseline.

If you tell me “keep” vs “merge+delete” for `PLAN.md`/`ARCHITECTURE.md`, I’ll align the docs accordingly.

---

**User**

Let's just delete plan and architecture

---

**Cursor**

Plan: delete `PLAN.md` and `ARCHITECTURE.md`, then update `README.md` so it doesn’t reference files that no longer exist.

```markdown
## Kardinality

Kardinality is a **single‑player, browser‑deployed** card game where your “hand” is an ordered stack of executable code‑cards. The vibe is roguelike deck‑building (Balatro‑adjacent), but the mechanics are intentionally **programming‑shaped**: cards compose, control flow exists, and you win by hitting ever‑higher score targets.

### Tech stack

* **Rust**: all game logic (rules, state, interpreter)
* **WASM (web)**: cross‑platform browser deploy
* **Dioxus**: UI rendered via **HTML DOM + CSS**, no traditional rendering engine
* **Browser APIs**: accessed from Rust (`web_sys` / `wasm_bindgen`) with minimal/no hand‑written JS

### Quick start (dev)

This will be the intended workflow once the Dioxus web setup lands:

* Install Rust (stable) and add the WASM target:
  * `rustup target add wasm32-unknown-unknown`
* Install Dioxus CLI:
  * `cargo install dioxus-cli`
* Run the dev server:
  * `dx serve`
* Build for release:
  * `dx build --release`

### Docs

* `AGENTS.md`: guidance for future AI agents (commands, constraints, conventions)



```

### Done

* Deleted `PLAN.md`
* Deleted `ARCHITECTURE.md`
* Updated `README.md` to remove references to those files

---

**User**

Okay, can you go ahead and start making it? Before you write any code, come up with an overall architecture plan. I'm thinking we want one place to handle all game logic (no rendering or user input), and we write test cases to handle how game states evolve

---

**Cursor**

Plan: I’ll outline a clean “core engine + web UI shell” architecture (pure Rust logic, deterministic, fully testable), then immediately scaffold the modules (`src/lib.rs` + `engine/` + `kardlang/` stubs) and add a couple state-evolution tests. After that we’ll hook up a minimal Dioxus UI that just dispatches `Action`s and renders `GameState` + trace.

Here’s the **overall architecture plan** (pure core logic + testable state evolution), before I touch any gameplay/UI code.

### Architecture (layers + responsibilities)

- **Core engine (`src/lib.rs` + `game/`, `kardlang/`, `vm/`)**
  - **Owns all rules/state**. No rendering, no browser APIs, no Dioxus types.
  - Public API is just: **state in**, **action in**, **state/events out**.
  - Designed so `cargo test` runs natively and deterministically.

- **Web UI shell (`src/main.rs` + optional `ui/`)**
  - Dioxus components render `GameState` and a **trace panel**.
  - UI only dispatches `Action`s; it never mutates game state directly.
  - Browser-only pieces (localStorage, clipboard, etc.) live here, behind `cfg(target_arch="wasm32")`.

### Core engine API (single “place” for game logic)

- **`GameState`**: pure data (bankroll/score/level target + deck/hand/discard + phase).
- **`Action`**: the *only* inputs from outside (button clicks, selections, etc.).
  - Examples: `NewRun { seed }`, `DrawHand`, `PlayHand { mode }`, `ChooseReward`, `EditWildcard { … }`.
- **`Engine`**: owns `GameState` + deterministic RNG + safety limits.
  - `engine.dispatch(action) -> Outcome`
  - `Outcome` contains emitted **`TraceEvent`s** (and maybe a recoverable error).
- **`TraceEvent`**: append-only “what happened” log (core debugging + UX).

### Execution model (hand/program runner)

- Hand play uses a **program counter** loop:
  - `pc` points at current card index
  - each card resolves to **Kardlang source → AST → VM eval → Effects**
  - Effects mutate `GameState` and can optionally emit **control-flow effects** (later) that adjust `pc`
- **Safety**: hard caps in one place:
  - `max_steps` (total ops per hand)
  - `max_loop_iters` (for future `while/loop` constructs)
  - abort is clean and shows in trace

### Kardlang + VM (unification point)

- **`kardlang/`**
  - Parser → AST for a tiny call-based language
  - Unary numbers (`1111` = 4) + optional digit shorthand (`4`), with a **cost model**
- **`vm/`**
  - Evaluates AST to a list of **`Effect`** values (pure), or errors with context
  - Game layer applies effects to `GameState` and records trace

### Testing strategy (state evolution)

- **Unit tests**
  - `kardlang` parsing + cost model
  - VM opcode behavior (given a call → expected effects / errors)
- **Integration-ish engine tests**
  - Instantiate `Engine::new(seed)` with a known deck
  - Dispatch a sequence of actions
  - Assert on final `GameState` + selected `TraceEvent`s
- Determinism rule: no `thread_rng`, no time, no browser entropy inside core.

Next I’ll scaffold `src/lib.rs` with `game/`, `kardlang/`, `vm/`, add 2–3 starter actions and a couple core tests, and then wire a minimal Dioxus UI that just dispatches actions and renders state + trace.

Nice — now that we have the core layering nailed, I’m going to scaffold the **pure Rust library** (`src/lib.rs` + `game/`, `kardlang/`, `vm/`) with a couple deterministic tests, and only then wire the wasm-only Dioxus `main.rs`. First I’ll confirm the exact Dioxus 0.6 entrypoint signature from official docs so we don’t fight API churn.

Got it — core-first. Next I’m going to add a `src/lib.rs` library with `game/`, `kardlang/`, and `vm/` modules, define `Engine/GameState/Action/TraceEvent`, and write a couple deterministic tests that assert state evolution when a hand is played.

```toml
[package]
name = "kardinality"
version = "0.1.0"
edition = "2024"

[dependencies]
rand = "0.8"
rand_chacha = "0.3"
serde = { version = "1", features = ["derive"] }
thiserror = "1"

```

```rust
pub mod game;
pub mod kardlang;
pub mod vm;

pub use game::{Action, Engine, GameError, GameState, TraceEvent};


```

```rust
mod engine;
mod model;
mod trace;

pub use engine::{Action, Engine, GameError};
pub use model::{Card, GameState, Phase};
pub use trace::TraceEvent;


```

```rust
use serde::{Deserialize, Serialize};

use crate::vm::Limits;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Phase {
    InLevel,
    Reward,
    GameOver,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Card {
    pub name: String,
    pub script: String,
    pub budget: usize,
}

impl Card {
    pub fn new(name: impl Into<String>, script: impl Into<String>, budget: usize) -> Self {
        Self {
            name: name.into(),
            script: script.into(),
            budget,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct GameState {
    pub bankroll: i64,
    pub score: i64,
    pub level: u32,
    pub target_score: i64,
    pub phase: Phase,

    pub deck: Vec<Card>,
    pub hand: Vec<Card>,
    pub discard: Vec<Card>,

    pub trace: Vec<crate::game::TraceEvent>,

    pub limits: Limits,
}

impl GameState {
    pub fn new(deck: Vec<Card>, limits: Limits) -> Self {
        Self {
            bankroll: 10,
            score: 0,
            level: 1,
            target_score: 10,
            phase: Phase::InLevel,
            deck,
            hand: Vec::new(),
            discard: Vec::new(),
            trace: Vec::new(),
            limits,
        }
    }
}


```

Nice — we now have the skeleton of a “core library crate” (`src/lib.rs`) and a dedicated `game/` module, which is the key to keeping all rules testable and UI-agnostic. Next I’ll add `kardlang/` + `vm/` with a tiny call parser and a step-limited evaluator, then wire `Engine::dispatch` and add the first state-evolution tests.

```rust
use serde::{Deserialize, Serialize};

use crate::vm::Effect;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TraceEvent {
    Action { action: String },
    CardStart {
        index: usize,
        name: String,
        script: String,
        budget: usize,
        cost: usize,
    },
    Call { name: String, args: Vec<u32> },
    EffectApplied { effect: Effect },
    Info(String),
    Error(String),
}


```

```rust
use rand::seq::SliceRandom;
use rand_chacha::ChaCha8Rng;
use rand_core::SeedableRng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmError};

use super::{Card, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawHand { count: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        Self::with_deck(seed, starter_deck(), Limits::default())
    }

    pub fn with_deck(seed: u64, mut deck: Vec<Card>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawHand { count } => self.draw_hand(count),
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_hand(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.hand.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<Card>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        for (index, card) in self.state.hand.iter().cloned().enumerate() {
            let cost = effective_len(&card.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: card.name.clone(),
                script: card.script.clone(),
                budget: card.budget,
                cost,
            });

            if cost > card.budget {
                return Err(GameError::CardOverBudget {
                    name: card.name,
                    cost,
                    budget: card.budget,
                });
            }

            let program = parse_program(&card.script)?;
            for call in &program.calls {
                let args = call
                    .args
                    .iter()
                    .map(|v| v.as_u32())
                    .collect::<Option<Vec<_>>>()
                    .unwrap_or_default();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let effects = vm.eval_call(call)?;
                self.apply_effects(effects);
            }

            self.state.discard.push(card);
        }

        self.state.hand.clear();

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn starter_deck() -> Vec<Card> {
    vec![
        Card::new("Score +2", "score(11)", 12),
        Card::new("Score +2", "score(11)", 12),
        Card::new("Bank +3", "bank(111)", 12),
        Card::new("Double Bank", "dbl()", 12),
    ]
}


```

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmError};

use super::{Card, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawHand { count: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        Self::with_deck(seed, starter_deck(), Limits::default())
    }

    pub fn with_deck(seed: u64, mut deck: Vec<Card>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawHand { count } => self.draw_hand(count),
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_hand(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.hand.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<Card>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        for (index, card) in self.state.hand.iter().cloned().enumerate() {
            let cost = effective_len(&card.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: card.name.clone(),
                script: card.script.clone(),
                budget: card.budget,
                cost,
            });

            if cost > card.budget {
                return Err(GameError::CardOverBudget {
                    name: card.name,
                    cost,
                    budget: card.budget,
                });
            }

            let program = parse_program(&card.script)?;
            for call in &program.calls {
                let args = call
                    .args
                    .iter()
                    .map(|v| v.as_u32())
                    .collect::<Option<Vec<_>>>()
                    .unwrap_or_default();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let effects = vm.eval_call(call)?;
                self.apply_effects(effects);
            }

            self.state.discard.push(card);
        }

        self.state.hand.clear();

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn starter_deck() -> Vec<Card> {
    vec![
        Card::new("Score +2", "score(11)", 12),
        Card::new("Score +2", "score(11)", 12),
        Card::new("Bank +3", "bank(111)", 12),
        Card::new("Double Bank", "dbl()", 12),
    ]
}



```

```rust
mod ast;
mod cost;
mod parser;

pub use ast::{Call, Program, Value};
pub use cost::effective_len;
pub use parser::{parse_program, ParseError};


```

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Program {
    pub calls: Vec<Call>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Call {
    pub name: String,
    pub args: Vec<Value>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Value {
    Num(u32),
}

impl Value {
    pub fn as_u32(&self) -> Option<u32> {
        match self {
            Value::Num(n) => Some(*n),
        }
    }
}


```

```rust
pub fn effective_len(source: &str) -> usize {
    source
        .chars()
        .map(|c| match c {
            '0' => 1,
            '1'..='9' => c.to_digit(10).unwrap_or(1) as usize,
            _ => 1,
        })
        .sum()
}


```

```rust
use thiserror::Error;

use super::ast::{Call, Program, Value};

#[derive(Debug, Clone, PartialEq, Eq, Error)]
#[error("{message} at byte {pos}")]
pub struct ParseError {
    pub message: String,
    pub pos: usize,
}

pub fn parse_program(input: &str) -> Result<Program, ParseError> {
    let mut p = Parser::new(input);
    let mut calls = Vec::new();

    p.skip_ws_and_semi();
    while !p.is_eof() {
        calls.push(p.parse_call()?);
        p.skip_ws_and_semi();
    }

    Ok(Program { calls })
}

struct Parser<'a> {
    input: &'a str,
    pos: usize,
}

impl<'a> Parser<'a> {
    fn new(input: &'a str) -> Self {
        Self { input, pos: 0 }
    }

    fn is_eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    fn peek_char(&self) -> Option<char> {
        self.input[self.pos..].chars().next()
    }

    fn bump_char(&mut self) -> Option<char> {
        let c = self.peek_char()?;
        self.pos += c.len_utf8();
        Some(c)
    }

    fn skip_ws_and_semi(&mut self) {
        while matches!(self.peek_char(), Some(c) if c.is_whitespace() || c == ';') {
            self.bump_char();
        }
    }

    fn expect_char(&mut self, expected: char) -> Result<(), ParseError> {
        match self.bump_char() {
            Some(c) if c == expected => Ok(()),
            Some(_) | None => Err(self.err(format!("expected '{expected}'"))),
        }
    }

    fn parse_call(&mut self) -> Result<Call, ParseError> {
        self.skip_ws_and_semi();
        let name = self.parse_ident()?;
        self.skip_ws_and_semi();
        self.expect_char('(')?;
        self.skip_ws_and_semi();

        let mut args = Vec::new();
        if matches!(self.peek_char(), Some(')')) {
            self.bump_char();
            return Ok(Call { name, args });
        }

        loop {
            self.skip_ws_and_semi();
            args.push(self.parse_number_value()?);
            self.skip_ws_and_semi();

            match self.peek_char() {
                Some(',') => {
                    self.bump_char();
                    continue;
                }
                Some(')') => {
                    self.bump_char();
                    break;
                }
                _ => return Err(self.err("expected ',' or ')'".to_string())),
            }
        }

        Ok(Call { name, args })
    }

    fn parse_ident(&mut self) -> Result<String, ParseError> {
        let start = self.pos;

        match self.peek_char() {
            Some(c) if c.is_ascii_alphabetic() || c == '_' => {
                self.bump_char();
            }
            _ => return Err(self.err("expected identifier".to_string())),
        }

        while matches!(self.peek_char(), Some(c) if c.is_ascii_alphanumeric() || c == '_') {
            self.bump_char();
        }

        Ok(self.input[start..self.pos].to_string())
    }

    fn parse_number_value(&mut self) -> Result<Value, ParseError> {
        let start = self.pos;

        match self.peek_char() {
            Some('1') => {
                let mut count = 0u32;
                while matches!(self.peek_char(), Some('1')) {
                    self.bump_char();
                    count += 1;
                }
                Ok(Value::Num(count))
            }
            Some(c @ '2'..='9') => {
                self.bump_char();
                let n = c.to_digit(10).unwrap_or(0);
                Ok(Value::Num(n))
            }
            Some('0') => Err(self.err("digit shorthand cannot be 0".to_string())),
            _ => {
                // This is intentionally strict: v0 numbers are unary or single-digit shorthand.
                let got = self.input[start..]
                    .chars()
                    .next()
                    .map(|c| c.to_string())
                    .unwrap_or_else(|| "EOF".to_string());
                Err(self.err(format!("expected number (unary '1…' or digit 2-9), got {got}")))
            }
        }
    }

    fn err(&self, message: String) -> ParseError {
        ParseError {
            message,
            pos: self.pos,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parses_simple_calls() {
        let p = parse_program("score(11); bank(3) dbl()").unwrap();
        assert_eq!(p.calls.len(), 3);
        assert_eq!(p.calls[0].name, "score");
        assert_eq!(p.calls[0].args, vec![Value::Num(2)]);
        assert_eq!(p.calls[1].args, vec![Value::Num(3)]);
        assert_eq!(p.calls[2].args.len(), 0);
    }

    #[test]
    fn rejects_zero_digit() {
        let err = parse_program("score(0)").unwrap_err();
        assert!(err.message.contains("cannot be 0"));
    }
}


```

```rust
mod effects;
mod limits;
mod machine;

pub use effects::Effect;
pub use limits::Limits;
pub use machine::{Machine, VmError};


```

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub struct Limits {
    pub max_steps: usize,
    pub max_loop_iters: usize,
}

impl Default for Limits {
    fn default() -> Self {
        Self {
            max_steps: 200,
            max_loop_iters: 50,
        }
    }
}


```

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Effect {
    AddScore(i64),
    AddBankroll(i64),
    MulBankroll(i64),
}


```

```rust
use thiserror::Error;

use crate::kardlang::Call;

use super::{Effect, Limits};

#[derive(Debug, Clone, PartialEq, Eq, Error)]
pub enum VmError {
    #[error("unknown function: {0}")]
    UnknownFunction(String),

    #[error("wrong arity for {name}: expected {expected}, got {got}")]
    WrongArity {
        name: String,
        expected: usize,
        got: usize,
    },

    #[error("execution aborted: exceeded max steps ({max_steps})")]
    StepLimitExceeded { max_steps: usize },
}

#[derive(Debug, Clone)]
pub struct Machine {
    steps: usize,
    limits: Limits,
}

impl Machine {
    pub fn new(limits: Limits) -> Self {
        Self { steps: 0, limits }
    }

    pub fn eval_call(&mut self, call: &Call) -> Result<Vec<Effect>, VmError> {
        self.steps += 1;
        if self.steps > self.limits.max_steps {
            return Err(VmError::StepLimitExceeded {
                max_steps: self.limits.max_steps,
            });
        }

        match call.name.as_str() {
            "score" => {
                let n = expect_one_num(call)?;
                Ok(vec![Effect::AddScore(n as i64)])
            }
            "bank" => {
                let n = expect_one_num(call)?;
                Ok(vec![Effect::AddBankroll(n as i64)])
            }
            "dbl" => {
                expect_arity(call, 0)?;
                Ok(vec![Effect::MulBankroll(2)])
            }
            other => Err(VmError::UnknownFunction(other.to_string())),
        }
    }
}

fn expect_arity(call: &Call, expected: usize) -> Result<(), VmError> {
    let got = call.args.len();
    if got != expected {
        return Err(VmError::WrongArity {
            name: call.name.clone(),
            expected,
            got,
        });
    }
    Ok(())
}

fn expect_one_num(call: &Call) -> Result<u32, VmError> {
    expect_arity(call, 1)?;
    Ok(call.args[0].as_u32().unwrap_or(0))
}


```

Good — core modules are in place (`game`, `kardlang`, `vm`) and the engine now executes a hand by parsing Kardlang, step-limiting VM calls, applying effects, and recording a typed trace. Next I’ll add a small engine test (draw 1 card → play → score changes) and then run `cargo test` to make sure the pure core compiles cleanly.

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmError};

use super::{Card, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawHand { count: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        Self::with_deck(seed, starter_deck(), Limits::default())
    }

    pub fn with_deck(seed: u64, mut deck: Vec<Card>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawHand { count } => self.draw_hand(count),
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_hand(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.hand.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<Card>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        for (index, card) in self.state.hand.iter().cloned().enumerate() {
            let cost = effective_len(&card.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: card.name.clone(),
                script: card.script.clone(),
                budget: card.budget,
                cost,
            });

            if cost > card.budget {
                return Err(GameError::CardOverBudget {
                    name: card.name,
                    cost,
                    budget: card.budget,
                });
            }

            let program = parse_program(&card.script)?;
            for call in &program.calls {
                let args = call
                    .args
                    .iter()
                    .map(|v| v.as_u32())
                    .collect::<Option<Vec<_>>>()
                    .unwrap_or_default();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let effects = vm.eval_call(call)?;
                self.apply_effects(effects);
            }

            self.state.discard.push(card);
        }

        self.state.hand.clear();

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn starter_deck() -> Vec<Card> {
    vec![
        Card::new("Score +2", "score(11)", 12),
        Card::new("Score +2", "score(11)", 12),
        Card::new("Bank +3", "bank(111)", 12),
        Card::new("Double Bank", "dbl()", 12),
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![Card::new("Score +2", "score(11)", 12)];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine.dispatch(Action::DrawHand { count: 1 }).unwrap();
        assert_eq!(engine.state.hand.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}



```

Good catch from the compiler: we were iterating over `self.state.hand` while also mutating `self` (applying effects + pushing trace), which Rust correctly forbids. I’ll fix this by taking ownership of the hand (`mem::take`) before executing it, which is also a nice “hand is a program we consume” mental model.

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmError};

use super::{Card, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawHand { count: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        Self::with_deck(seed, starter_deck(), Limits::default())
    }

    pub fn with_deck(seed: u64, mut deck: Vec<Card>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawHand { count } => self.draw_hand(count),
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_hand(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.hand.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<Card>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let hand = std::mem::take(&mut self.state.hand);
        for (index, card) in hand.into_iter().enumerate() {
            let cost = effective_len(&card.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: card.name.clone(),
                script: card.script.clone(),
                budget: card.budget,
                cost,
            });

            if cost > card.budget {
                return Err(GameError::CardOverBudget {
                    name: card.name,
                    cost,
                    budget: card.budget,
                });
            }

            let program = parse_program(&card.script)?;
            for call in &program.calls {
                let args = call
                    .args
                    .iter()
                    .map(|v| v.as_u32())
                    .collect::<Option<Vec<_>>>()
                    .unwrap_or_default();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let effects = vm.eval_call(call)?;
                self.apply_effects(effects);
            }

            self.state.discard.push(card);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn starter_deck() -> Vec<Card> {
    vec![
        Card::new("Score +2", "score(11)", 12),
        Card::new("Score +2", "score(11)", 12),
        Card::new("Bank +3", "bank(111)", 12),
        Card::new("Double Bank", "dbl()", 12),
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![Card::new("Score +2", "score(11)", 12)];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine.dispatch(Action::DrawHand { count: 1 }).unwrap();
        assert_eq!(engine.state.hand.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}



```

```toml
[package]
name = "kardinality"
version = "0.1.0"
edition = "2024"

[dependencies]
rand = "0.8"
rand_chacha = "0.3"
serde = { version = "1", features = ["derive"] }
thiserror = "1"

[target.'cfg(target_arch = "wasm32")'.dependencies]
# Dioxus UI (DOM + CSS) for the browser build.
dioxus = { version = "0.7.2", features = ["web"] }

# Better panics in the browser console.
console_error_panic_hook = "0.1"

# Ensure `rand` works on wasm by enabling JS-backed entropy (even though we prefer deterministic seeds).
getrandom = { version = "0.2", features = ["js"] }

```

```rust
#[cfg(target_arch = "wasm32")]
use dioxus::prelude::*;

#[cfg(not(target_arch = "wasm32"))]
fn main() {
    println!("Kardinality runs in the browser (WASM). Install `dioxus-cli` and run `dx serve`.");
}

#[cfg(target_arch = "wasm32")]
fn main() {
    console_error_panic_hook::set_once();
    dioxus::launch(App);
}

#[cfg(target_arch = "wasm32")]
#[component]
fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));

    let engine_read = engine.read();
    let state = &engine_read.state;

    let bankroll = state.bankroll;
    let score = state.score;
    let level = state.level;
    let target = state.target_score;

    rsx! {
        div { class: "app",
            h1 { "Kardinality" }

            div { class: "status",
                div { "Bankroll: {bankroll}" }
                div { "Score: {score}" }
                div { "Level: {level}" }
                div { "Target: {target}" }
            }

            div { class: "controls",
                button {
                    onclick: move |_| {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    },
                    "New run"
                }
                button {
                    onclick: move |_| {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::DrawHand { count: 5 }) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    },
                    "Draw 5"
                }
                button {
                    onclick: move |_| {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    },
                    "Play hand"
                }
                button {
                    onclick: move |_| {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::ClearTrace) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    },
                    "Clear trace"
                }
            }

            div { class: "panels",
                div { class: "panel hand",
                    h2 { "Hand" }
                    if state.hand.is_empty() {
                        div { class: "empty", "No cards in hand." }
                    } else {
                        ul {
                            for card in state.hand.iter() {
                                li {
                                    strong { "{card.name}" }
                                    span { " — " }
                                    code { "{card.script}" }
                                }
                            }
                        }
                    }
                }

                div { class: "panel trace",
                    h2 { "Trace" }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace events yet." }
                    } else {
                        ul {
                            for event in state.trace.iter().rev().take(100) {
                                li { "{event:?}" }
                            }
                        }
                    }
                }
            }
        }
    }
}

```

```ignore
/target
/dist
/.dioxus

```

```markdown
## Kardinality

Kardinality is a **single‑player, browser‑deployed** card game where your “hand” is an ordered stack of executable code‑cards. The vibe is roguelike deck‑building (Balatro‑adjacent), but the mechanics are intentionally **programming‑shaped**: cards compose, control flow exists, and you win by hitting ever‑higher score targets.

### Tech stack

* **Rust**: all game logic (rules, state, interpreter)
* **WASM (web)**: cross‑platform browser deploy
* **Dioxus**: UI rendered via **HTML DOM + CSS**, no traditional rendering engine
* **Browser APIs**: accessed from Rust (`web_sys` / `wasm_bindgen`) with minimal/no hand‑written JS

### Quick start (dev)

Recommended workflow:

* Install Rust (stable) and add the WASM target:
  * `rustup target add wasm32-unknown-unknown`
* Install Dioxus CLI:
  * `cargo install dioxus-cli`
  * (optional, faster installs) `cargo install cargo-binstall && cargo binstall dioxus-cli`
* Run the dev server:
  * `dx serve`
* Build for release:
  * `dx build --release`
* Run core logic tests:
  * `cargo test`

### Docs

* `AGENTS.md`: guidance for future AI agents (commands, constraints, conventions)



```

### Architecture implemented (core-first, testable)

- **Core game logic lives in the library** (`src/lib.rs` → `src/game/`, `src/kardlang/`, `src/vm/`)
  - No UI, no browser APIs, no Dioxus types.
  - The single “entry point” is `Engine::dispatch(Action)` and all state is in `Engine.state`.
- **UI is a thin web shell** (`src/main.rs`)
  - Dioxus app reads `Engine.state` and dispatches `Action`s.
  - Browser-only code is behind `cfg(target_arch = "wasm32")`.

### Proof it’s testable (state evolution)

Core tests run with `cargo test` and assert state changes from actions/hand execution:

```11:197:src/game/engine.rs
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawHand { count: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawHand { count } => self.draw_hand(count),
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    // ... play_hand parses kardlang, runs vm with step limits, applies effects, records trace ...

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![Card::new("Score +2", "score(11)", 12)];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine.dispatch(Action::DrawHand { count: 1 }).unwrap();
        engine.dispatch(Action::PlayHand).unwrap();

        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}
```

### Minimal browser UI wired up (Dioxus → Actions)

```1:112:src/main.rs
#[cfg(target_arch = "wasm32")]
use dioxus::prelude::*;

#[cfg(not(target_arch = "wasm32"))]
fn main() {
    println!("Kardinality runs in the browser (WASM). Install `dioxus-cli` and run `dx serve`.");
}

#[cfg(target_arch = "wasm32")]
fn main() {
    console_error_panic_hook::set_once();
    dioxus::launch(App);
}

#[cfg(target_arch = "wasm32")]
#[component]
fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));

    // renders state + buttons that dispatch kardinality::Action::{DrawHand, PlayHand, ...}
    // ... plus a basic trace panel ...
    rsx! { /* ... */ }
}
```

### How to run

- **Core tests**: `cargo test`
- **Web dev**: install `dx` then `dx serve` (see `README.md`)
- **WASM build**: `dx build --release` (or `cargo build --target wasm32-unknown-unknown`)

Next up (now that the plumbing is solid): expand `Action`s and the engine loop (more cards, better trace formatting, and start enforcing Kardlang budgets more systematically).

```rust
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawHand { count: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawHand { count } => self.draw_hand(count),
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    // ... play_hand parses kardlang, runs vm with step limits, applies effects, records trace ...

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![Card::new("Score +2", "score(11)", 12)];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine.dispatch(Action::DrawHand { count: 1 }).unwrap();
        engine.dispatch(Action::PlayHand).unwrap();

        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}
```

```rust
#[cfg(target_arch = "wasm32")]
use dioxus::prelude::*;

#[cfg(not(target_arch = "wasm32"))]
fn main() {
    println!("Kardinality runs in the browser (WASM). Install `dioxus-cli` and run `dx serve`.");
}

#[cfg(target_arch = "wasm32")]
fn main() {
    console_error_panic_hook::set_once();
    dioxus::launch(App);
}

#[cfg(target_arch = "wasm32")]
#[component]
fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));

    // renders state + buttons that dispatch kardinality::Action::{DrawHand, PlayHand, ...}
    // ... plus a basic trace panel ...
    rsx! { /* ... */ }
}
```

---

**User**

Okay, it's working but let's make it pretty. Also, right now it's literally so plain. It needs to be a proper "game" with cards as rectangles.

I want there to be a bar of buttons and options on like the left part of the screen like a sidebar, and then a row of cards at the bottom of the rest of the screen, a deck on the top right, and score / bankroll / register stuff at the top part. In addition, make a 'debug' tab for the trace that is toggleable (on the sidebar part of the screen). Church it up!

The vibes for this project are retro, CRT TV, dark theme, sleek, awesome hacker wizard vibes. Seriously go fucking crazy by default. We will want art on the cards later, so think of that, but for now some cool effects or gradient or color and text are well.

Make all this with reusable and easy to edit components and views. LETS GO. 

---

**Cursor**

Plan: extract the UI into a `src/ui/` module with reusable components (`Sidebar`, `Hud`, `DeckWidget`, `CardView`), add a big CRT-themed CSS skin, and restructure the layout into sidebar + main (top HUD + deck, bottom hand row). Then I’ll add a Debug tab in the sidebar that toggles the trace list.

```rust
#[cfg(target_arch = "wasm32")]
use dioxus::prelude::*;

#[cfg(target_arch = "wasm32")]
mod ui;

#[cfg(not(target_arch = "wasm32"))]
fn main() {
    println!("Kardinality runs in the browser (WASM). Install `dioxus-cli` and run `dx serve`.");
}

#[cfg(target_arch = "wasm32")]
fn main() {
    console_error_panic_hook::set_once();
    dioxus::launch(ui::App);
}

```

```rust
mod app;
pub mod theme;

pub mod views;

pub use app::App;


```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

.playfield .center-hint {
  text-align: center;
  max-width: 520px;
  padding: 18px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.5;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.hand-row {
  display: flex;
  gap: 12px;
  overflow-x: auto;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.hand-row::-webkit-scrollbar {
  height: 8px;
}
.hand-row::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.hand-row::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}
"#;


```

```rust
use dioxus::prelude::*;

use crate::ui::theme;
use crate::ui::views::{DeckWidget, Sidebar, SidebarTab, TopHud};

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let hand_count = state.hand.len();

    rsx! {
        style { {theme::CSS} }

        div { class: "app",
            Sidebar { engine, tab }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            level: state.level,
                            target: state.target_score,
                            hand_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        hand_count,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Cards are code. Draw into your hand, then execute the stack to hit the target."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, and upgrades."
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Draw cards to fill your hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView { index: i, card }
                            }
                        }
                    }
                }
            }
        }
    }
}


```

```rust
mod cards;
mod deck;
mod hud;
mod sidebar;

pub use cards::CardView;
pub use deck::DeckWidget;
pub use hud::TopHud;
pub use sidebar::{Sidebar, SidebarTab};


```

```rust
use dioxus::prelude::*;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
}

#[component]
pub fn Sidebar(mut engine: Signal<kardinality::Engine>, mut tab: Signal<SidebarTab>) -> Element {
    let tab_value = tab();

    let dispatch = move |action: kardinality::Action| {
        let mut eng = engine.write();
        if let Err(e) = eng.dispatch(action) {
            eng.state
                .trace
                .push(kardinality::TraceEvent::Error(e.to_string()));
        }
    };

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button { class: "btn", onclick: move |_| dispatch(kardinality::Action::NewRun { seed: 0 }),
                        "New run (seed 0)"
                    }
                    button { class: "btn secondary", onclick: move |_| dispatch(kardinality::Action::DrawHand { count: 5 }),
                        "Draw 5"
                    }
                    button { class: "btn", onclick: move |_| dispatch(kardinality::Action::PlayHand),
                        "Execute hand"
                    }
                    button { class: "btn danger", onclick: move |_| dispatch(kardinality::Action::ClearTrace),
                        "Clear trace"
                    }
                }

                div { class: "panel sidebar-panel",
                    h3 { "Telemetry" }
                    div { class: "kv", span { "Deck" } code { "{state.deck.len()}" } }
                    div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
                    div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
                    div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
                    div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
                    div { class: "hint",
                        "Tip: the trace panel is also core UX. Keep it readable and useful."
                    }
                }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Draw + execute a hand." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}


```

```rust
use dioxus::prelude::*;

#[component]
pub fn TopHud(
    bankroll: i64,
    score: i64,
    level: u32,
    target: i64,
    hand_count: usize,
    trace_count: usize,
    max_steps: usize,
    max_loop_iters: usize,
) -> Element {
    rsx! {
        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Status" }
            div { class: "stats",
                div { class: "stat", span { "Bankroll" } strong { "{bankroll}" } }
                div { class: "stat", span { "Score" } strong { "{score}" } }
                div { class: "stat", span { "Level" } strong { "{level}" } }
                div { class: "stat", span { "Target" } strong { "{target}" } }
            }
        }

        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Registers" }
            div { class: "kv", span { "hand_len" } code { "{hand_count}" } }
            div { class: "kv", span { "trace_len" } code { "{trace_count}" } }
            div { class: "kv", span { "max_steps" } code { "{max_steps}" } }
            div { class: "kv", span { "max_loop" } code { "{max_loop_iters}" } }
        }
    }
}


```

```rust
use dioxus::prelude::*;

#[component]
pub fn DeckWidget(deck_count: usize, discard_count: usize, hand_count: usize) -> Element {
    rsx! {
        div { class: "panel deck-widget",
            h2 { class: "deck-title", "Deck" }

            div { class: "deck-stack",
                div { class: "deck-card" }
                div { class: "deck-card" }
                div { class: "deck-card" }
            }

            div { class: "deck-meta",
                div { class: "pill", span { "Deck" } strong { "{deck_count}" } }
                div { class: "pill", span { "Discard" } strong { "{discard_count}" } }
                div { class: "pill", span { "Hand" } strong { "{hand_count}" } }
                div { class: "pill", span { "RNG" } strong { "seeded" } }
            }
        }
    }
}


```

```rust
use dioxus::prelude::*;

#[component]
pub fn CardView(index: usize, card: kardinality::game::Card) -> Element {
    // Later: rarity colors, upgrades, art, clickable targeting, drag/drop, etc.
    let badge = format!("#{index}");

    rsx! {
        div { class: "card",
            div { class: "card-badge", "{badge}" }
            div { class: "card-art" }
            div { class: "card-body",
                h3 { class: "card-title", "{card.name}" }
                div { class: "card-sub", "Budget: {card.budget} chars" }
                div { class: "card-script", "{card.script}" }
            }
        }
    }
}


```

Good — the layout/components are in place, but the wasm build caught a real Dioxus ergonomics issue: my `dispatch` helper closure ended up as `FnMut`, and then couldn’t be called from multiple button handlers. I’ll fix that by inlining dispatch logic per button (each handler captures its own `engine` signal copy), and clean up the wasm-only warnings.

```rust
use dioxus::prelude::*;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
}

#[component]
pub fn Sidebar(mut engine: Signal<kardinality::Engine>, mut tab: Signal<SidebarTab>) -> Element {
    let tab_value = tab();

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "New run (seed 0)"
                    }
                    button {
                        class: "btn secondary",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::DrawHand { count: 5 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Draw 5"
                    }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Execute hand"
                    }
                    button {
                        class: "btn danger",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::ClearTrace) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Clear trace"
                    }
                }

                div { class: "panel sidebar-panel",
                    h3 { "Telemetry" }
                    div { class: "kv", span { "Deck" } code { "{state.deck.len()}" } }
                    div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
                    div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
                    div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
                    div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
                    div { class: "hint",
                        "Tip: the trace panel is also core UX. Keep it readable and useful."
                    }
                }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Draw + execute a hand." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::theme;
use crate::ui::views::{DeckWidget, Sidebar, SidebarTab, TopHud};

#[component]
pub fn App() -> Element {
    let engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let hand_count = state.hand.len();

    rsx! {
        style { {theme::CSS} }

        div { class: "app",
            Sidebar { engine, tab }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            level: state.level,
                            target: state.target_score,
                            hand_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        hand_count,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Cards are code. Draw into your hand, then execute the stack to hit the target."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, and upgrades."
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Draw cards to fill your hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView { index: i, card }
                            }
                        }
                    }
                }
            }
        }
    }
}



```

```rust
#[cfg(target_arch = "wasm32")]
mod ui;

#[cfg(not(target_arch = "wasm32"))]
fn main() {
    println!("Kardinality runs in the browser (WASM). Install `dioxus-cli` and run `dx serve`.");
}

#[cfg(target_arch = "wasm32")]
fn main() {
    console_error_panic_hook::set_once();
    dioxus::launch(ui::App);
}

```

### UI overhaul: CRT hacker vibe + real “game” layout

- **New layout**
  - **Left sidebar** with **Controls / Debug** tabs
  - **Top HUD** (score/bankroll/level/target + “registers/telemetry” panel)
  - **Deck widget** on the **top right**
  - **Hand row** at the **bottom** with **card rectangles**
  - Center playfield placeholder for future “program space”

- **Retro CRT theme**
  - Dark neon gradients, glow, scanlines, vignette/flicker overlay
  - Card hover lift + glow
  - All styles centralized in `src/ui/theme.rs` for easy tuning

- **Reusable views/components**
  - `src/ui/views/sidebar.rs`: sidebar + Debug trace view
  - `src/ui/views/hud.rs`: top HUD
  - `src/ui/views/deck.rs`: deck widget
  - `src/ui/views/cards.rs`: card rectangles (`CardView`)
  - `src/ui/app.rs`: page composition

### Files added/changed

- **New**: `src/ui/` module (`app.rs`, `theme.rs`, `views/*`)
- **Updated**: `src/main.rs` now just launches `ui::App` for wasm

If you want, next we can make the **deck widget clickable** (click deck = draw), add **card hover tooltips** (show cost/budget + parsed calls), and add a **“Game” tab** in the sidebar for settings like seed/draw count/CRT intensity.

---

**User**

Okay, very good! I like it a lot, a few notes though:

* The layout isnt quite right, we should have a "deck" to draw from, our own collection, and our "current hand". We select cards from the collection, and add them to the active hand before we play. We should also be able to reorder all cards in both the hand and collection.
 * The status panel needs to be more "artsy", I mean the score needs like a bar with color coding showing the progress (as well as the number of course), bankroll needs a dollar sign, level needs something to spice it up (lets move it somewhere else?). For registers, let's do `len_deck`, `len_hand`, `max_step`, and so forth.
 * Let's make sure the card kinds are well documented and in an easy to edit format, so we can add arbitrary ones.
 * For example, the docs in comments should somehow be injected into the runtime objects. 
 * We need a settings menu as well, make it another tab on the side I guess (or, it can be a modal window, you decide what is best)
 * The UI needs to pop even more. If you can make a full screen effects toggleable in the settings menu for a CRT distortion type vibe (maybe have multiple settings -- CRT mode, hacker terminal green theme, magical theme with crazy colors). Just make sure it's CSS possible (but, it should be)

As far as the language itself, we want a super in-depth parser and grammar definition, so we can do things like syntax highlighting, and better error messages. For example, I want it to be able to be generated. You are free to write it directly in Rust, as this language should be very simple (function call syntax with parens, just numbers with unary / digits + cost, variable registers as identifiers with no spaces, no leading digits, and just the + and * operators (exponentiation would be too overpowered). Every value is an integer in this language, so that can simplify things.

Going further on the documenting of various cards, let's also make the "Kardinomicon", which is a guide book of ALL possible cards and functions and language. Think of it like a reference book with examples and explanations of the exact mechanics and rules of each card. That way a player can reference it before playing a hand to double check their strategy. Make the Kardinomicon like a modal window that pops over or to the side maybe, and supports hotlinking so you can click a book logo icon on the card, and it opens the kardinomicon to the correct area and highlights the docs for that card (or, maybe also a hover over the card for a modal window showing just its docs)

For syntax highlighting and card display, let's go with color coding, icons, logos, and jazz it up! Card display should also allow playing with a keyboard, no mouse (left/right to change what card to select, up arrow moves from the cards you have to the active hand and moves focus there too, down arrow moves from active hand back to the collection, enter plays, tab scrolls through options, etc)


---

**Cursor**

Plan: I’ll first refactor the core state to explicitly model `deck` → `collection` → `hand` (with move + reorder actions and tests). Then I’ll update the UI to render both rows with selection/reorder (mouse + keyboard), add a Settings tab (theme + CRT/effects toggles), and a Kardinomicon modal wired to per-card docs. Finally I’ll upgrade Kardlang to a real lexer+expression parser (spans + better errors) so we can do syntax highlighting in card scripts.

Nice — we’re going to make the gameplay “feel” like a real deckbuilder by separating **Deck → Collection → Active Hand** and making everything movable/reorderable. I’ll start by refactoring the core `GameState` + `Action`s (with tests), then update the UI to render both rows and hook up keyboard controls.

```rust
pub mod cards;
mod engine;
mod model;
mod trace;

pub use engine::{Action, Engine, GameError};
pub use model::{CardInstance, GameState, Phase};
pub use trace::TraceEvent;



```

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CardKind {
    Economy,
    Score,
    Control,
    Meta,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CardDef {
    pub id: &'static str,
    pub name: &'static str,
    pub kind: CardKind,
    pub budget: usize,
    pub script: &'static str,
    pub icon: &'static str,
    pub doc: &'static str,
}

pub fn catalog() -> &'static [CardDef] {
    &CATALOG
}

pub fn get(id: &str) -> Option<&'static CardDef> {
    CATALOG.iter().find(|c| c.id == id)
}

pub fn starter_deck_ids() -> &'static [&'static str] {
    &["score_2", "score_2", "bank_3", "dbl_bank"]
}

static CATALOG: [CardDef; 3] = [
    CardDef {
        id: "score_2",
        name: "Score +2",
        kind: CardKind::Score,
        budget: 12,
        script: "score(11)",
        icon: "▲",
        doc: r#"
Adds to your score.

* **Effect**: `score(n)` increases `score` by `n`.
* **Default script**: `score(11)` (unary 2)
* **Notes**: Score is compared against `target` to clear the level.
"#,
    },
    CardDef {
        id: "bank_3",
        name: "Bank +3",
        kind: CardKind::Economy,
        budget: 12,
        script: "bank(111)",
        icon: "$",
        doc: r#"
Adds to your bankroll.

* **Effect**: `bank(n)` increases `bankroll` by `n`.
* **Default script**: `bank(111)` (unary 3)
"#,
    },
    CardDef {
        id: "dbl_bank",
        name: "Double Bank",
        kind: CardKind::Economy,
        budget: 12,
        script: "dbl()",
        icon: "×2",
        doc: r#"
Doubles your bankroll.

* **Effect**: `dbl()` multiplies `bankroll` by 2.
* **Default script**: `dbl()`
"#,
    },
];


```

```rust
use serde::{Deserialize, Serialize};

use crate::vm::Limits;

use super::cards::{self, CardDef};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Phase {
    InLevel,
    Reward,
    GameOver,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CardInstance {
    pub def_id: String,
}

impl CardInstance {
    pub fn new(def_id: impl Into<String>) -> Self {
        Self {
            def_id: def_id.into(),
        }
    }

    pub fn def(&self) -> Option<&'static CardDef> {
        cards::get(&self.def_id)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct GameState {
    pub bankroll: i64,
    pub score: i64,
    pub level: u32,
    pub target_score: i64,
    pub phase: Phase,

    /// Draw pile. Hidden-ish, but still deterministic and reorderable for debug later.
    pub deck: Vec<CardInstance>,

    /// Cards currently available to be selected into the active hand ("program").
    pub collection: Vec<CardInstance>,

    /// Active hand/program to execute in order.
    pub hand: Vec<CardInstance>,

    pub discard: Vec<CardInstance>,

    pub trace: Vec<crate::game::TraceEvent>,

    pub limits: Limits,
}

impl GameState {
    pub fn new(deck: Vec<CardInstance>, limits: Limits) -> Self {
        Self {
            bankroll: 10,
            score: 0,
            level: 1,
            target_score: 10,
            phase: Phase::InLevel,
            deck,
            collection: Vec::new(),
            hand: Vec::new(),
            discard: Vec::new(),
            trace: Vec::new(),
            limits,
        }
    }
}



```

```rust
*** Begin Patch
*** Update File: src/game/engine.rs
@@
 use rand::seq::SliceRandom;
 use rand::SeedableRng;
 use rand_chacha::ChaCha8Rng;
 use thiserror::Error;
 
 use crate::kardlang::{effective_len, parse_program};
 use crate::vm::{Effect, Limits, Machine, VmError};
 
-use super::{Card, GameState, Phase, TraceEvent};
+use super::{cards, CardInstance, GameState, Phase, TraceEvent};
@@
 pub enum Action {
     NewRun { seed: u64 },
-    DrawHand { count: usize },
+    DrawToCollection { count: usize },
+    MoveCollectionToHand { index: usize },
+    MoveHandToCollection { index: usize },
+    ReorderCollection { from: usize, to: usize },
+    ReorderHand { from: usize, to: usize },
     PlayHand,
     ClearTrace,
 }
@@
 pub enum GameError {
@@
     #[error("cannot draw a hand: deck and discard are empty")]
     NoCards,
 }
@@
 impl Engine {
     pub fn new(seed: u64) -> Self {
-        Self::with_deck(seed, starter_deck(), Limits::default())
+        let deck = cards::starter_deck_ids()
+            .iter()
+            .map(|id| CardInstance::new(*id))
+            .collect();
+        Self::with_deck(seed, deck, Limits::default())
     }
 
-    pub fn with_deck(seed: u64, mut deck: Vec<Card>, limits: Limits) -> Self {
+    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
         let mut rng = ChaCha8Rng::seed_from_u64(seed);
         deck.shuffle(&mut rng);
         Self {
             state: GameState::new(deck, limits),
             rng,
         }
     }
@@
         match action {
             Action::NewRun { seed } => {
                 *self = Self::new(seed);
                 Ok(())
             }
-            Action::DrawHand { count } => self.draw_hand(count),
+            Action::DrawToCollection { count } => self.draw_to_collection(count),
+            Action::MoveCollectionToHand { index } => {
+                if let Some(card) = take_at(&mut self.state.collection, index) {
+                    self.state.hand.push(card);
+                }
+                Ok(())
+            }
+            Action::MoveHandToCollection { index } => {
+                if let Some(card) = take_at(&mut self.state.hand, index) {
+                    self.state.collection.push(card);
+                }
+                Ok(())
+            }
+            Action::ReorderCollection { from, to } => {
+                move_within(&mut self.state.collection, from, to);
+                Ok(())
+            }
+            Action::ReorderHand { from, to } => {
+                move_within(&mut self.state.hand, from, to);
+                Ok(())
+            }
             Action::PlayHand => self.play_hand(),
             Action::ClearTrace => {
                 self.state.trace.clear();
                 Ok(())
             }
         }
     }
 
-    fn draw_hand(&mut self, count: usize) -> Result<(), GameError> {
+    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
         for _ in 0..count {
             if let Some(card) = self.draw_one()? {
-                self.state.hand.push(card);
+                self.state.collection.push(card);
             }
         }
         Ok(())
     }
@@
     fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
         if self.state.deck.is_empty() {
             if self.state.discard.is_empty() {
                 return Err(GameError::NoCards);
             }
 
             self.state.deck.append(&mut self.state.discard);
             self.state.deck.shuffle(&mut self.rng);
         }
 
         Ok(self.state.deck.pop())
     }
@@
         let mut vm = Machine::new(self.state.limits);
 
         let hand = std::mem::take(&mut self.state.hand);
-        for (index, card) in hand.into_iter().enumerate() {
-            let cost = effective_len(&card.script);
+        for (index, card) in hand.into_iter().enumerate() {
+            let def = card.def().unwrap_or_else(|| {
+                // Missing defs should never happen once we have persistence, but don't hard crash.
+                // We'll surface it as an error in the trace.
+                self.state.trace.push(TraceEvent::Error(format!(
+                    "unknown card def id: {}",
+                    card.def_id
+                )));
+                // Fallback to a stub.
+                static STUB: cards::CardDef = cards::CardDef {
+                    id: "missing",
+                    name: "Missing Card",
+                    kind: cards::CardKind::Meta,
+                    budget: 0,
+                    script: "",
+                    icon: "?",
+                    doc: "missing card definition",
+                };
+                &STUB
+            });
+
+            let cost = effective_len(def.script);
             self.state.trace.push(TraceEvent::CardStart {
                 index,
-                name: card.name.clone(),
-                script: card.script.clone(),
-                budget: card.budget,
+                name: def.name.to_string(),
+                script: def.script.to_string(),
+                budget: def.budget,
                 cost,
             });
 
-            if cost > card.budget {
+            if cost > def.budget {
                 return Err(GameError::CardOverBudget {
-                    name: card.name,
+                    name: def.name.to_string(),
                     cost,
-                    budget: card.budget,
+                    budget: def.budget,
                 });
             }
 
-            let program = parse_program(&card.script)?;
-            for call in &program.calls {
+            let program = parse_program(def.script)?;
+            for call in &program.calls {
                 let args = call
                     .args
                     .iter()
                     .map(|v| v.as_u32())
                     .collect::<Option<Vec<_>>>()
                     .unwrap_or_default();
@@
                 let effects = vm.eval_call(call)?;
                 self.apply_effects(effects);
             }
 
             self.state.discard.push(card);
         }
@@
         Ok(())
     }
@@
 }
-
-fn starter_deck() -> Vec<Card> {
-    vec![
-        Card::new("Score +2", "score(11)", 12),
-        Card::new("Score +2", "score(11)", 12),
-        Card::new("Bank +3", "bank(111)", 12),
-        Card::new("Double Bank", "dbl()", 12),
-    ]
-}
+
+fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
+    if index >= v.len() {
+        return None;
+    }
+    Some(v.remove(index))
+}
+
+fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
+    if from >= v.len() || to >= v.len() || from == to {
+        return;
+    }
+    let item = v.remove(from);
+    v.insert(to, item);
+}
@@
 mod tests {
     use super::*;
 
     #[test]
     fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
-        let deck = vec![Card::new("Score +2", "score(11)", 12)];
+        let deck = vec![CardInstance::new("score_2")];
         let mut engine = Engine::with_deck(123, deck, Limits::default());
 
-        engine.dispatch(Action::DrawHand { count: 1 }).unwrap();
-        assert_eq!(engine.state.hand.len(), 1);
+        engine.dispatch(Action::DrawToCollection { count: 1 }).unwrap();
+        assert_eq!(engine.state.collection.len(), 1);
         assert_eq!(engine.state.discard.len(), 0);
 
+        engine
+            .dispatch(Action::MoveCollectionToHand { index: 0 })
+            .unwrap();
+        assert_eq!(engine.state.hand.len(), 1);
+
         engine.dispatch(Action::PlayHand).unwrap();
         assert_eq!(engine.state.score, 2);
         assert_eq!(engine.state.hand.len(), 0);
         assert_eq!(engine.state.discard.len(), 1);
     }
 }
*** End Patch
```

Good — the card catalog and new `collection` field are in place, but the big `engine.rs` refactor patch didn’t apply cleanly (it diverged from the current file contents). Next I’ll re-read `src/game/engine.rs` and re-apply the refactor in smaller, safer chunks so we don’t fight patch context.

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmError};

use super::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        let deck = cards::starter_deck_ids()
            .iter()
            .map(|id| CardInstance::new(*id))
            .collect();
        Self::with_deck(seed, deck, Limits::default())
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let hand = std::mem::take(&mut self.state.hand);
        for (index, card) in hand.into_iter().enumerate() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            for call in &program.calls {
                let args = call
                    .args
                    .iter()
                    .map(|v| v.as_u32())
                    .collect::<Option<Vec<_>>>()
                    .unwrap_or_default();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let effects = vm.eval_call(call)?;
                self.apply_effects(effects);
            }

            self.state.discard.push(card);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || to >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    v.insert(to, item);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![CardInstance::new("score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}



```

Nice — core now has the exact state model you described: **deck + collection + active hand**, with move/reorder actions and tests still passing. Next I’m going to rewire the UI to render **both** the collection row and the active hand row (cards as rectangles), and update the sidebar/deck buttons to draw into collection instead of directly into hand.

```rust
use dioxus::prelude::*;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
}

#[component]
pub fn Sidebar(mut engine: Signal<kardinality::Engine>, mut tab: Signal<SidebarTab>) -> Element {
    let tab_value = tab();

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "New run (seed 0)"
                    }
                    button {
                        class: "btn secondary",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Draw 5 → Collection"
                    }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Execute hand"
                    }
                    button {
                        class: "btn danger",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::ClearTrace) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Clear trace"
                    }
                }

                div { class: "panel sidebar-panel",
                    h3 { "Telemetry" }
                    div { class: "kv", span { "Deck" } code { "{state.deck.len()}" } }
                    div { class: "kv", span { "Collection" } code { "{state.collection.len()}" } }
                    div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
                    div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
                    div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
                    div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
                    div { class: "hint",
                        "Tip: the trace panel is also core UX. Keep it readable and useful."
                    }
                }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Draw + execute a hand." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn DeckWidget(deck_count: usize, discard_count: usize, collection_count: usize, hand_count: usize) -> Element {
    rsx! {
        div { class: "panel deck-widget",
            h2 { class: "deck-title", "Deck" }

            div { class: "deck-stack",
                div { class: "deck-card" }
                div { class: "deck-card" }
                div { class: "deck-card" }
            }

            div { class: "deck-meta",
                div { class: "pill", span { "Deck" } strong { "{deck_count}" } }
                div { class: "pill", span { "Discard" } strong { "{discard_count}" } }
                div { class: "pill", span { "Pool" } strong { "{collection_count}" } }
                div { class: "pill", span { "Hand" } strong { "{hand_count}" } }
                div { class: "pill", span { "RNG" } strong { "seeded" } }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::theme;
use crate::ui::views::{DeckWidget, Sidebar, SidebarTab, TopHud};

#[component]
pub fn App() -> Element {
    let engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    rsx! {
        style { {theme::CSS} }

        div { class: "app",
            Sidebar { engine, tab }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            level: state.level,
                            target: state.target_score,
                            hand_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView { index: i, card }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView { index: i, card }
                            }
                        }
                    }
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
}

.playfield .center-hint {
  text-align: center;
  max-width: 520px;
  padding: 18px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.5;
  align-self: center;
}

.collectionbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.hand-row {
  display: flex;
  gap: 12px;
  overflow-x: auto;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.hand-row::-webkit-scrollbar {
  height: 8px;
}
.hand-row::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.hand-row::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}
"#;



```

```rust
use dioxus::prelude::*;

#[component]
pub fn CardView(index: usize, card: kardinality::game::CardInstance) -> Element {
    let badge = format!("#{index}");

    let (name, script, budget, icon) = card
        .def()
        .map(|d| (d.name, d.script, d.budget, d.icon))
        .unwrap_or(("Missing Card", "/* missing */", 0, "?"));

    rsx! {
        div { class: "card",
            div { class: "card-badge", "{badge}" }
            div { class: "card-art" }
            div { class: "card-body",
                h3 { class: "card-title", "{icon} {name}" }
                div { class: "card-sub", "Budget: {budget} chars" }
                div { class: "card-script", "{script}" }
            }
        }
    }
}



```

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmError};

use crate::game::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        let deck = cards::starter_deck_ids()
            .iter()
            .map(|id| CardInstance::new(*id))
            .collect();
        Self::with_deck(seed, deck, Limits::default())
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let hand = std::mem::take(&mut self.state.hand);
        for (index, card) in hand.into_iter().enumerate() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            for call in &program.calls {
                let args = call
                    .args
                    .iter()
                    .map(|v| v.as_u32())
                    .collect::<Option<Vec<_>>>()
                    .unwrap_or_default();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let effects = vm.eval_call(call)?;
                self.apply_effects(effects);
            }

            self.state.discard.push(card);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || to >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    v.insert(to, item);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![CardInstance::new("score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn CardView(
    index: usize,
    card: kardinality::game::CardInstance,
    selected: bool,
    primary_icon: &'static str,
    on_select: EventHandler<usize>,
    on_primary: EventHandler<usize>,
    on_move_left: EventHandler<usize>,
    on_move_right: EventHandler<usize>,
    on_docs: EventHandler<String>,
) -> Element {
    let badge = format!("#{index}");

    let def_id = card.def_id.clone();
    let (name, script, budget, icon, doc_hint) = card
        .def()
        .map(|d| (d.name, d.script, d.budget, d.icon, d.kind))
        .map(|(name, script, budget, icon, kind)| (name, script, budget, icon, format!("{kind:?}")))
        .unwrap_or(("Missing Card", "/* missing */", 0, "?", "Missing".to_string()));

    let class = if selected { "card selected" } else { "card" };

    rsx! {
        div {
            class: "{class}",
            onclick: move |_| on_select.call(index),
            div { class: "card-badge", "{badge}" }
            div { class: "card-art" }
            div { class: "card-body",
                h3 { class: "card-title", "{icon} {name}" }
                div { class: "card-sub", "{doc_hint} • Budget: {budget}" }
                div { class: "card-script", "{script}" }
            }

            div { class: "card-actions",
                button {
                    class: "card-btn",
                    title: "Docs",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_docs.call(def_id.clone());
                    },
                    "⌘"
                }
                button {
                    class: "card-btn",
                    title: "Move",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_primary.call(index);
                    },
                    "{primary_icon}"
                }
                button {
                    class: "card-btn",
                    title: "Move left",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_left.call(index);
                    },
                    "←"
                }
                button {
                    class: "card-btn",
                    title: "Move right",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_right.call(index);
                    },
                    "→"
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
}

.playfield .center-hint {
  text-align: center;
  max-width: 520px;
  padding: 18px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.5;
  align-self: center;
}

.collectionbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.hand-row {
  display: flex;
  gap: 12px;
  overflow-x: auto;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.hand-row::-webkit-scrollbar {
  height: 8px;
}
.hand-row::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.hand-row::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}
"#;



```

```rust
use dioxus::prelude::*;

use crate::ui::theme;
use crate::ui::views::{DeckWidget, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Collection,
    Hand,
}

#[component]
pub fn App() -> Element {
    let engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    // Keyboard-first selection state.
    let focus = use_signal(|| FocusZone::Collection);
    let sel_collection = use_signal(|| 0usize);
    let sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    rsx! {
        style { {theme::CSS} }

        div {
            class: "app",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Collection {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Collection);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            level: state.level,
                            target: state.target_score,
                            hand_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |_id| {
                                            // Kardinomicon modal is next step; for now, leave a trace breadcrumb.
                                            let mut eng = engine.write();
                                            eng.state.trace.push(kardinality::TraceEvent::Info("Kardinomicon: coming next".to_string()));
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Collection);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |_id| {
                                        let mut eng = engine.write();
                                        eng.state.trace.push(kardinality::TraceEvent::Info("Kardinomicon: coming next".to_string()));
                                    },
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::theme;
use crate::ui::views::{DeckWidget, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Collection,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Collection);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    rsx! {
        style { {theme::CSS} }

        div {
            class: "app",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Collection {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Collection);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            level: state.level,
                            target: state.target_score,
                            hand_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |_id| {
                                            // Kardinomicon modal is next step; for now, leave a trace breadcrumb.
                                            let mut eng = engine.write();
                                            eng.state.trace.push(kardinality::TraceEvent::Info("Kardinomicon: coming next".to_string()));
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Collection);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |_id| {
                                        let mut eng = engine.write();
                                        eng.state.trace.push(kardinality::TraceEvent::Info("Kardinomicon: coming next".to_string()));
                                    },
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



```

```rust
mod app;
pub mod state;
pub mod theme;

pub mod views;

pub use app::App;



```

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum UiTheme {
    Crt,
    Terminal,
    Magic,
}

impl UiTheme {
    pub fn label(&self) -> &'static str {
        match self {
            UiTheme::Crt => "CRT",
            UiTheme::Terminal => "Terminal",
            UiTheme::Magic => "Arcane",
        }
    }

    pub fn class(&self) -> &'static str {
        match self {
            UiTheme::Crt => "theme-crt",
            UiTheme::Terminal => "theme-terminal",
            UiTheme::Magic => "theme-magic",
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct UiSettings {
    pub theme: UiTheme,
    pub effects: bool,
}

impl Default for UiSettings {
    fn default() -> Self {
        Self {
            theme: UiTheme::Crt,
            effects: true,
        }
    }
}


```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
) -> Element {
    let tab_value = tab();

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "New run (seed 0)"
                    }
                    button {
                        class: "btn secondary",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Draw 5 → Collection"
                    }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Execute hand"
                    }
                    button {
                        class: "btn danger",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::ClearTrace) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Clear trace"
                    }
                    button {
                        class: "btn secondary",
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                        "Open Kardinomicon"
                    }
                }

                div { class: "panel sidebar-panel",
                    h3 { "Telemetry" }
                    div { class: "kv", span { "Deck" } code { "{state.deck.len()}" } }
                    div { class: "kv", span { "Collection" } code { "{state.collection.len()}" } }
                    div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
                    div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
                    div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
                    div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
                    div { class: "hint",
                        "Tip: the trace panel is also core UX. Keep it readable and useful."
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Draw + execute a hand." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }
            } else {
                let cur = settings();

                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Collection,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let mut settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Collection);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Collection {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Collection);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            level: state.level,
                            target: state.target_score,
                            hand_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Collection);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
}

.playfield .center-hint {
  text-align: center;
  max-width: 520px;
  padding: 18px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.5;
  align-self: center;
}

.collectionbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.hand-row {
  display: flex;
  gap: 12px;
  overflow-x: auto;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.hand-row::-webkit-scrollbar {
  height: 8px;
}
.hand-row::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.hand-row::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}
"#;



```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
) -> Element {
    let tab_value = tab();
    let cur_settings = settings();

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "New run (seed 0)"
                    }
                    button {
                        class: "btn secondary",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Draw 5 → Collection"
                    }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Execute hand"
                    }
                    button {
                        class: "btn danger",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::ClearTrace) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Clear trace"
                    }
                    button {
                        class: "btn secondary",
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                        "Open Kardinomicon"
                    }
                }

                div { class: "panel sidebar-panel",
                    h3 { "Telemetry" }
                    div { class: "kv", span { "Deck" } code { "{state.deck.len()}" } }
                    div { class: "kv", span { "Collection" } code { "{state.collection.len()}" } }
                    div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
                    div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
                    div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
                    div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
                    div { class: "hint",
                        "Tip: the trace panel is also core UX. Keep it readable and useful."
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Draw + execute a hand." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur_settings.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur_settings.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur_settings.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Collection,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Collection);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Collection {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Collection);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            level: state.level,
                            target: state.target_score,
                            hand_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Collection);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn TopHud(
    bankroll: i64,
    score: i64,
    target: i64,
    deck_count: usize,
    collection_count: usize,
    hand_count: usize,
    discard_count: usize,
    trace_count: usize,
    max_steps: usize,
    max_loop_iters: usize,
) -> Element {
    let pct = if target <= 0 {
        0.0
    } else {
        (score as f64 / target as f64).clamp(0.0, 1.25)
    };
    let pct100 = (pct * 100.0).clamp(0.0, 125.0);
    let fill_style = format!("width: {pct100:.2}%");

    let stage = if pct < 0.33 {
        "low"
    } else if pct < 0.66 {
        "mid"
    } else if pct < 1.0 {
        "high"
    } else {
        "clear"
    };

    rsx! {
        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Score" }

            div { class: "scoreline",
                div { class: "scorebig", "{score}" }
                div { class: "scoremeta",
                    div { class: "hint", "Target" }
                    div { class: "scoretarget", "{target}" }
                }
            }

            div { class: "progress",
                div { class: "progress-fill {stage}", style: "{fill_style}" }
            }

            div { class: "bankline",
                div { class: "hint", "Bankroll" }
                div { class: "bankbig", "${bankroll}" }
            }
        }

        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Registers" }
            div { class: "kv", span { "len_deck" } code { "{deck_count}" } }
            div { class: "kv", span { "len_pool" } code { "{collection_count}" } }
            div { class: "kv", span { "len_hand" } code { "{hand_count}" } }
            div { class: "kv", span { "len_discard" } code { "{discard_count}" } }
            div { class: "kv", span { "max_steps" } code { "{max_steps}" } }
            div { class: "kv", span { "max_loop" } code { "{max_loop_iters}" } }
            div { class: "kv", span { "trace_len" } code { "{trace_count}" } }
        }
    }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn DeckWidget(
    deck_count: usize,
    discard_count: usize,
    collection_count: usize,
    hand_count: usize,
    level: u32,
    target: i64,
) -> Element {
    rsx! {
        div { class: "panel deck-widget",
            h2 { class: "deck-title", "Deck // Level {level}" }

            div { class: "deck-stack",
                div { class: "deck-card" }
                div { class: "deck-card" }
                div { class: "deck-card" }
            }

            div { class: "deck-meta",
                div { class: "pill", span { "Deck" } strong { "{deck_count}" } }
                div { class: "pill", span { "Discard" } strong { "{discard_count}" } }
                div { class: "pill", span { "Pool" } strong { "{collection_count}" } }
                div { class: "pill", span { "Hand" } strong { "{hand_count}" } }
                div { class: "pill", span { "Target" } strong { "{target}" } }
                div { class: "pill", span { "RNG" } strong { "seeded" } }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Collection,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Collection);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Collection {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Collection);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Collection);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Collection,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Collection);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Collection {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Collection);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Collection);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 32px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
}

.playfield .center-hint {
  text-align: center;
  max-width: 520px;
  padding: 18px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.5;
  align-self: center;
}

.collectionbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.hand-row {
  display: flex;
  gap: 12px;
  overflow-x: auto;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.hand-row::-webkit-scrollbar {
  height: 8px;
}
.hand-row::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.hand-row::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}
"#;



```

```rust
mod cards;
mod deck;
mod hud;
mod kardinomicon;
mod sidebar;

pub use cards::CardView;
pub use deck::DeckWidget;
pub use hud::TopHud;
pub use kardinomicon::KardinomiconModal;
pub use sidebar::{Sidebar, SidebarTab};



```

```rust
use dioxus::prelude::*;

#[component]
pub fn KardinomiconModal(
    open: bool,
    target: Option<String>,
    on_close: EventHandler<()>,
) -> Element {
    if !open {
        return None;
    }

    let catalog = kardinality::game::cards::catalog();

    // If a target is provided, show it first.
    let mut ordered: Vec<&kardinality::game::cards::CardDef> = Vec::with_capacity(catalog.len());
    if let Some(t) = target.as_deref() {
        if let Some(found) = catalog.iter().find(|c| c.id == t) {
            ordered.push(found);
        }
    }
    for c in catalog {
        if ordered.first().is_some_and(|first| first.id == c.id) {
            continue;
        }
        ordered.push(c);
    }

    rsx! {
        div {
            class: "modal-overlay",
            onclick: move |_| on_close.call(()),

            div {
                class: "modal panel",
                onclick: move |evt| evt.stop_propagation(),

                div { class: "modal-header",
                    div { class: "modal-title",
                        span { class: "modal-glyph", "⟡" }
                        span { "Kardinomicon" }
                    }
                    button { class: "btn danger", onclick: move |_| on_close.call(()), "Close" }
                }

                div { class: "modal-body",
                    h2 { class: "hud-title", "Language" }
                    div { class: "kdoc",
                        "Kardlang is a tiny integer-only language designed for card execution budgets."
                        br {}
                        "Numbers are unary (\"111\" = 3) or digit shorthand (\"4\" = 4 but costs 4)."
                        br {}
                        "Soon: identifiers (registers), + and * expressions, and better diagnostics."
                    }

                    h2 { class: "hud-title", "Functions" }
                    div { class: "kdoc",
                        "score(n)  → add n to score"
                        br {}
                        "bank(n)   → add n to bankroll"
                        br {}
                        "dbl()     → bankroll *= 2"
                    }

                    h2 { class: "hud-title", "Cards" }
                    div { class: "kcard-list",
                        for c in ordered {
                            let highlight = target.as_deref().is_some_and(|t| t == c.id);
                            let class = if highlight { "kcard highlight" } else { "kcard" };
                            div { class: "{class}",
                                div { class: "kcard-head",
                                    span { class: "kcard-icon", "{c.icon}" }
                                    div { class: "kcard-title",
                                        div { class: "kcard-name", "{c.name}" }
                                        div { class: "kcard-id", "{c.id}" }
                                    }
                                    div { class: "kcard-script", "{c.script}" }
                                }
                                pre { class: "kcard-doc", "{c.doc.trim()}" }
                            }
                        }
                    }
                }
            }
        }
    }
}


```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Collection,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Collection);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Collection {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Collection);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Collection);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 32px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
}

.playfield .center-hint {
  text-align: center;
  max-width: 520px;
  padding: 18px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.5;
  align-self: center;
}

.collectionbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.hand-row {
  display: flex;
  gap: 12px;
  overflow-x: auto;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.hand-row::-webkit-scrollbar {
  height: 8px;
}
.hand-row::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.hand-row::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
use dioxus::prelude::*;

#[component]
pub fn KardinomiconModal(
    open: bool,
    target: Option<String>,
    on_close: EventHandler<()>,
) -> Element {
    let catalog = kardinality::game::cards::catalog();

    // If a target is provided, show it first.
    let mut ordered: Vec<kardinality::game::cards::CardDef> = Vec::with_capacity(catalog.len());
    if let Some(t) = target.as_deref() {
        if let Some(found) = catalog.iter().find(|c| c.id == t) {
            ordered.push(*found);
        }
    }
    for c in catalog {
        if ordered.first().is_some_and(|first| first.id == c.id) {
            continue;
        }
        ordered.push(*c);
    }

    rsx! {
        if open {
            div {
                class: "modal-overlay",
                onclick: move |_| on_close.call(()),

                div {
                    class: "modal panel",
                    onclick: move |evt| evt.stop_propagation(),

                    div { class: "modal-header",
                        div { class: "modal-title",
                            span { class: "modal-glyph", "⟡" }
                            span { "Kardinomicon" }
                        }
                        button { class: "btn danger", onclick: move |_| on_close.call(()), "Close" }
                    }

                    div { class: "modal-body",
                        h2 { class: "hud-title", "Language" }
                        div { class: "kdoc",
                            "Kardlang is a tiny integer-only language designed for card execution budgets."
                            br {}
                            "Numbers are unary (\"111\" = 3) or digit shorthand (\"4\" = 4 but costs 4)."
                            br {}
                            "Soon: identifiers (registers), + and * expressions, and better diagnostics."
                        }

                        h2 { class: "hud-title", "Functions" }
                        div { class: "kdoc",
                            "score(n)  → add n to score"
                            br {}
                            "bank(n)   → add n to bankroll"
                            br {}
                            "dbl()     → bankroll *= 2"
                        }

                        h2 { class: "hud-title", "Cards" }
                        div { class: "kcard-list",
                            for c in ordered {
                                KardinomiconCard {
                                    card: c,
                                    highlight: target.as_deref().is_some_and(|t| t == c.id),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn KardinomiconCard(card: kardinality::game::cards::CardDef, highlight: bool) -> Element {
    let class = if highlight { "kcard highlight" } else { "kcard" };
    rsx! {
        div { class: "{class}",
            div { class: "kcard-head",
                span { class: "kcard-icon", "{card.icon}" }
                div { class: "kcard-title",
                    div { class: "kcard-name", "{card.name}" }
                    div { class: "kcard-id", "{card.id}" }
                }
                div { class: "kcard-script", "{card.script}" }
            }
            pre { class: "kcard-doc", "{card.doc.trim()}" }
        }
    }
}



```

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub struct Span {
    pub start: usize,
    pub end: usize,
}

impl Span {
    pub fn new(start: usize, end: usize) -> Self {
        Self { start, end }
    }

    pub fn len(&self) -> usize {
        self.end.saturating_sub(self.start)
    }

    pub fn merge(a: Span, b: Span) -> Span {
        Span {
            start: a.start.min(b.start),
            end: a.end.max(b.end),
        }
    }
}


```

```rust
use serde::{Deserialize, Serialize};

use super::Span;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Token {
    pub kind: TokenKind,
    pub span: Span,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TokenKind {
    Ident(String),
    NumUnary(u32),
    NumDigit(u32),
    Plus,
    Star,
    LParen,
    RParen,
    Comma,
    Semi,
    Eof,
}


```

```rust
use thiserror::Error;

use super::{Span, Token, TokenKind};

#[derive(Debug, Clone, PartialEq, Eq, Error)]
#[error("{message} at {span:?}")]
pub struct LexError {
    pub message: String,
    pub span: Span,
}

pub fn lex(input: &str) -> Result<Vec<Token>, LexError> {
    let mut out = Vec::new();
    let mut i = 0usize;

    while i < input.len() {
        let c = input[i..].chars().next().unwrap();
        let c_len = c.len_utf8();

        if c.is_whitespace() {
            i += c_len;
            continue;
        }

        let start = i;

        let kind = match c {
            ';' => {
                i += 1;
                TokenKind::Semi
            }
            '(' => {
                i += 1;
                TokenKind::LParen
            }
            ')' => {
                i += 1;
                TokenKind::RParen
            }
            ',' => {
                i += 1;
                TokenKind::Comma
            }
            '+' => {
                i += 1;
                TokenKind::Plus
            }
            '*' => {
                i += 1;
                TokenKind::Star
            }
            '1' => {
                let mut count = 0u32;
                while i < input.len() && input[i..].starts_with('1') {
                    i += 1;
                    count += 1;
                }
                TokenKind::NumUnary(count)
            }
            '0'..='9' => {
                i += 1;
                TokenKind::NumDigit(c.to_digit(10).unwrap_or(0))
            }
            _ if c.is_ascii_alphabetic() || c == '_' => {
                i += c_len;
                while i < input.len() {
                    let nc = input[i..].chars().next().unwrap();
                    if nc.is_ascii_alphanumeric() || nc == '_' {
                        i += nc.len_utf8();
                    } else {
                        break;
                    }
                }
                TokenKind::Ident(input[start..i].to_string())
            }
            _ => {
                return Err(LexError {
                    message: format!("unexpected character '{c}'"),
                    span: Span::new(start, start + c_len),
                });
            }
        };

        let end = i;
        out.push(Token {
            kind,
            span: Span::new(start, end),
        });
    }

    out.push(Token {
        kind: TokenKind::Eof,
        span: Span::new(input.len(), input.len()),
    });

    Ok(out)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lexes_calls_and_ops() {
        let t = lex("score(11+3); dbl()").unwrap();
        assert!(t.iter().any(|t| matches!(t.kind, TokenKind::Plus)));
        assert!(t.iter().any(|t| matches!(t.kind, TokenKind::Semi)));
    }
}


```

```rust
use serde::{Deserialize, Serialize};

use super::Span;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Program {
    pub calls: Vec<Call>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Call {
    pub name: String,
    pub name_span: Span,
    pub args: Vec<Expr>,
    pub span: Span,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum BinOp {
    Add,
    Mul,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Expr {
    Int(i64, Span),
    Var(String, Span),
    Binary {
        op: BinOp,
        lhs: Box<Expr>,
        rhs: Box<Expr>,
        span: Span,
    },
    Group(Box<Expr>, Span),
}

impl Expr {
    pub fn span(&self) -> Span {
        match self {
            Expr::Int(_, s) => *s,
            Expr::Var(_, s) => *s,
            Expr::Binary { span, .. } => *span,
            Expr::Group(_, s) => *s,
        }
    }
}



```

```rust
mod ast;
mod cost;
mod lexer;
mod parser;
mod span;
mod token;

pub use ast::{BinOp, Call, Expr, Program};
pub use cost::effective_len;
pub use lexer::{lex, LexError};
pub use parser::{parse_program, ParseError};
pub use span::Span;
pub use token::{Token, TokenKind};



```

```rust
use thiserror::Error;

use super::{
    lex, BinOp, Call, Expr, LexError, Program, Span, Token, TokenKind,
};

#[derive(Debug, Clone, PartialEq, Eq, Error)]
#[error("{message} at {span:?}")]
pub struct ParseError {
    pub message: String,
    pub span: Span,
}

impl From<LexError> for ParseError {
    fn from(value: LexError) -> Self {
        Self {
            message: value.message,
            span: value.span,
        }
    }
}

pub fn parse_program(input: &str) -> Result<Program, ParseError> {
    let tokens = lex(input)?;
    let mut p = Parser { tokens, i: 0 };
    p.parse_program()
}

struct Parser {
    tokens: Vec<Token>,
    i: usize,
}

impl Parser {
    fn parse_program(&mut self) -> Result<Program, ParseError> {
        let mut calls = Vec::new();

        self.consume_semi();
        while !self.at_eof() {
            calls.push(self.parse_call()?);
            self.consume_semi();
        }

        Ok(Program { calls })
    }

    fn parse_call(&mut self) -> Result<Call, ParseError> {
        let (name, name_span) = self.expect_ident()?;
        self.expect_simple(TokenKind::LParen)?;

        let mut args = Vec::new();
        if self.peek_is(&TokenKind::RParen) {
            let r = self.bump();
            let span = Span::merge(name_span, r.span);
            return Ok(Call {
                name,
                name_span,
                args,
                span,
            });
        }

        loop {
            args.push(self.parse_expr()?);
            if self.peek_is(&TokenKind::Comma) {
                self.bump();
                continue;
            }
            let r = self.expect_simple(TokenKind::RParen)?;
            let span = Span::merge(name_span, r.span);
            return Ok(Call {
                name,
                name_span,
                args,
                span,
            });
        }
    }

    fn parse_expr(&mut self) -> Result<Expr, ParseError> {
        self.parse_add()
    }

    fn parse_add(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.parse_mul()?;
        while self.peek_is(&TokenKind::Plus) {
            self.bump();
            let rhs = self.parse_mul()?;
            let span = Span::merge(expr.span(), rhs.span());
            expr = Expr::Binary {
                op: BinOp::Add,
                lhs: Box::new(expr),
                rhs: Box::new(rhs),
                span,
            };
        }
        Ok(expr)
    }

    fn parse_mul(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.parse_primary()?;
        while self.peek_is(&TokenKind::Star) {
            self.bump();
            let rhs = self.parse_primary()?;
            let span = Span::merge(expr.span(), rhs.span());
            expr = Expr::Binary {
                op: BinOp::Mul,
                lhs: Box::new(expr),
                rhs: Box::new(rhs),
                span,
            };
        }
        Ok(expr)
    }

    fn parse_primary(&mut self) -> Result<Expr, ParseError> {
        let t = self.peek().clone();
        match t.kind {
            TokenKind::NumUnary(n) => {
                let tok = self.bump();
                Ok(Expr::Int(n as i64, tok.span))
            }
            TokenKind::NumDigit(n) => {
                let tok = self.bump();
                Ok(Expr::Int(n as i64, tok.span))
            }
            TokenKind::Ident(name) => {
                let tok = self.bump();
                Ok(Expr::Var(name, tok.span))
            }
            TokenKind::LParen => {
                let l = self.bump();
                let inner = self.parse_expr()?;
                let r = self.expect_simple(TokenKind::RParen)?;
                let span = Span::merge(l.span, r.span);
                Ok(Expr::Group(Box::new(inner), span))
            }
            _ => Err(ParseError {
                message: "expected expression".to_string(),
                span: t.span,
            }),
        }
    }

    fn expect_ident(&mut self) -> Result<(String, Span), ParseError> {
        let t = self.peek().clone();
        match &t.kind {
            TokenKind::Ident(name) => {
                self.bump();
                Ok((name.clone(), t.span))
            }
            _ => Err(ParseError {
                message: "expected identifier".to_string(),
                span: t.span,
            }),
        }
    }

    fn expect_simple(&mut self, kind: TokenKind) -> Result<Token, ParseError> {
        let t = self.peek().clone();
        if std::mem::discriminant(&t.kind) == std::mem::discriminant(&kind) {
            Ok(self.bump())
        } else {
            Err(ParseError {
                message: format!("expected {kind:?}"),
                span: t.span,
            })
        }
    }

    fn consume_semi(&mut self) {
        while self.peek_is(&TokenKind::Semi) {
            self.bump();
        }
    }

    fn peek_is(&self, kind: &TokenKind) -> bool {
        std::mem::discriminant(&self.peek().kind) == std::mem::discriminant(kind)
    }

    fn at_eof(&self) -> bool {
        matches!(self.peek().kind, TokenKind::Eof)
    }

    fn peek(&self) -> &Token {
        &self.tokens[self.i]
    }

    fn bump(&mut self) -> Token {
        let t = self.tokens[self.i].clone();
        self.i = (self.i + 1).min(self.tokens.len().saturating_sub(1));
        t
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parses_simple_calls() {
        let p = parse_program("score(11); bank(3) dbl()").unwrap();
        assert_eq!(p.calls.len(), 3);
        assert_eq!(p.calls[0].name, "score");
        assert!(matches!(p.calls[0].args[0], Expr::Int(2, _)));
        assert!(matches!(p.calls[1].args[0], Expr::Int(3, _)));
        assert_eq!(p.calls[2].args.len(), 0);
    }

    #[test]
    fn parses_registers_and_ops() {
        let p = parse_program("score(len_deck*11+1)").unwrap();
        assert_eq!(p.calls.len(), 1);
        assert_eq!(p.calls[0].name, "score");
    }
}



```

```rust
use serde::{Deserialize, Serialize};

use crate::vm::Effect;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TraceEvent {
    Action { action: String },
    CardStart {
        index: usize,
        name: String,
        script: String,
        budget: usize,
        cost: usize,
    },
    Call { name: String, args: Vec<String> },
    EffectApplied { effect: Effect },
    Info(String),
    Error(String),
}



```

```rust
mod effects;
mod limits;
mod machine;

pub use effects::Effect;
pub use limits::Limits;
pub use machine::{Machine, VmContext, VmError};



```

```rust
use thiserror::Error;

use crate::kardlang::{BinOp, Call, Expr};

use super::{Effect, Limits};

pub trait VmContext {
    fn get(&self, name: &str) -> Option<i64>;
}

#[derive(Debug, Clone, PartialEq, Eq, Error)]
pub enum VmError {
    #[error("unknown function: {0}")]
    UnknownFunction(String),

    #[error("unknown register: {0}")]
    UnknownRegister(String),

    #[error("wrong arity for {name}: expected {expected}, got {got}")]
    WrongArity {
        name: String,
        expected: usize,
        got: usize,
    },

    #[error("integer overflow")]
    Overflow,

    #[error("execution aborted: exceeded max steps ({max_steps})")]
    StepLimitExceeded { max_steps: usize },
}

#[derive(Debug, Clone)]
pub struct Machine {
    steps: usize,
    limits: Limits,
}

impl Machine {
    pub fn new(limits: Limits) -> Self {
        Self { steps: 0, limits }
    }

    pub fn eval_call<C: VmContext>(&mut self, call: &Call, ctx: &C) -> Result<Vec<Effect>, VmError> {
        self.steps += 1;
        if self.steps > self.limits.max_steps {
            return Err(VmError::StepLimitExceeded {
                max_steps: self.limits.max_steps,
            });
        }

        match call.name.as_str() {
            "score" => {
                let n = expect_one_int(call, ctx)?;
                Ok(vec![Effect::AddScore(n)])
            }
            "bank" => {
                let n = expect_one_int(call, ctx)?;
                Ok(vec![Effect::AddBankroll(n)])
            }
            "dbl" => {
                expect_arity(call, 0)?;
                Ok(vec![Effect::MulBankroll(2)])
            }
            other => Err(VmError::UnknownFunction(other.to_string())),
        }
    }
}

fn expect_arity(call: &Call, expected: usize) -> Result<(), VmError> {
    let got = call.args.len();
    if got != expected {
        return Err(VmError::WrongArity {
            name: call.name.clone(),
            expected,
            got,
        });
    }
    Ok(())
}

fn expect_one_int<C: VmContext>(call: &Call, ctx: &C) -> Result<i64, VmError> {
    expect_arity(call, 1)?;
    eval_expr(&call.args[0], ctx)
}

fn eval_expr<C: VmContext>(expr: &Expr, ctx: &C) -> Result<i64, VmError> {
    match expr {
        Expr::Int(n, _) => Ok(*n),
        Expr::Var(name, _) => ctx
            .get(name)
            .ok_or_else(|| VmError::UnknownRegister(name.clone())),
        Expr::Group(inner, _) => eval_expr(inner, ctx),
        Expr::Binary { op, lhs, rhs, .. } => {
            let a = eval_expr(lhs, ctx)?;
            let b = eval_expr(rhs, ctx)?;
            match op {
                BinOp::Add => a.checked_add(b).ok_or(VmError::Overflow),
                BinOp::Mul => a.checked_mul(b).ok_or(VmError::Overflow),
            }
        }
    }
}



```

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmContext, VmError};

use crate::game::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        let deck = cards::starter_deck_ids()
            .iter()
            .map(|id| CardInstance::new(*id))
            .collect();
        Self::with_deck(seed, deck, Limits::default())
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let hand = std::mem::take(&mut self.state.hand);
        for (index, card) in hand.into_iter().enumerate() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            for call in &program.calls {
                let args = call.args.iter().map(expr_to_string).collect::<Vec<_>>();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let ctx = GameCtx { state: &self.state };
                let effects = vm.eval_call(call, &ctx)?;
                self.apply_effects(effects);
            }

            self.state.discard.push(card);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || to >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    v.insert(to, item);
}

struct GameCtx<'a> {
    state: &'a GameState,
}

impl VmContext for GameCtx<'_> {
    fn get(&self, name: &str) -> Option<i64> {
        match name {
            "len_deck" => Some(self.state.deck.len() as i64),
            "len_pool" | "len_collection" => Some(self.state.collection.len() as i64),
            "len_hand" => Some(self.state.hand.len() as i64),
            "len_discard" => Some(self.state.discard.len() as i64),
            "score" => Some(self.state.score),
            "bankroll" => Some(self.state.bankroll),
            "level" => Some(self.state.level as i64),
            "target" => Some(self.state.target_score),
            "max_step" | "max_steps" => Some(self.state.limits.max_steps as i64),
            "max_loop" | "max_loop_iters" => Some(self.state.limits.max_loop_iters as i64),
            _ => None,
        }
    }
}

fn expr_to_string(expr: &crate::kardlang::Expr) -> String {
    use crate::kardlang::{BinOp, Expr};
    match expr {
        Expr::Int(n, _) => n.to_string(),
        Expr::Var(name, _) => name.clone(),
        Expr::Group(inner, _) => format!("({})", expr_to_string(inner)),
        Expr::Binary { op, lhs, rhs, .. } => {
            let op_str = match op {
                BinOp::Add => "+",
                BinOp::Mul => "*",
            };
            format!("{}{}{}", expr_to_string(lhs), op_str, expr_to_string(rhs))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![CardInstance::new("score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}



```

```plaintext
div { class:"card-script",
    if let Some(tokens) = tokens {
        for tok in tokens.iter().filter(...) { span { class: "...", "{&script[tok.span.start..tok.span.end]}" } }
    } else {
        "{script}"
    }
}
```

```plaintext
let script_tokens = kardinality::kardlang::lex(script).ok();

rsx! {
  div { class:"card-script",
    match script_tokens {
      Some(tokens) => rsx! { for tok in tokens { ... } },
      None => rsx! { "{script}" },
    }
  }
}
```

```plaintext
for (text, class) in token_spans { span { class: "tok tok-{class}", "{text}" } }
```

```plaintext
Key::Tab => { if focus() == Collection { focus.set(Hand) } else { focus.set(Collection) } }
```

```rust
use dioxus::prelude::*;

#[component]
pub fn CardView(
    index: usize,
    card: kardinality::game::CardInstance,
    selected: bool,
    primary_icon: &'static str,
    on_select: EventHandler<usize>,
    on_primary: EventHandler<usize>,
    on_move_left: EventHandler<usize>,
    on_move_right: EventHandler<usize>,
    on_docs: EventHandler<String>,
) -> Element {
    let badge = format!("#{index}");

    let def_id = card.def_id.clone();
    let (name, script, budget, icon, doc_hint) = card
        .def()
        .map(|d| (d.name, d.script, d.budget, d.icon, d.kind))
        .map(|(name, script, budget, icon, kind)| (name, script, budget, icon, format!("{kind:?}")))
        .unwrap_or(("Missing Card", "/* missing */", 0, "?", "Missing".to_string()));

    let script_spans: Vec<(String, &'static str)> = match kardinality::kardlang::lex(script) {
        Ok(tokens) => tokens
            .into_iter()
            .filter(|t| !matches!(t.kind, kardinality::kardlang::TokenKind::Eof))
            .map(|t| {
                let text = script
                    .get(t.span.start..t.span.end)
                    .unwrap_or("")
                    .to_string();
                let class = match t.kind {
                    kardinality::kardlang::TokenKind::Ident(_) => "ident",
                    kardinality::kardlang::TokenKind::NumUnary(_) => "num",
                    kardinality::kardlang::TokenKind::NumDigit(_) => "num",
                    kardinality::kardlang::TokenKind::Plus => "op",
                    kardinality::kardlang::TokenKind::Star => "op",
                    kardinality::kardlang::TokenKind::LParen => "punct",
                    kardinality::kardlang::TokenKind::RParen => "punct",
                    kardinality::kardlang::TokenKind::Comma => "punct",
                    kardinality::kardlang::TokenKind::Semi => "punct",
                    kardinality::kardlang::TokenKind::Eof => "punct",
                };
                (text, class)
            })
            .collect(),
        Err(_) => vec![(script.to_string(), "raw")],
    };

    let class = if selected { "card selected" } else { "card" };

    rsx! {
        div {
            class: "{class}",
            onclick: move |_| on_select.call(index),
            div { class: "card-badge", "{badge}" }
            div { class: "card-art" }
            div { class: "card-body",
                h3 { class: "card-title", "{icon} {name}" }
                div { class: "card-sub", "{doc_hint} • Budget: {budget}" }
                div { class: "card-script",
                    for (text, cls) in script_spans {
                        span { class: "tok tok-{cls}", "{text}" }
                    }
                }
            }

            div { class: "card-actions",
                button {
                    class: "card-btn",
                    title: "Docs",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_docs.call(def_id.clone());
                    },
                    "⌘"
                }
                button {
                    class: "card-btn",
                    title: "Move",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_primary.call(index);
                    },
                    "{primary_icon}"
                }
                button {
                    class: "card-btn",
                    title: "Move left",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_left.call(index);
                    },
                    "←"
                }
                button {
                    class: "card-btn",
                    title: "Move right",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_right.call(index);
                    },
                    "→"
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 32px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
}

.playfield .center-hint {
  text-align: center;
  max-width: 520px;
  padding: 18px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.5;
  align-self: center;
}

.collectionbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.hand-row {
  display: flex;
  gap: 12px;
  overflow-x: auto;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.hand-row::-webkit-scrollbar {
  height: 8px;
}
.hand-row::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.hand-row::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Collection,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Collection);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Collection {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Collection);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Collection {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Collection);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Collection);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn KardinomiconModal(
    open: bool,
    target: Option<String>,
    on_close: EventHandler<()>,
) -> Element {
    let catalog = kardinality::game::cards::catalog();

    // If a target is provided, show it first.
    let mut ordered: Vec<kardinality::game::cards::CardDef> = Vec::with_capacity(catalog.len());
    if let Some(t) = target.as_deref() {
        if let Some(found) = catalog.iter().find(|c| c.id == t) {
            ordered.push(*found);
        }
    }
    for c in catalog {
        if ordered.first().is_some_and(|first| first.id == c.id) {
            continue;
        }
        ordered.push(*c);
    }

    rsx! {
        if open {
            div {
                class: "modal-overlay",
                onclick: move |_| on_close.call(()),

                div {
                    class: "modal panel",
                    onclick: move |evt| evt.stop_propagation(),

                    div { class: "modal-header",
                        div { class: "modal-title",
                            span { class: "modal-glyph", "⟡" }
                            span { "Kardinomicon" }
                        }
                        button { class: "btn danger", onclick: move |_| on_close.call(()), "Close" }
                    }

                    div { class: "modal-body",
                        h2 { class: "hud-title", "Language" }
                        div { class: "kdoc",
                            "Kardlang is a tiny integer-only language designed for card execution budgets."
                            br {}
                            "Numbers are unary (\"111\" = 3) or digit shorthand (\"4\" = 4 but costs 4)."
                            br {}
                            "Values support identifiers (registers) and + / * expressions."
                            br {}
                            "Registers: len_deck, len_pool, len_hand, len_discard, score, bankroll, level, target, max_steps, max_loop."
                        }

                        h2 { class: "hud-title", "Functions" }
                        div { class: "kdoc",
                            "score(n)  → add n to score"
                            br {}
                            "bank(n)   → add n to bankroll"
                            br {}
                            "dbl()     → bankroll *= 2"
                        }

                        h2 { class: "hud-title", "Cards" }
                        div { class: "kcard-list",
                            for c in ordered {
                                KardinomiconCard {
                                    card: c,
                                    highlight: target.as_deref().is_some_and(|t| t == c.id),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn KardinomiconCard(card: kardinality::game::cards::CardDef, highlight: bool) -> Element {
    let class = if highlight { "kcard highlight" } else { "kcard" };
    rsx! {
        div { class: "{class}",
            div { class: "kcard-head",
                span { class: "kcard-icon", "{card.icon}" }
                div { class: "kcard-title",
                    div { class: "kcard-name", "{card.name}" }
                    div { class: "kcard-id", "{card.id}" }
                }
                div { class: "kcard-script", "{card.script}" }
            }
            pre { class: "kcard-doc", "{card.doc.trim()}" }
        }
    }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn CardView(
    index: usize,
    card: kardinality::game::CardInstance,
    selected: bool,
    primary_icon: &'static str,
    on_select: EventHandler<usize>,
    on_primary: EventHandler<usize>,
    on_move_left: EventHandler<usize>,
    on_move_right: EventHandler<usize>,
    on_docs: EventHandler<String>,
) -> Element {
    let badge = format!("#{index}");

    let def_id = card.def_id.clone();
    let (name, script, budget, icon, doc_hint) = card
        .def()
        .map(|d| (d.name, d.script, d.budget, d.icon, d.kind))
        .map(|(name, script, budget, icon, kind)| (name, script, budget, icon, format!("{kind:?}")))
        .unwrap_or(("Missing Card", "/* missing */", 0, "?", "Missing".to_string()));

    let script_spans: Vec<(String, &'static str)> = match kardinality::kardlang::lex(script) {
        Ok(tokens) => tokens
            .into_iter()
            .filter(|t| !matches!(t.kind, kardinality::kardlang::TokenKind::Eof))
            .map(|t| {
                let text = script
                    .get(t.span.start..t.span.end)
                    .unwrap_or("")
                    .to_string();
                let class = match t.kind {
                    kardinality::kardlang::TokenKind::Ident(_) => "ident",
                    kardinality::kardlang::TokenKind::NumUnary(_) => "num",
                    kardinality::kardlang::TokenKind::NumDigit(_) => "num",
                    kardinality::kardlang::TokenKind::Plus => "op",
                    kardinality::kardlang::TokenKind::Star => "op",
                    kardinality::kardlang::TokenKind::LParen => "punct",
                    kardinality::kardlang::TokenKind::RParen => "punct",
                    kardinality::kardlang::TokenKind::Comma => "punct",
                    kardinality::kardlang::TokenKind::Semi => "punct",
                    kardinality::kardlang::TokenKind::Eof => "punct",
                };
                (text, class)
            })
            .collect(),
        Err(_) => vec![(script.to_string(), "raw")],
    };

    let class = if selected { "card selected" } else { "card" };

    rsx! {
        div {
            class: "{class}",
            onclick: move |_| on_select.call(index),
            div { class: "card-badge", "{badge}" }
            div { class: "card-art" }
            div { class: "card-body",
                h3 { class: "card-title", "{icon} {name}" }
                div { class: "card-sub", "{doc_hint} • Budget: {budget}" }
                div { class: "card-script",
                    for (text, cls) in script_spans {
                        span { class: "tok tok-{cls}", "{text}" }
                    }
                }
            }

            div { class: "card-actions",
                button {
                    class: "card-btn",
                    title: "Docs",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_docs.call(def_id.clone());
                    },
                    "📖"
                }
                button {
                    class: "card-btn",
                    title: "Move",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_primary.call(index);
                    },
                    "{primary_icon}"
                }
                button {
                    class: "card-btn",
                    title: "Move left",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_left.call(index);
                    },
                    "←"
                }
                button {
                    class: "card-btn",
                    title: "Move right",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_right.call(index);
                    },
                    "→"
                }
            }
        }
    }
}



```

```rust
pub const GRAMMAR: &str = r#"
Kardlang v0 grammar (EBNF-ish)

program   := (call (sep call)*)? ;
sep       := ';' | whitespace ;

call      := ident '(' (expr (',' expr)*)? ')' ;

expr      := add ;
add       := mul ( '+' mul )* ;
mul       := primary ( '*' primary )* ;

primary   := number
          | ident
          | '(' expr ')' ;

number    := unary | digit ;
unary     := '1'+ ;
digit     := '0' | '2'..'9' ;

ident     := [A-Za-z_][A-Za-z0-9_]* ;

Notes
* All values are integers.
* Digit shorthand is intentionally single-digit (no multi-digit literals).
* Cost model (enforced at the card level): each character costs 1, except digits cost their numeric value (0 costs 1).
"#;


```

```rust
mod ast;
mod cost;
mod grammar;
mod lexer;
mod parser;
mod span;
mod token;

pub use ast::{BinOp, Call, Expr, Program};
pub use cost::effective_len;
pub use grammar::GRAMMAR;
pub use lexer::{lex, LexError};
pub use parser::{parse_program, ParseError};
pub use span::Span;
pub use token::{Token, TokenKind};



```

```rust
use dioxus::prelude::*;

#[component]
pub fn KardinomiconModal(
    open: bool,
    target: Option<String>,
    on_close: EventHandler<()>,
) -> Element {
    let catalog = kardinality::game::cards::catalog();

    // If a target is provided, show it first.
    let mut ordered: Vec<kardinality::game::cards::CardDef> = Vec::with_capacity(catalog.len());
    if let Some(t) = target.as_deref() {
        if let Some(found) = catalog.iter().find(|c| c.id == t) {
            ordered.push(*found);
        }
    }
    for c in catalog {
        if ordered.first().is_some_and(|first| first.id == c.id) {
            continue;
        }
        ordered.push(*c);
    }

    rsx! {
        if open {
            div {
                class: "modal-overlay",
                onclick: move |_| on_close.call(()),

                div {
                    class: "modal panel",
                    onclick: move |evt| evt.stop_propagation(),

                    div { class: "modal-header",
                        div { class: "modal-title",
                            span { class: "modal-glyph", "⟡" }
                            span { "Kardinomicon" }
                        }
                        button { class: "btn danger", onclick: move |_| on_close.call(()), "Close" }
                    }

                    div { class: "modal-body",
                        h2 { class: "hud-title", "Language" }
                        div { class: "kdoc",
                            "Kardlang is a tiny integer-only language designed for card execution budgets."
                            br {}
                            "Numbers are unary (\"111\" = 3) or digit shorthand (\"4\" = 4 but costs 4)."
                            br {}
                            "Values support identifiers (registers) and + / * expressions."
                            br {}
                            "Registers: len_deck, len_pool, len_hand, len_discard, score, bankroll, level, target, max_steps, max_loop."
                        }
                        pre { class: "kcard-doc", "{kardinality::kardlang::GRAMMAR.trim()}" }

                        h2 { class: "hud-title", "Functions" }
                        div { class: "kdoc",
                            "score(n)  → add n to score"
                            br {}
                            "bank(n)   → add n to bankroll"
                            br {}
                            "dbl()     → bankroll *= 2"
                        }

                        h2 { class: "hud-title", "Cards" }
                        div { class: "kcard-list",
                            for c in ordered {
                                KardinomiconCard {
                                    card: c,
                                    highlight: target.as_deref().is_some_and(|t| t == c.id),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn KardinomiconCard(card: kardinality::game::cards::CardDef, highlight: bool) -> Element {
    let class = if highlight { "kcard highlight" } else { "kcard" };
    rsx! {
        div { class: "{class}",
            div { class: "kcard-head",
                span { class: "kcard-icon", "{card.icon}" }
                div { class: "kcard-title",
                    div { class: "kcard-name", "{card.name}" }
                    div { class: "kcard-id", "{card.id}" }
                }
                div { class: "kcard-script", "{card.script}" }
            }
            pre { class: "kcard-doc", "{card.doc.trim()}" }
        }
    }
}



```

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CardKind {
    Economy,
    Score,
    Control,
    Meta,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CardDef {
    pub id: &'static str,
    pub name: &'static str,
    pub kind: CardKind,
    pub budget: usize,
    pub script: &'static str,
    pub icon: &'static str,
    pub doc: &'static str,
}

pub fn catalog() -> &'static [CardDef] {
    &CATALOG
}

pub fn get(id: &str) -> Option<&'static CardDef> {
    CATALOG.iter().find(|c| c.id == id)
}

pub fn starter_deck_ids() -> &'static [&'static str] {
    &["score_2", "score_len_deck", "bank_3", "bank_len_pool", "dbl_bank"]
}

static CATALOG: [CardDef; 5] = [
    CardDef {
        id: "score_2",
        name: "Score +2",
        kind: CardKind::Score,
        budget: 12,
        script: "score(11)",
        icon: "▲",
        doc: r#"
Adds to your score.

* **Effect**: `score(n)` increases `score` by `n`.
* **Default script**: `score(11)` (unary 2)
* **Notes**: Score is compared against `target` to clear the level.
"#,
    },
    CardDef {
        id: "score_len_deck",
        name: "Score +len_deck",
        kind: CardKind::Score,
        budget: 24,
        script: "score(len_deck)",
        icon: "Σ",
        doc: r#"
Adds the current deck size to your score.

* **Effect**: `score(len_deck)` increases `score` by `len_deck`.
* **Register**: `len_deck` is the number of cards in the draw pile.
"#,
    },
    CardDef {
        id: "bank_3",
        name: "Bank +3",
        kind: CardKind::Economy,
        budget: 12,
        script: "bank(111)",
        icon: "$",
        doc: r#"
Adds to your bankroll.

* **Effect**: `bank(n)` increases `bankroll` by `n`.
* **Default script**: `bank(111)` (unary 3)
"#,
    },
    CardDef {
        id: "bank_len_pool",
        name: "Bank +len_pool",
        kind: CardKind::Economy,
        budget: 24,
        script: "bank(len_pool)",
        icon: "$",
        doc: r#"
Adds the current collection size to your bankroll.

* **Effect**: `bank(len_pool)` increases `bankroll` by `len_pool`.
* **Register**: `len_pool` is the number of cards currently in your collection.
"#,
    },
    CardDef {
        id: "dbl_bank",
        name: "Double Bank",
        kind: CardKind::Economy,
        budget: 12,
        script: "dbl()",
        icon: "×2",
        doc: r#"
Doubles your bankroll.

* **Effect**: `dbl()` multiplies `bankroll` by 2.
* **Default script**: `dbl()`
"#,
    },
];



```

### What you have now

- **Real gameplay zones**: `Deck → Collection → Active Hand → Discard`
  - Draw fills **Collection**, you **pick/move** cards into the **Active Hand** (your program), then **Execute hand**.
  - **Reordering** works for both Collection and Active Hand (buttons on cards + keyboard).

- **Keyboard-first controls**
  - **← / →**: move selection
  - **Shift + ← / →**: reorder within the current row
  - **↑**: move selected **Collection → Hand** (and focus Hand)
  - **↓**: move selected **Hand → Collection** (and focus Collection)
  - **Enter**: execute the active hand
  - **Tab**: toggle focus between Collection and Hand

- **HUD is artsy**
  - Score has a **color-coded progress bar** vs target
  - Bankroll shows **$**
  - Level moved into the **Deck widget**
  - Registers show `len_deck`, `len_pool`, `len_hand`, `len_discard`, `max_steps`, etc.

- **Settings + themes**
  - Sidebar **Settings** tab: **CRT / Terminal / Arcane** themes + **CRT overlays toggle** (CSS-only)

- **Kardinomicon**
  - Click the **📖** on any card to open the **Kardinomicon** and **highlight** that card’s entry
  - Shows language + grammar + functions + the full card catalog

- **Kardlang upgraded (for highlighting + better errors)**
  - Lexer + spanned AST + parser now supports **identifiers (registers)** and **`+` / `*` expressions**
  - Card scripts are now **syntax highlighted** from the lexer tokens

### Where to edit things

- **Add/edit cards + docs**: `src/game/cards.rs` (each card has `kind`, `script`, `budget`, `doc`, `icon`)
- **Language/grammar**: `src/kardlang/` (see `GRAMMAR` and lexer/parser)
- **Theme/CSS vibes**: `src/ui/theme.rs`

---

**User**

Very good! A few more notes to iterate on:

* Right now, "the program space" is too big and causes the active hand to disappear off the screen. I'd put that somewhere else or nuke it entirely
* The CRT effect could be made more extensive, like with scanlines and fisheye over the whole screen. Go a little wild with it
* Let's rename some things -- I like "hand" for the cards being selected for play now, let's do our "deck" being what was called the "collection", and let's think of more intuititive names to give how we generate new cards
* When cards animate when hovering over them, they are hidden by the "collection" header just kind of chopping them off
* I think active hand cards need to be on top lof the layout of your hole cards
* Control of the cards needs to be cleaned up, I should be able to drag and drop them between my active hand and my deck, or use a keyboard (or, in the future, also use a controller but we can not implement that if you think it will be too complicated).
* Controls should effectively be "up/down/left/right" and "enter" to navigate the WHOLE UI. See if you can architect that to make it work

Think of more animations and making them clean. Again its a game, not a web app! It should look pretty crazy. And the hacker vibes should be NEON GREEN GLOWING TEXT. The magic aura should be RAINBOW GRADIENTS PURPLE MAGIK

Think of better cards and kardlang too, let's always start the player with 3 cards at the start, with "draw(5)", "score(4)", and "bank(6)". In addition, let's spice up the possible functions you can use. In addition, let's document the grammar more completely. Create an entire file that's like KARDLANG.md that describes the language philosophy

Here's something from another LLM to help you get inspired. Don't take every aspect (all the variables, the extended syntax, and so on) literally, but use them as material to populate your implementation:

## Kardlang vibe and constraints

Kardlang is a **character-budget language** where card text is executable code. The cost of a card is the number of characters in its program, and the language is designed so that:

* **Power scales with length**: longer function names and longer programs can express stronger effects or broader control. Short cards are intentionally narrow.
* **Large numbers are intentionally inconvenient**: writing the literal number `N` costs `N` characters (with `0` costing 1). This prevents “type 5000” strategies and forces players to rely on *game-state-derived values* and modest growth transforms.
* **Arithmetic is minimal by design**: only `+` and `*` operators exist inside arguments. There is no `-`, no `/`, no exponentiation, no composition.
* **No composition (for now)**: each line is exactly one call:

  ```
  function(arg, arg, ...)
  ```

  No nesting. No `score(sqr(len_hand))`. If you want multi-step logic, you spend multiple lines (characters) to do it.

---

## Virtual machine model

### Registers as named state reads

The VM exposes **named registers** that read (and sometimes write) the game state. These are identifiers like:

* `len_deck` — number of cards remaining in deck
* `len_hand` — number of cards currently in hand
* `level` — current level / round index
* `score_now` — current score (read-only, typically)
* `bank_now` — current money (read-only, typically)
* `turn_played` — number of cards played this turn
* `target_score` — current target score

They are intentionally **not 1-character**. Referencing state costs characters, which is part of balance.

### Stack evaluation (numbers only)

Each line is evaluated with a simple numeric stack:

* A function may **push** a number to the stack.
* A function may **pop** one or more numbers from the stack.
* Many functions accept explicit numeric arguments; if an argument is omitted (if you allow that later), they could pop from stack, but you do not need omission right now.

Since you disallow composition, the stack is the normal way to move numeric results from one line to the next.

Recommended minimal rule:

* Numeric-producing functions (`sqr`, `tri`, `fibo`) **push** results.
* Consuming functions (`draw`, `score`, `bank`, `clone`, `again`) **pop** required numeric arguments from the stack *if not provided explicitly*, but in this write-up below I will specify them as explicit arguments to keep it simple and unambiguous.

---

## Function suite (exact behavior)

### `sqr(x)`

**Category:** numeric transform (moderate growth)
**Arguments:** `x` (number expression using only `+` and `*`, may reference registers)
**Effect:** computes `x*x` and **pushes the result** to the stack.

* Deterministic.
* Intended as the strongest “safe” growth tool.

Example lines:

```
sqr(len_hand)
sqr(level+1)
```

---

### `tri(x)`

**Category:** numeric transform (smooth growth)
**Arguments:** `x`
**Effect:** computes the triangular number `x*(x+1)/2` and **pushes the result** to the stack.

* Internally uses exact integer math (the VM can implement the division as part of the primitive).
* Deterministic, easy to reason about.

Examples:

```
tri(level)
tri(len_deck)
```

---

### `fibo(x)`

**Category:** numeric transform (staged growth)
**Arguments:** `x`
**Effect:** computes `F(x)` and **pushes the result** to the stack, where `F(0)=0, F(1)=1`.

Balance rule (recommended, deterministic):

* The VM may clamp `x` to a maximum (e.g., `x<=Ncap`) to avoid runaway.

Examples:

```
fibo(level)
fibo(len_hand+2)
```

---

### `draw(n)`

**Category:** game action (card economy)
**Arguments:** `n`
**Effect:** draws `n` cards from the deck into the hand, up to availability.

* Side effects:

  * `len_deck` decreases by the number actually drawn
  * `len_hand` increases by the number actually drawn
* Return convention (choose one and stay consistent):

  * Either pushes `n_drawn` to stack, or pushes nothing. Simpler: pushes nothing.

Examples:

```
draw(1)
draw(len_hand)
draw(tri(level))   // NOT allowed (no composition)
```

To do a multi-step version without composition:

```
tri(level)
draw(pop)
```

Where `pop` is described below.

---

### `clone(n)`

**Category:** action amplification (deterministic)
**Arguments:** `n`
**Effect:** duplicates the **last-played card** `n` times into the execution queue (or into hand; pick one model).

Recommended, simple execution-queue model:

* Clones are scheduled to execute **immediately after the current card finishes**, preserving order.

Constraints (recommended for clarity/balance):

* `clone` cannot clone itself when it is the last-played card (or it can, but with a hard cap per turn).
* `n` is capped by a rule (e.g., `n <= len_hand` or `n <= clone_cap(level)`).

Examples:

```
clone(2)
clone(len_hand)
```

---

### `mutate()`

**Category:** volatility / roguelike randomness
**Arguments:** none
**Effect:** applies a random mutation to the **last-played card**, producing a modified card instance that replaces it (or modifies its next execution if already queued).

Mutation outcomes should be **small, legible deltas**, not a total rewrite, so players can learn it. Example mutation table:

* tweak a numeric argument by `+1` or `*2`
* swap `draw` ↔ `clone` in limited contexts
* add/remove a line (bounded)
* add a “glitch tag” that changes resolution order for one turn

The key property:

* `mutate()` can be **good or bad**, and is explicitly unpredictable.

Example:

```
mutate()
```

---

### `again(n)`

**Category:** action replay (deterministic)
**Arguments:** `n`
**Effect:** re-executes the **last-played card** `n` additional times.

Recommended semantics (clear and debuggable):

* Each replay uses the game state as it exists at the time of replay.
* Replays are queued immediately after the current card.

Constraints (recommended):

* Cannot target itself as last-played card (or hard-cap chain depth).
* `n` capped.

Examples:

```
again(1)
again(level)
```

---

### `score(x)`

**Category:** primary win-condition sink
**Arguments:** `x`
**Effect:** adds `x` to the player’s score.

* Side effect: increases `score_now` by `x`.
* Typically does not push anything.

Examples:

```
score(1)
score(len_hand*level)
```

---

### `bank(x)`

**Category:** secondary resource sink
**Arguments:** `x`
**Effect:** adds `x` to the player’s bank/money.

* Side effect: increases `bank_now` by `x`.

Examples:

```
bank(1)
bank(level)
```

---

## Minimal stack glue (needed without composition)

Without composition, you still need a way to feed numeric results from transforms into action sinks. The cleanest *small* mechanism is stack operations. Two primitives are enough and are not overpowered because they don’t create value, only move it:

### `push(x)`

Pushes the numeric value `x` onto the stack.

Example:

```
push(len_hand)
sqr(pop)
score(pop)
```

### `pop`

Used only as an argument placeholder meaning “take from stack”.

* `pop` is not a variable; it is a syntactic token.
* It costs 3 characters, which is meaningful.

If you don’t want `push`, you can require all numeric transforms to push automatically, but then you still need `pop`:

Example:

```
sqr(len_hand)   // pushes
score(pop)      // consumes
```

This preserves: one call per line, no composition, no one-letter state access.

---

## Summary

* State access is intentionally verbose (`len_hand`, `len_deck`, `target_score`, `level`), so “reading the world” has a cost.
* Numeric growth is constrained to **`sqr`, `tri`, `fibo`** (no pow/fact).
* Player power comes from **sequencing** (`again`, `clone`, `mutate`) and **resource routing** (`score`, `bank`, `draw`) rather than from manufacturing huge constants.
* No composition keeps cards readable; stack tokens (`pop`, optionally `push`) provide the minimum glue to make multi-step cards possible.

If you want, I can propose exact caps/guardrails (per-turn replay depth, clone limits, mutate table weights) tuned so that longer cards are stronger but not degenerately infinite.






---

**Cursor**

Plan: fix the layout first (hand always visible, no “program space” eating height, hover not clipped), then rename UI terms (Deck/Hand), then add drag‑drop, then beef up CRT distortion + themes, and finally update starter cards + add `draw(n)` + write `KARDLANG.md`.

Nice — we can fix the “hand disappearing” issue by removing the big center hint and adding `min-height: 0` to the grid so the middle row can actually shrink. Next I’ll rename the UI labels to Deck/Hand and change the card rows to a scroll-wrapper that won’t clip hover animations.

```rust
*** Begin Patch
*** Update File: src/ui/app.rs
@@
 enum FocusZone {
-    Collection,
+    Deck,
     Hand,
 }
@@
     // Keyboard-first selection state.
-    let mut focus = use_signal(|| FocusZone::Collection);
+    let mut focus = use_signal(|| FocusZone::Deck);
     let mut sel_collection = use_signal(|| 0usize);
     let mut sel_hand = use_signal(|| 0usize);
@@
                 match key {
                     Key::ArrowLeft => {
-                        if focus() == FocusZone::Collection {
+                        if focus() == FocusZone::Deck {
                             let len = engine.read().state.collection.len();
                             let idx = sel_collection();
                             if shift && len > 0 && idx > 0 {
                                 let mut eng = engine.write();
                                 let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
@@
                     }
                     Key::ArrowRight => {
-                        if focus() == FocusZone::Collection {
+                        if focus() == FocusZone::Deck {
                             let len = engine.read().state.collection.len();
                             let idx = sel_collection();
                             if shift && len > 0 && idx + 1 < len {
                                 let mut eng = engine.write();
                                 let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
@@
                     Key::ArrowUp => {
                         // Move from collection -> hand and focus hand.
-                        if focus() == FocusZone::Collection {
+                        if focus() == FocusZone::Deck {
                             let idx = sel_collection();
                             let mut eng = engine.write();
                             if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                 eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                             }
                             focus.set(FocusZone::Hand);
@@
                     Key::ArrowDown => {
                         // Move from hand -> collection and focus collection.
                         if focus() == FocusZone::Hand {
@@
-                            focus.set(FocusZone::Collection);
+                            focus.set(FocusZone::Deck);
                             let new_coll_len = eng.state.collection.len();
                             if new_coll_len > 0 {
                                 sel_collection.set(new_coll_len - 1);
                             }
@@
                     Key::Tab => {
                         // Simple focus toggle between Collection and Hand.
-                        if focus() == FocusZone::Collection {
+                        if focus() == FocusZone::Deck {
                             focus.set(FocusZone::Hand);
                             let len = engine.read().state.hand.len();
                             sel_hand.set(clamp(sel_hand(), len));
                         } else {
-                            focus.set(FocusZone::Collection);
+                            focus.set(FocusZone::Deck);
                             let len = engine.read().state.collection.len();
                             sel_collection.set(clamp(sel_collection(), len));
                         }
                     }
                     _ => {}
                 }
             },
@@
-                div { class: "playfield",
-                    div { class: "center-hint",
-                        strong { "The Program Space" }
-                        br {}
-                        "Draw into your collection, then assemble an active hand (your program) and execute it."
-                        br {}
-                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
-                    }
-
-                    div { class: "collectionbar",
+                div { class: "playfield",
+                    div { class: "deckbar",
                         div { class: "hand-title",
-                            span { "Collection" }
+                            span { "Deck" }
                             span { class: "hint", "{collection_count} cards" }
                         }
 
                         if state.collection.is_empty() {
-                            div { class: "empty", "Draw cards to populate your collection." }
+                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                         } else {
-                            div { class: "hand-row",
-                                for (i, card) in state.collection.iter().cloned().enumerate() {
-                                    crate::ui::views::CardView {
-                                        index: i,
-                                        card,
-                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
-                                        primary_icon: "↑",
-                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
-                                        on_primary: move |idx| {
-                                            let mut eng = engine.write();
-                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
-                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
-                                            }
-                                            focus.set(FocusZone::Hand);
-                                            let new_hand_len = eng.state.hand.len();
-                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
-                                            let new_coll_len = eng.state.collection.len();
-                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
-                                        },
-                                        on_move_left: move |idx| {
-                                            if idx == 0 { return; }
-                                            let mut eng = engine.write();
-                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
-                                            focus.set(FocusZone::Collection);
-                                            sel_collection.set(idx - 1);
-                                        },
-                                        on_move_right: move |idx| {
-                                            let len = engine.read().state.collection.len();
-                                            if idx + 1 >= len { return; }
-                                            let mut eng = engine.write();
-                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
-                                            focus.set(FocusZone::Collection);
-                                            sel_collection.set(idx + 1);
-                                        },
-                                        on_docs: move |id| {
-                                            kardinomicon_target.set(Some(id));
-                                            kardinomicon_open.set(true);
-                                        },
-                                    }
-                                }
-                            }
+                            div { class: "row-scroll",
+                                div { class: "row",
+                                    for (i, card) in state.collection.iter().cloned().enumerate() {
+                                        crate::ui::views::CardView {
+                                            index: i,
+                                            card,
+                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
+                                            primary_icon: "↑",
+                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
+                                            on_primary: move |idx| {
+                                                let mut eng = engine.write();
+                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
+                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
+                                                }
+                                                focus.set(FocusZone::Hand);
+                                                let new_hand_len = eng.state.hand.len();
+                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
+                                                let new_coll_len = eng.state.collection.len();
+                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
+                                            },
+                                            on_move_left: move |idx| {
+                                                if idx == 0 { return; }
+                                                let mut eng = engine.write();
+                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
+                                                focus.set(FocusZone::Deck);
+                                                sel_collection.set(idx - 1);
+                                            },
+                                            on_move_right: move |idx| {
+                                                let len = engine.read().state.collection.len();
+                                                if idx + 1 >= len { return; }
+                                                let mut eng = engine.write();
+                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
+                                                focus.set(FocusZone::Deck);
+                                                sel_collection.set(idx + 1);
+                                            },
+                                            on_docs: move |id| {
+                                                kardinomicon_target.set(Some(id));
+                                                kardinomicon_open.set(true);
+                                            },
+                                        }
+                                    }
+                                }
+                            }
                         }
                     }
                 }
 
                 div { class: "handbar",
                     div { class: "hand-title",
-                        span { "Active Hand" }
+                        span { "Hand" }
                         span { class: "hint", "{hand_count} cards" }
                     }
 
                     if state.hand.is_empty() {
-                        div { class: "empty", "Move cards from Collection into your Active Hand." }
+                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                     } else {
-                        div { class: "hand-row",
-                            for (i, card) in state.hand.iter().cloned().enumerate() {
-                                crate::ui::views::CardView {
-                                    index: i,
-                                    card,
-                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
-                                    primary_icon: "↓",
-                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
-                                    on_primary: move |idx| {
-                                        let mut eng = engine.write();
-                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
-                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
-                                        }
-                                        focus.set(FocusZone::Collection);
-                                        let new_coll_len = eng.state.collection.len();
-                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
-                                        let new_hand_len = eng.state.hand.len();
-                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
-                                    },
-                                    on_move_left: move |idx| {
-                                        if idx == 0 { return; }
-                                        let mut eng = engine.write();
-                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
-                                        focus.set(FocusZone::Hand);
-                                        sel_hand.set(idx - 1);
-                                    },
-                                    on_move_right: move |idx| {
-                                        let len = engine.read().state.hand.len();
-                                        if idx + 1 >= len { return; }
-                                        let mut eng = engine.write();
-                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
-                                        focus.set(FocusZone::Hand);
-                                        sel_hand.set(idx + 1);
-                                    },
-                                    on_docs: move |id| {
-                                        kardinomicon_target.set(Some(id));
-                                        kardinomicon_open.set(true);
-                                    },
-                                }
-                            }
-                        }
+                        div { class: "row-scroll",
+                            div { class: "row",
+                                for (i, card) in state.hand.iter().cloned().enumerate() {
+                                    crate::ui::views::CardView {
+                                        index: i,
+                                        card,
+                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
+                                        primary_icon: "↓",
+                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
+                                        on_primary: move |idx| {
+                                            let mut eng = engine.write();
+                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
+                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
+                                            }
+                                            focus.set(FocusZone::Deck);
+                                            let new_coll_len = eng.state.collection.len();
+                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
+                                            let new_hand_len = eng.state.hand.len();
+                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
+                                        },
+                                        on_move_left: move |idx| {
+                                            if idx == 0 { return; }
+                                            let mut eng = engine.write();
+                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
+                                            focus.set(FocusZone::Hand);
+                                            sel_hand.set(idx - 1);
+                                        },
+                                        on_move_right: move |idx| {
+                                            let len = engine.read().state.hand.len();
+                                            if idx + 1 >= len { return; }
+                                            let mut eng = engine.write();
+                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
+                                            focus.set(FocusZone::Hand);
+                                            sel_hand.set(idx + 1);
+                                        },
+                                        on_docs: move |id| {
+                                            kardinomicon_target.set(Some(id));
+                                            kardinomicon_open.set(true);
+                                        },
+                                    }
+                                }
+                            }
+                        }
                     }
                 }
             }
         }
*** End Patch
```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Deck,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Collection {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Collection {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Collection);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Collection {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Collection);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Collection && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Collection); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Collection);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Collection);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Deck,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "center-hint",
                        strong { "The Program Space" }
                        br {}
                        "Draw into your collection, then assemble an active hand (your program) and execute it."
                        br {}
                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
                    }

                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
*** Begin Patch
*** Update File: src/ui/app.rs
@@
                 }
 
                 div { class: "playfield",
-                    div { class: "center-hint",
-                        strong { "The Program Space" }
-                        br {}
-                        "Draw into your collection, then assemble an active hand (your program) and execute it."
-                        br {}
-                        "Soon: control flow, stack tricks, wildcards, upgrades, and the Kardinomicon."
-                    }
-
-                    div { class: "collectionbar",
+                    div { class: "deckbar",
                         div { class: "hand-title",
-                            span { "Collection" }
+                            span { "Deck" }
                             span { class: "hint", "{collection_count} cards" }
                         }
 
                         if state.collection.is_empty() {
-                            div { class: "empty", "Draw cards to populate your collection." }
+                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                         } else {
-                            div { class: "hand-row",
-                                for (i, card) in state.collection.iter().cloned().enumerate() {
-                                    crate::ui::views::CardView {
-                                        index: i,
-                                        card,
-                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
-                                        primary_icon: "↑",
-                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
-                                        on_primary: move |idx| {
-                                            let mut eng = engine.write();
-                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
-                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
-                                            }
-                                            focus.set(FocusZone::Hand);
-                                            let new_hand_len = eng.state.hand.len();
-                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
-                                            let new_coll_len = eng.state.collection.len();
-                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
-                                        },
-                                        on_move_left: move |idx| {
-                                            if idx == 0 { return; }
-                                            let mut eng = engine.write();
-                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
-                                            focus.set(FocusZone::Deck);
-                                            sel_collection.set(idx - 1);
-                                        },
-                                        on_move_right: move |idx| {
-                                            let len = engine.read().state.collection.len();
-                                            if idx + 1 >= len { return; }
-                                            let mut eng = engine.write();
-                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
-                                            focus.set(FocusZone::Deck);
-                                            sel_collection.set(idx + 1);
-                                        },
-                                        on_docs: move |id| {
-                                            kardinomicon_target.set(Some(id));
-                                            kardinomicon_open.set(true);
-                                        },
-                                    }
-                                }
-                            }
+                            div { class: "row-scroll",
+                                div { class: "row",
+                                    for (i, card) in state.collection.iter().cloned().enumerate() {
+                                        crate::ui::views::CardView {
+                                            index: i,
+                                            card,
+                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
+                                            primary_icon: "↑",
+                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
+                                            on_primary: move |idx| {
+                                                let mut eng = engine.write();
+                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
+                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
+                                                }
+                                                focus.set(FocusZone::Hand);
+                                                let new_hand_len = eng.state.hand.len();
+                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
+                                                let new_coll_len = eng.state.collection.len();
+                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
+                                            },
+                                            on_move_left: move |idx| {
+                                                if idx == 0 { return; }
+                                                let mut eng = engine.write();
+                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
+                                                focus.set(FocusZone::Deck);
+                                                sel_collection.set(idx - 1);
+                                            },
+                                            on_move_right: move |idx| {
+                                                let len = engine.read().state.collection.len();
+                                                if idx + 1 >= len { return; }
+                                                let mut eng = engine.write();
+                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
+                                                focus.set(FocusZone::Deck);
+                                                sel_collection.set(idx + 1);
+                                            },
+                                            on_docs: move |id| {
+                                                kardinomicon_target.set(Some(id));
+                                                kardinomicon_open.set(true);
+                                            },
+                                        }
+                                    }
+                                }
+                            }
                         }
                     }
                 }
 
                 div { class: "handbar",
                     div { class: "hand-title",
-                        span { "Active Hand" }
+                        span { "Hand" }
                         span { class: "hint", "{hand_count} cards" }
                     }
 
                     if state.hand.is_empty() {
-                        div { class: "empty", "Move cards from Collection into your Active Hand." }
+                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                     } else {
-                        div { class: "hand-row",
-                            for (i, card) in state.hand.iter().cloned().enumerate() {
-                                crate::ui::views::CardView {
-                                    index: i,
-                                    card,
-                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
-                                    primary_icon: "↓",
-                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
-                                    on_primary: move |idx| {
-                                        let mut eng = engine.write();
-                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
-                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
-                                        }
-                                        focus.set(FocusZone::Deck);
-                                        let new_coll_len = eng.state.collection.len();
-                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
-                                        let new_hand_len = eng.state.hand.len();
-                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
-                                    },
-                                    on_move_left: move |idx| {
-                                        if idx == 0 { return; }
-                                        let mut eng = engine.write();
-                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
-                                        focus.set(FocusZone::Hand);
-                                        sel_hand.set(idx - 1);
-                                    },
-                                    on_move_right: move |idx| {
-                                        let len = engine.read().state.hand.len();
-                                        if idx + 1 >= len { return; }
-                                        let mut eng = engine.write();
-                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
-                                        focus.set(FocusZone::Hand);
-                                        sel_hand.set(idx + 1);
-                                    },
-                                    on_docs: move |id| {
-                                        kardinomicon_target.set(Some(id));
-                                        kardinomicon_open.set(true);
-                                    },
-                                }
-                            }
-                        }
+                        div { class: "row-scroll",
+                            div { class: "row",
+                                for (i, card) in state.hand.iter().cloned().enumerate() {
+                                    crate::ui::views::CardView {
+                                        index: i,
+                                        card,
+                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
+                                        primary_icon: "↓",
+                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
+                                        on_primary: move |idx| {
+                                            let mut eng = engine.write();
+                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
+                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
+                                            }
+                                            focus.set(FocusZone::Deck);
+                                            let new_coll_len = eng.state.collection.len();
+                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
+                                            let new_hand_len = eng.state.hand.len();
+                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
+                                        },
+                                        on_move_left: move |idx| {
+                                            if idx == 0 { return; }
+                                            let mut eng = engine.write();
+                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
+                                            focus.set(FocusZone::Hand);
+                                            sel_hand.set(idx - 1);
+                                        },
+                                        on_move_right: move |idx| {
+                                            let len = engine.read().state.hand.len();
+                                            if idx + 1 >= len { return; }
+                                            let mut eng = engine.write();
+                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
+                                            focus.set(FocusZone::Hand);
+                                            sel_hand.set(idx + 1);
+                                        },
+                                        on_docs: move |id| {
+                                            kardinomicon_target.set(Some(id));
+                                            kardinomicon_open.set(true);
+                                        },
+                                    }
+                                }
+                            }
+                        }
                     }
                 }
             }
         }
*** End Patch
```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Deck,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "collectionbar",
                        div { class: "hand-title",
                            span { "Collection" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Draw cards to populate your collection." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Active Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from Collection into your Active Hand." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Deck,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div { class: "hand-row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Deck,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div { class: "row-scroll",
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div { class: "hand-row",
                            for (i, card) in state.hand.iter().cloned().enumerate() {
                                crate::ui::views::CardView {
                                    index: i,
                                    card,
                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
                                    primary_icon: "↓",
                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                    on_primary: move |idx| {
                                        let mut eng = engine.write();
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        let new_coll_len = eng.state.collection.len();
                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                        let new_hand_len = eng.state.hand.len();
                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                    },
                                    on_move_left: move |idx| {
                                        if idx == 0 { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx - 1);
                                    },
                                    on_move_right: move |idx| {
                                        let len = engine.read().state.hand.len();
                                        if idx + 1 >= len { return; }
                                        let mut eng = engine.write();
                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(idx + 1);
                                    },
                                    on_docs: move |id| {
                                        kardinomicon_target.set(Some(id));
                                        kardinomicon_open.set(true);
                                    },
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
*** Begin Patch
*** Update File: src/ui/app.rs
@@
                     if state.hand.is_empty() {
                         div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                     } else {
-                        div { class: "hand-row",
-                            for (i, card) in state.hand.iter().cloned().enumerate() {
-                                crate::ui::views::CardView {
-                                    index: i,
-                                    card,
-                                    selected: focus_value == FocusZone::Hand && selected_hand == i,
-                                    primary_icon: "↓",
-                                    on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
-                                    on_primary: move |idx| {
-                                        let mut eng = engine.write();
-                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
-                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
-                                        }
-                                        focus.set(FocusZone::Deck);
-                                        let new_coll_len = eng.state.collection.len();
-                                        if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
-                                        let new_hand_len = eng.state.hand.len();
-                                        sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
-                                    },
-                                    on_move_left: move |idx| {
-                                        if idx == 0 { return; }
-                                        let mut eng = engine.write();
-                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
-                                        focus.set(FocusZone::Hand);
-                                        sel_hand.set(idx - 1);
-                                    },
-                                    on_move_right: move |idx| {
-                                        let len = engine.read().state.hand.len();
-                                        if idx + 1 >= len { return; }
-                                        let mut eng = engine.write();
-                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
-                                        focus.set(FocusZone::Hand);
-                                        sel_hand.set(idx + 1);
-                                    },
-                                    on_docs: move |id| {
-                                        kardinomicon_target.set(Some(id));
-                                        kardinomicon_open.set(true);
-                                    },
-                                }
-                            }
-                        }
+                        div { class: "row-scroll",
+                            div { class: "row",
+                                for (i, card) in state.hand.iter().cloned().enumerate() {
+                                    crate::ui::views::CardView {
+                                        index: i,
+                                        card,
+                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
+                                        primary_icon: "↓",
+                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
+                                        on_primary: move |idx| {
+                                            let mut eng = engine.write();
+                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
+                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
+                                            }
+                                            focus.set(FocusZone::Deck);
+                                            let new_coll_len = eng.state.collection.len();
+                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
+                                            let new_hand_len = eng.state.hand.len();
+                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
+                                        },
+                                        on_move_left: move |idx| {
+                                            if idx == 0 { return; }
+                                            let mut eng = engine.write();
+                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
+                                            focus.set(FocusZone::Hand);
+                                            sel_hand.set(idx - 1);
+                                        },
+                                        on_move_right: move |idx| {
+                                            let len = engine.read().state.hand.len();
+                                            if idx + 1 >= len { return; }
+                                            let mut eng = engine.write();
+                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
+                                            focus.set(FocusZone::Hand);
+                                            sel_hand.set(idx + 1);
+                                        },
+                                        on_docs: move |id| {
+                                            kardinomicon_target.set(Some(id));
+                                            kardinomicon_open.set(true);
+                                        },
+                                    }
+                                }
+                            }
+                        }
                     }
                 }
             }
         }
*** End Patch
```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Deck,
    Hand,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div { class: "row-scroll",
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div { class: "row-scroll",
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 32px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
  min-height: 0;
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
  position: sticky;
  bottom: 14px;
  z-index: 8;
  backdrop-filter: blur(12px);
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: auto;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row-scroll::-webkit-scrollbar {
  height: 8px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
use dioxus::prelude::*;

#[component]
pub fn CardView(
    index: usize,
    card: kardinality::game::CardInstance,
    selected: bool,
    primary_icon: &'static str,
    on_select: EventHandler<usize>,
    on_primary: EventHandler<usize>,
    on_move_left: EventHandler<usize>,
    on_move_right: EventHandler<usize>,
    on_docs: EventHandler<String>,
    on_drag_start: EventHandler<usize>,
    on_drag_end: EventHandler<()>,
    on_drop: EventHandler<usize>,
) -> Element {
    let badge = format!("#{index}");

    let def_id = card.def_id.clone();
    let (name, script, budget, icon, doc_hint) = card
        .def()
        .map(|d| (d.name, d.script, d.budget, d.icon, d.kind))
        .map(|(name, script, budget, icon, kind)| (name, script, budget, icon, format!("{kind:?}")))
        .unwrap_or(("Missing Card", "/* missing */", 0, "?", "Missing".to_string()));

    let script_spans: Vec<(String, &'static str)> = match kardinality::kardlang::lex(script) {
        Ok(tokens) => tokens
            .into_iter()
            .filter(|t| !matches!(t.kind, kardinality::kardlang::TokenKind::Eof))
            .map(|t| {
                let text = script
                    .get(t.span.start..t.span.end)
                    .unwrap_or("")
                    .to_string();
                let class = match t.kind {
                    kardinality::kardlang::TokenKind::Ident(_) => "ident",
                    kardinality::kardlang::TokenKind::NumUnary(_) => "num",
                    kardinality::kardlang::TokenKind::NumDigit(_) => "num",
                    kardinality::kardlang::TokenKind::Plus => "op",
                    kardinality::kardlang::TokenKind::Star => "op",
                    kardinality::kardlang::TokenKind::LParen => "punct",
                    kardinality::kardlang::TokenKind::RParen => "punct",
                    kardinality::kardlang::TokenKind::Comma => "punct",
                    kardinality::kardlang::TokenKind::Semi => "punct",
                    kardinality::kardlang::TokenKind::Eof => "punct",
                };
                (text, class)
            })
            .collect(),
        Err(_) => vec![(script.to_string(), "raw")],
    };

    let class = if selected { "card selected" } else { "card" };

    rsx! {
        div {
            class: "{class}",
            onclick: move |_| on_select.call(index),
            draggable: "true",
            ondragstart: move |_| on_drag_start.call(index),
            ondragend: move |_| on_drag_end.call(()),
            ondragover: move |evt| evt.prevent_default(),
            ondrop: move |evt| {
                evt.prevent_default();
                on_drop.call(index);
            },
            div { class: "card-badge", "{badge}" }
            div { class: "card-art" }
            div { class: "card-body",
                h3 { class: "card-title", "{icon} {name}" }
                div { class: "card-sub", "{doc_hint} • Budget: {budget}" }
                div { class: "card-script",
                    for (text, cls) in script_spans {
                        span { class: "tok tok-{cls}", "{text}" }
                    }
                }
            }

            div { class: "card-actions",
                button {
                    class: "card-btn",
                    title: "Docs",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_docs.call(def_id.clone());
                    },
                    "📖"
                }
                button {
                    class: "card-btn",
                    title: "Move",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_primary.call(index);
                    },
                    "{primary_icon}"
                }
                button {
                    class: "card-btn",
                    title: "Move left",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_left.call(index);
                    },
                    "←"
                }
                button {
                    class: "card-btn",
                    title: "Move right",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_right.call(index);
                    },
                    "→"
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div { class: "row-scroll",
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div { class: "row-scroll",
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div {
                                class: "row-scroll",
                                ondragover: move |evt| evt.prevent_default(),
                                ondrop: move |evt| {
                                    evt.prevent_default();
                                    if let Some(payload) = drag() {
                                        let mut eng = engine.write();
                                        match payload.zone {
                                            FocusZone::Deck => {
                                                let len = eng.state.collection.len();
                                                if len > 0 {
                                                    let to = len - 1;
                                                    let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                    focus.set(FocusZone::Deck);
                                                    sel_collection.set(to);
                                                }
                                            }
                                            FocusZone::Hand => {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                        }
                                    }
                                    drag.set(None);
                                },
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                            on_drag_start: move |idx| {
                                                drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx);
                                            },
                                            on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                                if let Some(payload) = drag() {
                                                    let mut eng = engine.write();
                                                    match payload.zone {
                                                        FocusZone::Deck => {
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(drop_idx);
                                                        }
                                                        FocusZone::Hand => {
                                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                            }
                                                            let from = eng.state.collection.len().saturating_sub(1);
                                                            let to = drop_idx.min(from);
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(to);
                                                        }
                                                    }
                                                }
                                                drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div { class: "row-scroll",
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar { engine, tab, settings, kardinomicon_open, kardinomicon_target }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div {
                                class: "row-scroll",
                                ondragover: move |evt| evt.prevent_default(),
                                ondrop: move |evt| {
                                    evt.prevent_default();
                                    if let Some(payload) = drag() {
                                        let mut eng = engine.write();
                                        match payload.zone {
                                            FocusZone::Deck => {
                                                let len = eng.state.collection.len();
                                                if len > 0 {
                                                    let to = len - 1;
                                                    let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                    focus.set(FocusZone::Deck);
                                                    sel_collection.set(to);
                                                }
                                            }
                                            FocusZone::Hand => {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                        }
                                    }
                                    drag.set(None);
                                },
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                            on_drag_start: move |idx| {
                                                drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx);
                                            },
                                            on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                                if let Some(payload) = drag() {
                                                    let mut eng = engine.write();
                                                    match payload.zone {
                                                        FocusZone::Deck => {
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(drop_idx);
                                                        }
                                                        FocusZone::Hand => {
                                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                            }
                                                            let from = eng.state.collection.len().saturating_sub(1);
                                                            let to = drop_idx.min(from);
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(to);
                                                        }
                                                    }
                                                }
                                                drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.10) saturate(1.18);
  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.26;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.045),
      rgba(255, 255, 255, 0.045) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.020),
      rgba(255, 0, 0, 0.020) 1px,
      rgba(0, 255, 0, 0.018) 2px,
      rgba(0, 0, 255, 0.020) 3px
    );
  animation: scanlines 7.2s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.94;
  animation: flicker 2.6s infinite steps(60);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 32px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
  min-height: 0;
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
  position: sticky;
  bottom: 14px;
  z-index: 8;
  backdrop-filter: blur(12px);
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: auto;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row-scroll::-webkit-scrollbar {
  height: 8px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Effect {
    AddScore(i64),
    AddBankroll(i64),
    MulBankroll(i64),
    Draw(i64),
}



```

```rust
use thiserror::Error;

use crate::kardlang::{BinOp, Call, Expr};

use super::{Effect, Limits};

pub trait VmContext {
    fn get(&self, name: &str) -> Option<i64>;
}

#[derive(Debug, Clone, PartialEq, Eq, Error)]
pub enum VmError {
    #[error("unknown function: {0}")]
    UnknownFunction(String),

    #[error("unknown register: {0}")]
    UnknownRegister(String),

    #[error("wrong arity for {name}: expected {expected}, got {got}")]
    WrongArity {
        name: String,
        expected: usize,
        got: usize,
    },

    #[error("integer overflow")]
    Overflow,

    #[error("execution aborted: exceeded max steps ({max_steps})")]
    StepLimitExceeded { max_steps: usize },
}

#[derive(Debug, Clone)]
pub struct Machine {
    steps: usize,
    limits: Limits,
}

impl Machine {
    pub fn new(limits: Limits) -> Self {
        Self { steps: 0, limits }
    }

    pub fn eval_call<C: VmContext>(&mut self, call: &Call, ctx: &C) -> Result<Vec<Effect>, VmError> {
        self.steps += 1;
        if self.steps > self.limits.max_steps {
            return Err(VmError::StepLimitExceeded {
                max_steps: self.limits.max_steps,
            });
        }

        match call.name.as_str() {
            "score" => {
                let n = expect_one_int(call, ctx)?;
                Ok(vec![Effect::AddScore(n)])
            }
            "bank" => {
                let n = expect_one_int(call, ctx)?;
                Ok(vec![Effect::AddBankroll(n)])
            }
            "dbl" => {
                expect_arity(call, 0)?;
                Ok(vec![Effect::MulBankroll(2)])
            }
            "draw" => {
                let n = expect_one_int(call, ctx)?;
                Ok(vec![Effect::Draw(n)])
            }
            other => Err(VmError::UnknownFunction(other.to_string())),
        }
    }
}

fn expect_arity(call: &Call, expected: usize) -> Result<(), VmError> {
    let got = call.args.len();
    if got != expected {
        return Err(VmError::WrongArity {
            name: call.name.clone(),
            expected,
            got,
        });
    }
    Ok(())
}

fn expect_one_int<C: VmContext>(call: &Call, ctx: &C) -> Result<i64, VmError> {
    expect_arity(call, 1)?;
    eval_expr(&call.args[0], ctx)
}

fn eval_expr<C: VmContext>(expr: &Expr, ctx: &C) -> Result<i64, VmError> {
    match expr {
        Expr::Int(n, _) => Ok(*n),
        Expr::Var(name, _) => ctx
            .get(name)
            .ok_or_else(|| VmError::UnknownRegister(name.clone())),
        Expr::Group(inner, _) => eval_expr(inner, ctx),
        Expr::Binary { op, lhs, rhs, .. } => {
            let a = eval_expr(lhs, ctx)?;
            let b = eval_expr(rhs, ctx)?;
            match op {
                BinOp::Add => a.checked_add(b).ok_or(VmError::Overflow),
                BinOp::Mul => a.checked_mul(b).ok_or(VmError::Overflow),
            }
        }
    }
}



```

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmContext, VmError};

use crate::game::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        let deck = cards::starter_deck_ids()
            .iter()
            .map(|id| CardInstance::new(*id))
            .collect();
        Self::with_deck(seed, deck, Limits::default())
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let hand = std::mem::take(&mut self.state.hand);
        for (index, card) in hand.into_iter().enumerate() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            for call in &program.calls {
                let args = call.args.iter().map(expr_to_string).collect::<Vec<_>>();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let ctx = GameCtx { state: &self.state };
                let effects = vm.eval_call(call, &ctx)?;
                self.apply_effects(effects);
            }

            self.state.discard.push(card);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
                Effect::Draw(n) => {
                    let count: usize = (*n).clamp(0, 25) as usize;
                    if let Err(e) = self.draw_to_collection(count) {
                        self.state.trace.push(TraceEvent::Error(e.to_string()));
                    }
                }
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || to >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    v.insert(to, item);
}

struct GameCtx<'a> {
    state: &'a GameState,
}

impl VmContext for GameCtx<'_> {
    fn get(&self, name: &str) -> Option<i64> {
        match name {
            "len_deck" => Some(self.state.deck.len() as i64),
            "len_pool" | "len_collection" => Some(self.state.collection.len() as i64),
            "len_hand" => Some(self.state.hand.len() as i64),
            "len_discard" => Some(self.state.discard.len() as i64),
            "score" => Some(self.state.score),
            "bankroll" => Some(self.state.bankroll),
            "level" => Some(self.state.level as i64),
            "target" => Some(self.state.target_score),
            "max_step" | "max_steps" => Some(self.state.limits.max_steps as i64),
            "max_loop" | "max_loop_iters" => Some(self.state.limits.max_loop_iters as i64),
            _ => None,
        }
    }
}

fn expr_to_string(expr: &crate::kardlang::Expr) -> String {
    use crate::kardlang::{BinOp, Expr};
    match expr {
        Expr::Int(n, _) => n.to_string(),
        Expr::Var(name, _) => name.clone(),
        Expr::Group(inner, _) => format!("({})", expr_to_string(inner)),
        Expr::Binary { op, lhs, rhs, .. } => {
            let op_str = match op {
                BinOp::Add => "+",
                BinOp::Mul => "*",
            };
            format!("{}{}{}", expr_to_string(lhs), op_str, expr_to_string(rhs))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![CardInstance::new("score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}



```

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CardKind {
    Economy,
    Score,
    Control,
    Meta,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CardDef {
    pub id: &'static str,
    pub name: &'static str,
    pub kind: CardKind,
    pub budget: usize,
    pub script: &'static str,
    pub icon: &'static str,
    pub doc: &'static str,
}

pub fn catalog() -> &'static [CardDef] {
    &CATALOG
}

pub fn get(id: &str) -> Option<&'static CardDef> {
    CATALOG.iter().find(|c| c.id == id)
}

pub fn starter_deck_ids() -> &'static [&'static str] {
    &["draw_5", "score_4", "bank_6"]
}

static CATALOG: [CardDef; 8] = [
    CardDef {
        id: "draw_5",
        name: "Draw 5",
        kind: CardKind::Control,
        budget: 12,
        script: "draw(5)",
        icon: "⇣",
        doc: r#"
Generates new cards.

* **Effect**: `draw(n)` adds `n` new cards into your Deck (up to availability).
* **Default script**: `draw(5)`
* **Notes**: This is your primary way to expand options early.
"#,
    },
    CardDef {
        id: "score_4",
        name: "Score +4",
        kind: CardKind::Score,
        budget: 12,
        script: "score(4)",
        icon: "▲",
        doc: r#"
Adds to your score.

* **Effect**: `score(n)` increases `score` by `n`.
* **Default script**: `score(4)`
"#,
    },
    CardDef {
        id: "bank_6",
        name: "Bank +6",
        kind: CardKind::Economy,
        budget: 13,
        script: "bank(6)",
        icon: "$",
        doc: r#"
Adds to your bankroll.

* **Effect**: `bank(n)` increases `bankroll` by `n`.
* **Default script**: `bank(6)`
"#,
    },
    CardDef {
        id: "score_2",
        name: "Score +2",
        kind: CardKind::Score,
        budget: 12,
        script: "score(11)",
        icon: "▲",
        doc: r#"
Adds to your score.

* **Effect**: `score(n)` increases `score` by `n`.
* **Default script**: `score(11)` (unary 2)
* **Notes**: Score is compared against `target` to clear the level.
"#,
    },
    CardDef {
        id: "score_len_deck",
        name: "Score +len_deck",
        kind: CardKind::Score,
        budget: 24,
        script: "score(len_deck)",
        icon: "Σ",
        doc: r#"
Adds the current deck size to your score.

* **Effect**: `score(len_deck)` increases `score` by `len_deck`.
* **Register**: `len_deck` is the number of cards in the draw pile.
"#,
    },
    CardDef {
        id: "bank_3",
        name: "Bank +3",
        kind: CardKind::Economy,
        budget: 12,
        script: "bank(111)",
        icon: "$",
        doc: r#"
Adds to your bankroll.

* **Effect**: `bank(n)` increases `bankroll` by `n`.
* **Default script**: `bank(111)` (unary 3)
"#,
    },
    CardDef {
        id: "bank_len_pool",
        name: "Bank +len_pool",
        kind: CardKind::Economy,
        budget: 24,
        script: "bank(len_pool)",
        icon: "$",
        doc: r#"
Adds the current collection size to your bankroll.

* **Effect**: `bank(len_pool)` increases `bankroll` by `len_pool`.
* **Register**: `len_pool` is the number of cards currently in your collection.
"#,
    },
    CardDef {
        id: "dbl_bank",
        name: "Double Bank",
        kind: CardKind::Economy,
        budget: 12,
        script: "dbl()",
        icon: "×2",
        doc: r#"
Doubles your bankroll.

* **Effect**: `dbl()` multiplies `bankroll` by 2.
* **Default script**: `dbl()`
"#,
    },
];



```

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmContext, VmError};

use crate::game::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        // Draw pile ("source") is a shuffled pool of all known cards (with repeats).
        let mut draw_pile: Vec<CardInstance> = Vec::new();
        for _ in 0..4 {
            for def in cards::catalog() {
                draw_pile.push(CardInstance::new(def.id));
            }
        }

        let mut engine = Self::with_deck(seed, draw_pile, Limits::default());

        // Player starts with a small starter deck.
        engine.state.collection = cards::starter_deck_ids()
            .iter()
            .map(|id| CardInstance::new(*id))
            .collect();

        engine
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let hand = std::mem::take(&mut self.state.hand);
        for (index, card) in hand.into_iter().enumerate() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            for call in &program.calls {
                let args = call.args.iter().map(expr_to_string).collect::<Vec<_>>();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let ctx = GameCtx { state: &self.state };
                let effects = vm.eval_call(call, &ctx)?;
                self.apply_effects(effects);
            }

            self.state.discard.push(card);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
                Effect::Draw(n) => {
                    let count: usize = (*n).clamp(0, 25) as usize;
                    if let Err(e) = self.draw_to_collection(count) {
                        self.state.trace.push(TraceEvent::Error(e.to_string()));
                    }
                }
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || to >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    v.insert(to, item);
}

struct GameCtx<'a> {
    state: &'a GameState,
}

impl VmContext for GameCtx<'_> {
    fn get(&self, name: &str) -> Option<i64> {
        match name {
            "len_deck" => Some(self.state.deck.len() as i64),
            "len_pool" | "len_collection" => Some(self.state.collection.len() as i64),
            "len_hand" => Some(self.state.hand.len() as i64),
            "len_discard" => Some(self.state.discard.len() as i64),
            "score" => Some(self.state.score),
            "bankroll" => Some(self.state.bankroll),
            "level" => Some(self.state.level as i64),
            "target" => Some(self.state.target_score),
            "max_step" | "max_steps" => Some(self.state.limits.max_steps as i64),
            "max_loop" | "max_loop_iters" => Some(self.state.limits.max_loop_iters as i64),
            _ => None,
        }
    }
}

fn expr_to_string(expr: &crate::kardlang::Expr) -> String {
    use crate::kardlang::{BinOp, Expr};
    match expr {
        Expr::Int(n, _) => n.to_string(),
        Expr::Var(name, _) => name.clone(),
        Expr::Group(inner, _) => format!("({})", expr_to_string(inner)),
        Expr::Binary { op, lhs, rhs, .. } => {
            let op_str = match op {
                BinOp::Add => "+",
                BinOp::Mul => "*",
            };
            format!("{}{}{}", expr_to_string(lhs), op_str, expr_to_string(rhs))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![CardInstance::new("score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
) -> Element {
    let tab_value = tab();
    let cur_settings = settings();

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "New run (seed 0)"
                    }
                    button {
                        class: "btn secondary",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Generate 5 → Deck"
                    }
                    button {
                        class: "btn",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Execute hand"
                    }
                    button {
                        class: "btn danger",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::ClearTrace) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Clear trace"
                    }
                    button {
                        class: "btn secondary",
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                        "Open Kardinomicon"
                    }
                }

                div { class: "panel sidebar-panel",
                    h3 { "Telemetry" }
                    div { class: "kv", span { "Deck" } code { "{state.deck.len()}" } }
                    div { class: "kv", span { "Collection" } code { "{state.collection.len()}" } }
                    div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
                    div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
                    div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
                    div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
                    div { class: "hint",
                        "Tip: the trace panel is also core UX. Keep it readable and useful."
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Assemble a hand and execute." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur_settings.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur_settings.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur_settings.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn KardinomiconModal(
    open: bool,
    target: Option<String>,
    on_close: EventHandler<()>,
) -> Element {
    let catalog = kardinality::game::cards::catalog();

    // If a target is provided, show it first.
    let mut ordered: Vec<kardinality::game::cards::CardDef> = Vec::with_capacity(catalog.len());
    if let Some(t) = target.as_deref() {
        if let Some(found) = catalog.iter().find(|c| c.id == t) {
            ordered.push(*found);
        }
    }
    for c in catalog {
        if ordered.first().is_some_and(|first| first.id == c.id) {
            continue;
        }
        ordered.push(*c);
    }

    rsx! {
        if open {
            div {
                class: "modal-overlay",
                onclick: move |_| on_close.call(()),

                div {
                    class: "modal panel",
                    onclick: move |evt| evt.stop_propagation(),

                    div { class: "modal-header",
                        div { class: "modal-title",
                            span { class: "modal-glyph", "⟡" }
                            span { "Kardinomicon" }
                        }
                        button { class: "btn danger", onclick: move |_| on_close.call(()), "Close" }
                    }

                    div { class: "modal-body",
                        h2 { class: "hud-title", "Language" }
                        div { class: "kdoc",
                            "Kardlang is a tiny integer-only language designed for card execution budgets."
                            br {}
                            "Numbers are unary (\"111\" = 3) or digit shorthand (\"4\" = 4 but costs 4)."
                            br {}
                            "Values support identifiers (registers) and + / * expressions."
                            br {}
                            "Registers: len_deck, len_pool, len_hand, len_discard, score, bankroll, level, target, max_steps, max_loop."
                        }
                        pre { class: "kcard-doc", "{kardinality::kardlang::GRAMMAR.trim()}" }

                        h2 { class: "hud-title", "Functions" }
                        div { class: "kdoc",
                            "draw(n)   → generate n new cards into your Deck"
                            br {}
                            "score(n)  → add n to score"
                            br {}
                            "bank(n)   → add n to bankroll"
                            br {}
                            "dbl()     → bankroll *= 2"
                        }

                        h2 { class: "hud-title", "Cards" }
                        div { class: "kcard-list",
                            for c in ordered {
                                KardinomiconCard {
                                    card: c,
                                    highlight: target.as_deref().is_some_and(|t| t == c.id),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn KardinomiconCard(card: kardinality::game::cards::CardDef, highlight: bool) -> Element {
    let class = if highlight { "kcard highlight" } else { "kcard" };
    rsx! {
        div { class: "{class}",
            div { class: "kcard-head",
                span { class: "kcard-icon", "{card.icon}" }
                div { class: "kcard-title",
                    div { class: "kcard-name", "{card.name}" }
                    div { class: "kcard-id", "{card.id}" }
                }
                div { class: "kcard-script", "{card.script}" }
            }
            pre { class: "kcard-doc", "{card.doc.trim()}" }
        }
    }
}



```

```markdown
## Kardlang

Kardlang is the tiny “cards-as-code” language inside **Kardinality**. It’s designed for a gamejam reality: **simple to read**, **cheap to parse**, and **easy to balance**.

### Philosophy

* **Character budgets are the balance lever**: every card has a strict budget. If you want more power, you spend more characters.
* **Big constants are intentionally expensive**: digits cost their numeric value, so typing `9` is “9 chars worth of power”. Unary numbers (`111`) are always available but still cost length.
* **Arithmetic is minimal**: only `+` and `*` exist inside expressions. No subtraction, division, exponentiation, or function composition.
* **No nested calls (for now)**: you can’t write `score(sqr(len_hand))`. A call’s arguments are **expressions**, not other calls.
* **Everything is an integer**: makes the VM deterministic, fast, and easier to reason about.

### The “effective length” cost model

Kardlang budgets are enforced using an **effective length**, not raw character count:

* Normal characters cost **1**
* Digit characters cost **their value**
  * `0` costs **1**
  * `4` costs **4**
  * `9` costs **9**

This prevents “type 999999” strategies and pushes players toward **state-derived values** and **sequencing** instead of raw constants.

### Core syntax (v0)

* Programs are a sequence of calls:

```text
score(4)
bank(6)
dbl()
```

* Calls can be separated by whitespace and/or `;`.
* Arguments are integer expressions using:
  * **numbers** (unary `111` or digit shorthand `4`)
  * **register identifiers** (e.g. `len_deck`)
  * **operators** `+` and `*`
  * **parentheses** for grouping

### Grammar

The codebase ships a canonical grammar string in `src/kardlang/grammar.rs`. (The Kardinomicon shows it in-game.)

### Registers

Registers are named reads of game state. They are intentionally verbose (referencing state costs characters).

Current registers include:

* `len_deck` / `len_pool` / `len_collection`
* `len_hand`
* `len_discard`
* `score`
* `bankroll`
* `level`
* `target`
* `max_steps` / `max_step`
* `max_loop_iters` / `max_loop`

### Functions

These are the “opcodes” of Kardlang. A card is basically a (budgeted) program made of these calls.

* `draw(n)`: generate/draw `n` new cards into your Deck (bounded in the engine)
* `score(n)`: add `n` to score
* `bank(n)`: add `n` to bankroll
* `dbl()`: multiply bankroll by 2

### Safety limits

Execution is always bounded:

* `max_steps`: caps how many calls can be evaluated in one execution
* `max_loop_iters`: reserved for future control-flow cards

If a limit is exceeded, execution aborts cleanly and the UI shows it in the trace/debug panel.


```

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmContext, VmError};

use crate::game::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        // Draw pile ("source") is a shuffled pool of all known cards (with repeats).
        let mut draw_pile: Vec<CardInstance> = Vec::new();
        for _ in 0..4 {
            for def in cards::catalog() {
                draw_pile.push(CardInstance::new(def.id));
            }
        }

        let mut engine = Self::with_deck(seed, draw_pile, Limits::default());

        // Player starts with a small starter deck.
        engine.state.collection = cards::starter_deck_ids()
            .iter()
            .map(|id| CardInstance::new(*id))
            .collect();

        engine
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let hand = std::mem::take(&mut self.state.hand);
        for (index, card) in hand.into_iter().enumerate() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            for call in &program.calls {
                let args = call.args.iter().map(expr_to_string).collect::<Vec<_>>();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let ctx = GameCtx { state: &self.state };
                let effects = vm.eval_call(call, &ctx)?;
                self.apply_effects(effects);
            }

            // After execution, cards return to the player's deck (selection pool).
            self.state.collection.push(card);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
                Effect::Draw(n) => {
                    let count: usize = (*n).clamp(0, 25) as usize;
                    if let Err(e) = self.draw_to_collection(count) {
                        self.state.trace.push(TraceEvent::Error(e.to_string()));
                    }
                }
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || to >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    v.insert(to, item);
}

struct GameCtx<'a> {
    state: &'a GameState,
}

impl VmContext for GameCtx<'_> {
    fn get(&self, name: &str) -> Option<i64> {
        match name {
            "len_deck" => Some(self.state.deck.len() as i64),
            "len_pool" | "len_collection" => Some(self.state.collection.len() as i64),
            "len_hand" => Some(self.state.hand.len() as i64),
            "len_discard" => Some(self.state.discard.len() as i64),
            "score" => Some(self.state.score),
            "bankroll" => Some(self.state.bankroll),
            "level" => Some(self.state.level as i64),
            "target" => Some(self.state.target_score),
            "max_step" | "max_steps" => Some(self.state.limits.max_steps as i64),
            "max_loop" | "max_loop_iters" => Some(self.state.limits.max_loop_iters as i64),
            _ => None,
        }
    }
}

fn expr_to_string(expr: &crate::kardlang::Expr) -> String {
    use crate::kardlang::{BinOp, Expr};
    match expr {
        Expr::Int(n, _) => n.to_string(),
        Expr::Var(name, _) => name.clone(),
        Expr::Group(inner, _) => format!("({})", expr_to_string(inner)),
        Expr::Binary { op, lhs, rhs, .. } => {
            let op_str = match op {
                BinOp::Add => "+",
                BinOp::Mul => "*",
            };
            format!("{}{}{}", expr_to_string(lhs), op_str, expr_to_string(rhs))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_moves_cards_to_discard() {
        let deck = vec![CardInstance::new("score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.discard.len(), 1);
    }
}



```

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmContext, VmError};

use crate::game::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        // Draw pile ("source") is a shuffled pool of all known cards (with repeats).
        let mut draw_pile: Vec<CardInstance> = Vec::new();
        for _ in 0..4 {
            for def in cards::catalog() {
                draw_pile.push(CardInstance::new(def.id));
            }
        }

        let mut engine = Self::with_deck(seed, draw_pile, Limits::default());

        // Player starts with a small starter deck.
        engine.state.collection = cards::starter_deck_ids()
            .iter()
            .map(|id| CardInstance::new(*id))
            .collect();

        engine
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let hand = std::mem::take(&mut self.state.hand);
        for (index, card) in hand.into_iter().enumerate() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            for call in &program.calls {
                let args = call.args.iter().map(expr_to_string).collect::<Vec<_>>();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let ctx = GameCtx { state: &self.state };
                let effects = vm.eval_call(call, &ctx)?;
                self.apply_effects(effects);
            }

            // After execution, cards return to the player's deck (selection pool).
            self.state.collection.push(card);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
                Effect::Draw(n) => {
                    let count: usize = (*n).clamp(0, 25) as usize;
                    if let Err(e) = self.draw_to_collection(count) {
                        self.state.trace.push(TraceEvent::Error(e.to_string()));
                    }
                }
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || to >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    v.insert(to, item);
}

struct GameCtx<'a> {
    state: &'a GameState,
}

impl VmContext for GameCtx<'_> {
    fn get(&self, name: &str) -> Option<i64> {
        match name {
            "len_deck" => Some(self.state.deck.len() as i64),
            "len_pool" | "len_collection" => Some(self.state.collection.len() as i64),
            "len_hand" => Some(self.state.hand.len() as i64),
            "len_discard" => Some(self.state.discard.len() as i64),
            "score" => Some(self.state.score),
            "bankroll" => Some(self.state.bankroll),
            "level" => Some(self.state.level as i64),
            "target" => Some(self.state.target_score),
            "max_step" | "max_steps" => Some(self.state.limits.max_steps as i64),
            "max_loop" | "max_loop_iters" => Some(self.state.limits.max_loop_iters as i64),
            _ => None,
        }
    }
}

fn expr_to_string(expr: &crate::kardlang::Expr) -> String {
    use crate::kardlang::{BinOp, Expr};
    match expr {
        Expr::Int(n, _) => n.to_string(),
        Expr::Var(name, _) => name.clone(),
        Expr::Group(inner, _) => format!("({})", expr_to_string(inner)),
        Expr::Binary { op, lhs, rhs, .. } => {
            let op_str = match op {
                BinOp::Add => "+",
                BinOp::Mul => "*",
            };
            format!("{}{}{}", expr_to_string(lhs), op_str, expr_to_string(rhs))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_returns_cards_to_deck() {
        let deck = vec![CardInstance::new("score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);
    }
}



```

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmContext, VmError};

use crate::game::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        // Draw pile ("source") is a shuffled pool of all known cards (with repeats).
        let mut draw_pile: Vec<CardInstance> = Vec::new();
        for _ in 0..4 {
            for def in cards::catalog() {
                draw_pile.push(CardInstance::new(def.id));
            }
        }

        let mut engine = Self::with_deck(seed, draw_pile, Limits::default());

        // Player starts with a small starter deck.
        engine.state.collection = cards::starter_deck_ids()
            .iter()
            .map(|id| CardInstance::new(*id))
            .collect();

        engine
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        Self {
            state: GameState::new(deck, limits),
            rng,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let hand = std::mem::take(&mut self.state.hand);
        for (index, card) in hand.into_iter().enumerate() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            for call in &program.calls {
                let args = call.args.iter().map(expr_to_string).collect::<Vec<_>>();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let ctx = GameCtx { state: &self.state };
                let effects = vm.eval_call(call, &ctx)?;
                self.apply_effects(effects);
            }

            // After execution, cards return to the player's deck (selection pool).
            self.state.collection.push(card);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effects(&mut self, effects: Vec<Effect>) {
        for effect in effects {
            match &effect {
                Effect::AddScore(n) => self.state.score += *n,
                Effect::AddBankroll(n) => self.state.bankroll += *n,
                Effect::MulBankroll(n) => self.state.bankroll *= *n,
                Effect::Draw(n) => {
                    let count: usize = (*n).clamp(0, 25) as usize;
                    if let Err(e) = self.draw_to_collection(count) {
                        self.state.trace.push(TraceEvent::Error(e.to_string()));
                    }
                }
            }

            self.state
                .trace
                .push(TraceEvent::EffectApplied { effect });
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || to >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    v.insert(to, item);
}

struct GameCtx<'a> {
    state: &'a GameState,
}

impl VmContext for GameCtx<'_> {
    fn get(&self, name: &str) -> Option<i64> {
        match name {
            // Terminology:
            // - "deck" is the player's owned deck (selection pool)
            // - "source" is the generator/draw pile we pull new cards from
            "len_deck" | "len_pool" | "len_collection" => Some(self.state.collection.len() as i64),
            "len_source" | "len_draw" => Some(self.state.deck.len() as i64),
            "len_hand" => Some(self.state.hand.len() as i64),
            "len_discard" => Some(self.state.discard.len() as i64),
            "score" => Some(self.state.score),
            "bankroll" => Some(self.state.bankroll),
            "level" => Some(self.state.level as i64),
            "target" => Some(self.state.target_score),
            "max_step" | "max_steps" => Some(self.state.limits.max_steps as i64),
            "max_loop" | "max_loop_iters" => Some(self.state.limits.max_loop_iters as i64),
            _ => None,
        }
    }
}

fn expr_to_string(expr: &crate::kardlang::Expr) -> String {
    use crate::kardlang::{BinOp, Expr};
    match expr {
        Expr::Int(n, _) => n.to_string(),
        Expr::Var(name, _) => name.clone(),
        Expr::Group(inner, _) => format!("({})", expr_to_string(inner)),
        Expr::Binary { op, lhs, rhs, .. } => {
            let op_str = match op {
                BinOp::Add => "+",
                BinOp::Mul => "*",
            };
            format!("{}{}{}", expr_to_string(lhs), op_str, expr_to_string(rhs))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_returns_cards_to_deck() {
        let deck = vec![CardInstance::new("score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);
    }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn TopHud(
    bankroll: i64,
    score: i64,
    target: i64,
    deck_count: usize,
    collection_count: usize,
    hand_count: usize,
    discard_count: usize,
    trace_count: usize,
    max_steps: usize,
    max_loop_iters: usize,
) -> Element {
    let pct = if target <= 0 {
        0.0
    } else {
        (score as f64 / target as f64).clamp(0.0, 1.25)
    };
    let pct100 = (pct * 100.0).clamp(0.0, 125.0);
    let fill_style = format!("width: {pct100:.2}%");

    let stage = if pct < 0.33 {
        "low"
    } else if pct < 0.66 {
        "mid"
    } else if pct < 1.0 {
        "high"
    } else {
        "clear"
    };

    rsx! {
        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Score" }

            div { class: "scoreline",
                div { class: "scorebig", "{score}" }
                div { class: "scoremeta",
                    div { class: "hint", "Target" }
                    div { class: "scoretarget", "{target}" }
                }
            }

            div { class: "progress",
                div { class: "progress-fill {stage}", style: "{fill_style}" }
            }

            div { class: "bankline",
                div { class: "hint", "Bankroll" }
                div { class: "bankbig", "${bankroll}" }
            }
        }

        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Registers" }
            div { class: "kv", span { "len_source" } code { "{deck_count}" } }
            div { class: "kv", span { "len_deck" } code { "{collection_count}" } }
            div { class: "kv", span { "len_hand" } code { "{hand_count}" } }
            div { class: "kv", span { "len_discard" } code { "{discard_count}" } }
            div { class: "kv", span { "max_steps" } code { "{max_steps}" } }
            div { class: "kv", span { "max_loop" } code { "{max_loop_iters}" } }
            div { class: "kv", span { "trace_len" } code { "{trace_count}" } }
        }
    }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn DeckWidget(
    deck_count: usize,
    discard_count: usize,
    collection_count: usize,
    hand_count: usize,
    level: u32,
    target: i64,
) -> Element {
    rsx! {
        div { class: "panel deck-widget",
            h2 { class: "deck-title", "Source // Level {level}" }

            div { class: "deck-stack",
                div { class: "deck-card" }
                div { class: "deck-card" }
                div { class: "deck-card" }
            }

            div { class: "deck-meta",
                div { class: "pill", span { "Source" } strong { "{deck_count}" } }
                div { class: "pill", span { "Discard" } strong { "{discard_count}" } }
                div { class: "pill", span { "Deck" } strong { "{collection_count}" } }
                div { class: "pill", span { "Hand" } strong { "{hand_count}" } }
                div { class: "pill", span { "Target" } strong { "{target}" } }
                div { class: "pill", span { "RNG" } strong { "seeded" } }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

#[component]
pub fn KardinomiconModal(
    open: bool,
    target: Option<String>,
    on_close: EventHandler<()>,
) -> Element {
    let catalog = kardinality::game::cards::catalog();

    // If a target is provided, show it first.
    let mut ordered: Vec<kardinality::game::cards::CardDef> = Vec::with_capacity(catalog.len());
    if let Some(t) = target.as_deref() {
        if let Some(found) = catalog.iter().find(|c| c.id == t) {
            ordered.push(*found);
        }
    }
    for c in catalog {
        if ordered.first().is_some_and(|first| first.id == c.id) {
            continue;
        }
        ordered.push(*c);
    }

    rsx! {
        if open {
            div {
                class: "modal-overlay",
                onclick: move |_| on_close.call(()),

                div {
                    class: "modal panel",
                    onclick: move |evt| evt.stop_propagation(),

                    div { class: "modal-header",
                        div { class: "modal-title",
                            span { class: "modal-glyph", "⟡" }
                            span { "Kardinomicon" }
                        }
                        button { class: "btn danger", onclick: move |_| on_close.call(()), "Close" }
                    }

                    div { class: "modal-body",
                        h2 { class: "hud-title", "Language" }
                        div { class: "kdoc",
                            "Kardlang is a tiny integer-only language designed for card execution budgets."
                            br {}
                            "Numbers are unary (\"111\" = 3) or digit shorthand (\"4\" = 4 but costs 4)."
                            br {}
                            "Values support identifiers (registers) and + / * expressions."
                            br {}
                            "Registers: len_deck, len_hand, len_source, len_discard, score, bankroll, level, target, max_steps, max_loop."
                        }
                        pre { class: "kcard-doc", "{kardinality::kardlang::GRAMMAR.trim()}" }

                        h2 { class: "hud-title", "Functions" }
                        div { class: "kdoc",
                            "draw(n)   → generate n new cards into your Deck"
                            br {}
                            "score(n)  → add n to score"
                            br {}
                            "bank(n)   → add n to bankroll"
                            br {}
                            "dbl()     → bankroll *= 2"
                        }

                        h2 { class: "hud-title", "Cards" }
                        div { class: "kcard-list",
                            for c in ordered {
                                KardinomiconCard {
                                    card: c,
                                    highlight: target.as_deref().is_some_and(|t| t == c.id),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn KardinomiconCard(card: kardinality::game::cards::CardDef, highlight: bool) -> Element {
    let class = if highlight { "kcard highlight" } else { "kcard" };
    rsx! {
        div { class: "{class}",
            div { class: "kcard-head",
                span { class: "kcard-icon", "{card.icon}" }
                div { class: "kcard-title",
                    div { class: "kcard-name", "{card.name}" }
                    div { class: "kcard-id", "{card.id}" }
                }
                div { class: "kcard-script", "{card.script}" }
            }
            pre { class: "kcard-doc", "{card.doc.trim()}" }
        }
    }
}



```

```markdown
## Kardlang

Kardlang is the tiny “cards-as-code” language inside **Kardinality**. It’s designed for a gamejam reality: **simple to read**, **cheap to parse**, and **easy to balance**.

### Philosophy

* **Character budgets are the balance lever**: every card has a strict budget. If you want more power, you spend more characters.
* **Big constants are intentionally expensive**: digits cost their numeric value, so typing `9` is “9 chars worth of power”. Unary numbers (`111`) are always available but still cost length.
* **Arithmetic is minimal**: only `+` and `*` exist inside expressions. No subtraction, division, exponentiation, or function composition.
* **No nested calls (for now)**: you can’t write `score(sqr(len_hand))`. A call’s arguments are **expressions**, not other calls.
* **Everything is an integer**: makes the VM deterministic, fast, and easier to reason about.

### The “effective length” cost model

Kardlang budgets are enforced using an **effective length**, not raw character count:

* Normal characters cost **1**
* Digit characters cost **their value**
  * `0` costs **1**
  * `4` costs **4**
  * `9` costs **9**

This prevents “type 999999” strategies and pushes players toward **state-derived values** and **sequencing** instead of raw constants.

### Core syntax (v0)

* Programs are a sequence of calls:

```text
score(4)
bank(6)
dbl()
```

* Calls can be separated by whitespace and/or `;`.
* Arguments are integer expressions using:
  * **numbers** (unary `111` or digit shorthand `4`)
  * **register identifiers** (e.g. `len_deck`)
  * **operators** `+` and `*`
  * **parentheses** for grouping

### Grammar

The codebase ships a canonical grammar string in `src/kardlang/grammar.rs`. (The Kardinomicon shows it in-game.)

### Registers

Registers are named reads of game state. They are intentionally verbose (referencing state costs characters).

Current registers include:

* `len_deck` / `len_pool` / `len_collection`
* `len_hand`
* `len_source` / `len_draw`
* `len_discard`
* `score`
* `bankroll`
* `level`
* `target`
* `max_steps` / `max_step`
* `max_loop_iters` / `max_loop`

### Functions

These are the “opcodes” of Kardlang. A card is basically a (budgeted) program made of these calls.

* `draw(n)`: generate/draw `n` new cards into your Deck (bounded in the engine)
* `score(n)`: add `n` to score
* `bank(n)`: add `n` to bankroll
* `dbl()`: multiply bankroll by 2

### Safety limits

Execution is always bounded:

* `max_steps`: caps how many calls can be evaluated in one execution
* `max_loop_iters`: reserved for future control-flow cards

If a limit is exceeded, execution aborts cleanly and the UI shows it in the trace/debug panel.



```

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CardKind {
    Economy,
    Score,
    Control,
    Meta,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CardDef {
    pub id: &'static str,
    pub name: &'static str,
    pub kind: CardKind,
    pub budget: usize,
    pub script: &'static str,
    pub icon: &'static str,
    pub doc: &'static str,
}

pub fn catalog() -> &'static [CardDef] {
    &CATALOG
}

pub fn get(id: &str) -> Option<&'static CardDef> {
    CATALOG.iter().find(|c| c.id == id)
}

pub fn starter_deck_ids() -> &'static [&'static str] {
    &["draw_5", "score_4", "bank_6"]
}

static CATALOG: [CardDef; 8] = [
    CardDef {
        id: "draw_5",
        name: "Draw 5",
        kind: CardKind::Control,
        budget: 12,
        script: "draw(5)",
        icon: "⇣",
        doc: r#"
Generates new cards.

* **Effect**: `draw(n)` adds `n` new cards into your Deck (up to availability).
* **Default script**: `draw(5)`
* **Notes**: This is your primary way to expand options early.
"#,
    },
    CardDef {
        id: "score_4",
        name: "Score +4",
        kind: CardKind::Score,
        budget: 12,
        script: "score(4)",
        icon: "▲",
        doc: r#"
Adds to your score.

* **Effect**: `score(n)` increases `score` by `n`.
* **Default script**: `score(4)`
"#,
    },
    CardDef {
        id: "bank_6",
        name: "Bank +6",
        kind: CardKind::Economy,
        budget: 13,
        script: "bank(6)",
        icon: "$",
        doc: r#"
Adds to your bankroll.

* **Effect**: `bank(n)` increases `bankroll` by `n`.
* **Default script**: `bank(6)`
"#,
    },
    CardDef {
        id: "score_2",
        name: "Score +2",
        kind: CardKind::Score,
        budget: 12,
        script: "score(11)",
        icon: "▲",
        doc: r#"
Adds to your score.

* **Effect**: `score(n)` increases `score` by `n`.
* **Default script**: `score(11)` (unary 2)
* **Notes**: Score is compared against `target` to clear the level.
"#,
    },
    CardDef {
        id: "score_len_deck",
        name: "Score +len_source",
        kind: CardKind::Score,
        budget: 24,
        script: "score(len_source)",
        icon: "Σ",
        doc: r#"
Adds the current source size to your score.

* **Effect**: `score(len_source)` increases `score` by `len_source`.
* **Register**: `len_source` is the number of cards remaining in the source pile.
"#,
    },
    CardDef {
        id: "bank_3",
        name: "Bank +3",
        kind: CardKind::Economy,
        budget: 12,
        script: "bank(111)",
        icon: "$",
        doc: r#"
Adds to your bankroll.

* **Effect**: `bank(n)` increases `bankroll` by `n`.
* **Default script**: `bank(111)` (unary 3)
"#,
    },
    CardDef {
        id: "bank_len_pool",
        name: "Bank +len_deck",
        kind: CardKind::Economy,
        budget: 24,
        script: "bank(len_deck)",
        icon: "$",
        doc: r#"
Adds the current deck size to your bankroll.

* **Effect**: `bank(len_deck)` increases `bankroll` by `len_deck`.
* **Register**: `len_deck` is the number of cards currently in your deck.
"#,
    },
    CardDef {
        id: "dbl_bank",
        name: "Double Bank",
        kind: CardKind::Economy,
        budget: 12,
        script: "dbl()",
        icon: "×2",
        doc: r#"
Doubles your bankroll.

* **Effect**: `dbl()` multiplies `bankroll` by 2.
* **Default script**: `dbl()`
"#,
    },
];



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls tab currently has 5 actions.
                            let max = 4usize;
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            let mut eng = engine.write();
                            match idx {
                                0 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                1 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                2 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                3 => {
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                4 => {
                                    kardinomicon_target.set(None);
                                    kardinomicon_open.set(true);
                                }
                                _ => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div {
                                class: "row-scroll",
                                ondragover: move |evt| evt.prevent_default(),
                                ondrop: move |evt| {
                                    evt.prevent_default();
                                    if let Some(payload) = drag() {
                                        let mut eng = engine.write();
                                        match payload.zone {
                                            FocusZone::Deck => {
                                                let len = eng.state.collection.len();
                                                if len > 0 {
                                                    let to = len - 1;
                                                    let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                    focus.set(FocusZone::Deck);
                                                    sel_collection.set(to);
                                                }
                                            }
                                            FocusZone::Hand => {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                        }
                                    }
                                    drag.set(None);
                                },
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                            on_drag_start: move |idx| {
                                                drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx);
                                            },
                                            on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                                if let Some(payload) = drag() {
                                                    let mut eng = engine.write();
                                                    match payload.zone {
                                                        FocusZone::Deck => {
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(drop_idx);
                                                        }
                                                        FocusZone::Hand => {
                                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                            }
                                                            let from = eng.state.collection.len().saturating_sub(1);
                                                            let to = drop_idx.min(from);
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(to);
                                                        }
                                                    }
                                                }
                                                drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
    focused: bool,
    focus_index: usize,
) -> Element {
    let tab_value = tab();
    let cur_settings = settings();

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    let c0 = if focused && focus_index == 0 { "btn focused" } else { "btn" };
                    let c1 = if focused && focus_index == 1 { "btn secondary focused" } else { "btn secondary" };
                    let c2 = if focused && focus_index == 2 { "btn focused" } else { "btn" };
                    let c3 = if focused && focus_index == 3 { "btn danger focused" } else { "btn danger" };
                    let c4 = if focused && focus_index == 4 { "btn secondary focused" } else { "btn secondary" };

                    button {
                        class: "{c0}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "New run (seed 0)"
                    }
                    button {
                        class: "{c1}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Generate 5 → Deck"
                    }
                    button {
                        class: "{c2}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Execute hand"
                    }
                    button {
                        class: "{c3}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::ClearTrace) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Clear trace"
                    }
                    button {
                        class: "{c4}",
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                        "Open Kardinomicon"
                    }
                }

                div { class: "panel sidebar-panel",
                    h3 { "Telemetry" }
                    div { class: "kv", span { "Source" } code { "{state.deck.len()}" } }
                    div { class: "kv", span { "Deck" } code { "{state.collection.len()}" } }
                    div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
                    div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
                    div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
                    div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
                    div { class: "hint",
                        "Tip: the trace panel is also core UX. Keep it readable and useful."
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Assemble a hand and execute." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur_settings.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur_settings.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur_settings.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.10) saturate(1.18);
  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.26;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.045),
      rgba(255, 255, 255, 0.045) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.020),
      rgba(255, 0, 0, 0.020) 1px,
      rgba(0, 255, 0, 0.018) 2px,
      rgba(0, 0, 255, 0.020) 3px
    );
  animation: scanlines 7.2s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.94;
  animation: flicker 2.6s infinite steps(60);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 32px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
  min-height: 0;
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
  position: sticky;
  bottom: 14px;
  z-index: 8;
  backdrop-filter: blur(12px);
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: auto;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row-scroll::-webkit-scrollbar {
  height: 8px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
    focused: bool,
    focus_index: usize,
) -> Element {
    let tab_value = tab();
    let cur_settings = settings();

    // Sidebar focus highlight (used for keyboard/controller navigation).
    let c0 = if focused && focus_index == 0 {
        "btn focused"
    } else {
        "btn"
    };
    let c1 = if focused && focus_index == 1 {
        "btn secondary focused"
    } else {
        "btn secondary"
    };
    let c2 = if focused && focus_index == 2 {
        "btn focused"
    } else {
        "btn"
    };
    let c3 = if focused && focus_index == 3 {
        "btn danger focused"
    } else {
        "btn danger"
    };
    let c4 = if focused && focus_index == 4 {
        "btn secondary focused"
    } else {
        "btn secondary"
    };

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: "{c0}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "New run (seed 0)"
                    }
                    button {
                        class: "{c1}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Generate 5 → Deck"
                    }
                    button {
                        class: "{c2}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Execute hand"
                    }
                    button {
                        class: "{c3}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::ClearTrace) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Clear trace"
                    }
                    button {
                        class: "{c4}",
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                        "Open Kardinomicon"
                    }
                }

                div { class: "panel sidebar-panel",
                    h3 { "Telemetry" }
                    div { class: "kv", span { "Source" } code { "{state.deck.len()}" } }
                    div { class: "kv", span { "Deck" } code { "{state.collection.len()}" } }
                    div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
                    div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
                    div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
                    div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
                    div { class: "hint",
                        "Tip: the trace panel is also core UX. Keep it readable and useful."
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Assemble a hand and execute." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur_settings.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur_settings.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur_settings.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls tab currently has 5 actions.
                            let max = 4usize;
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            let mut eng = engine.write();
                            match idx {
                                0 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                1 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                2 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                3 => {
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                4 => {
                                    kardinomicon_target.set(None);
                                    kardinomicon_open.set(true);
                                }
                                _ => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div {
                                class: "row-scroll",
                                ondragover: move |evt| evt.prevent_default(),
                                ondrop: move |evt| {
                                    evt.prevent_default();
                                    if let Some(payload) = drag() {
                                        let mut eng = engine.write();
                                        match payload.zone {
                                            FocusZone::Deck => {
                                                let len = eng.state.collection.len();
                                                if len > 0 {
                                                    let to = len - 1;
                                                    let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                    focus.set(FocusZone::Deck);
                                                    sel_collection.set(to);
                                                }
                                            }
                                            FocusZone::Hand => {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                        }
                                    }
                                    drag.set(None);
                                },
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                            on_drag_start: move |idx| {
                                                drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx);
                                            },
                                            on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                                if let Some(payload) = drag() {
                                                    let mut eng = engine.write();
                                                    match payload.zone {
                                                        FocusZone::Deck => {
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(drop_idx);
                                                        }
                                                        FocusZone::Hand => {
                                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                            }
                                                            let from = eng.state.collection.len().saturating_sub(1);
                                                            let to = drop_idx.min(from);
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(to);
                                                        }
                                                    }
                                                }
                                                drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls tab currently has 5 actions.
                            let max = 4usize;
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            let mut eng = engine.write();
                            match idx {
                                0 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                1 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                2 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                3 => {
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                4 => {
                                    kardinomicon_target.set(None);
                                    kardinomicon_open.set(true);
                                }
                                _ => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div {
                                class: "row-scroll",
                                ondragover: move |evt| evt.prevent_default(),
                                ondrop: move |evt| {
                                    evt.prevent_default();
                                    if let Some(payload) = drag() {
                                        let mut eng = engine.write();
                                        match payload.zone {
                                            FocusZone::Deck => {
                                                let len = eng.state.collection.len();
                                                if len > 0 {
                                                    let to = len - 1;
                                                    let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                    focus.set(FocusZone::Deck);
                                                    sel_collection.set(to);
                                                }
                                            }
                                            FocusZone::Hand => {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                            FocusZone::Sidebar => {}
                                        }
                                    }
                                    drag.set(None);
                                },
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                            on_drag_start: move |idx| {
                                                drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx);
                                            },
                                            on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                                if let Some(payload) = drag() {
                                                    let mut eng = engine.write();
                                                    match payload.zone {
                                                        FocusZone::Deck => {
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(drop_idx);
                                                        }
                                                        FocusZone::Hand => {
                                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                            }
                                                            let from = eng.state.collection.len().saturating_sub(1);
                                                            let to = drop_idx.min(from);
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(to);
                                                        }
                                                    }
                                                }
                                                drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls tab currently has 5 actions.
                            let max = 4usize;
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            let mut eng = engine.write();
                            match idx {
                                0 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                1 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                2 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                3 => {
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                4 => {
                                    kardinomicon_target.set(None);
                                    kardinomicon_open.set(true);
                                }
                                _ => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div {
                                class: "row-scroll",
                                ondragover: move |evt| evt.prevent_default(),
                                ondrop: move |evt| {
                                    evt.prevent_default();
                                    if let Some(payload) = drag() {
                                        let mut eng = engine.write();
                                        match payload.zone {
                                            FocusZone::Deck => {
                                                let len = eng.state.collection.len();
                                                if len > 0 {
                                                    let to = len - 1;
                                                    let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                    focus.set(FocusZone::Deck);
                                                    sel_collection.set(to);
                                                }
                                            }
                                            FocusZone::Hand => {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                            FocusZone::Sidebar => {}
                                        }
                                    }
                                    drag.set(None);
                                },
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                            on_drag_start: move |idx| {
                                                drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx);
                                            },
                                            on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                                if let Some(payload) = drag() {
                                                    let mut eng = engine.write();
                                                    match payload.zone {
                                                        FocusZone::Deck => {
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(drop_idx);
                                                        }
                                                        FocusZone::Hand => {
                                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                            }
                                                            let from = eng.state.collection.len().saturating_sub(1);
                                                            let to = drop_idx.min(from);
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(to);
                                                        }
                                                        FocusZone::Sidebar => {}
                                                    }
                                                }
                                                drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls tab currently has 5 actions.
                            let max = 4usize;
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            let mut eng = engine.write();
                            match idx {
                                0 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                1 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                2 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                3 => {
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                4 => {
                                    kardinomicon_target.set(None);
                                    kardinomicon_open.set(true);
                                }
                                _ => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div {
                                class: "row-scroll",
                                ondragover: move |evt| evt.prevent_default(),
                                ondrop: move |evt| {
                                    evt.prevent_default();
                                    if let Some(payload) = drag() {
                                        let mut eng = engine.write();
                                        match payload.zone {
                                            FocusZone::Deck => {
                                                let len = eng.state.collection.len();
                                                if len > 0 {
                                                    let to = len - 1;
                                                    let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                    focus.set(FocusZone::Deck);
                                                    sel_collection.set(to);
                                                }
                                            }
                                            FocusZone::Hand => {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                            FocusZone::Sidebar => {}
                                        }
                                    }
                                    drag.set(None);
                                },
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                            on_drag_start: move |idx| {
                                                drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx);
                                            },
                                            on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                                if let Some(payload) = drag() {
                                                    let mut eng = engine.write();
                                                    match payload.zone {
                                                        FocusZone::Deck => {
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(drop_idx);
                                                        }
                                                        FocusZone::Hand => {
                                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                            }
                                                            let from = eng.state.collection.len().saturating_sub(1);
                                                            let to = drop_idx.min(from);
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(to);
                                                        }
                                                        FocusZone::Sidebar => {}
                                                    }
                                                }
                                                drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if !shift && idx == 0 {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(0);
                                return;
                            }
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls tab currently has 5 actions.
                            let max = 4usize;
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            let mut eng = engine.write();
                            match idx {
                                0 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                1 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                2 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                3 => {
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                4 => {
                                    kardinomicon_target.set(None);
                                    kardinomicon_open.set(true);
                                }
                                _ => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Simple focus toggle between Collection and Hand.
                        if focus() == FocusZone::Deck {
                            focus.set(FocusZone::Hand);
                            let len = engine.read().state.hand.len();
                            sel_hand.set(clamp(sel_hand(), len));
                        } else {
                            focus.set(FocusZone::Deck);
                            let len = engine.read().state.collection.len();
                            sel_collection.set(clamp(sel_collection(), len));
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "playfield",
                    div { class: "deckbar",
                        div { class: "hand-title",
                            span { "Deck" }
                            span { class: "hint", "{collection_count} cards" }
                        }

                        if state.collection.is_empty() {
                            div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                        } else {
                            div {
                                class: "row-scroll",
                                ondragover: move |evt| evt.prevent_default(),
                                ondrop: move |evt| {
                                    evt.prevent_default();
                                    if let Some(payload) = drag() {
                                        let mut eng = engine.write();
                                        match payload.zone {
                                            FocusZone::Deck => {
                                                let len = eng.state.collection.len();
                                                if len > 0 {
                                                    let to = len - 1;
                                                    let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                    focus.set(FocusZone::Deck);
                                                    sel_collection.set(to);
                                                }
                                            }
                                            FocusZone::Hand => {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                            FocusZone::Sidebar => {}
                                        }
                                    }
                                    drag.set(None);
                                },
                                div { class: "row",
                                    for (i, card) in state.collection.iter().cloned().enumerate() {
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                                let mut eng = engine.write();
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                let new_hand_len = eng.state.hand.len();
                                                if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                                let new_coll_len = eng.state.collection.len();
                                                sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            },
                                            on_move_left: move |idx| {
                                                if idx == 0 { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx - 1);
                                            },
                                            on_move_right: move |idx| {
                                                let len = engine.read().state.collection.len();
                                                if idx + 1 >= len { return; }
                                                let mut eng = engine.write();
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx + 1);
                                            },
                                            on_docs: move |id| {
                                                kardinomicon_target.set(Some(id));
                                                kardinomicon_open.set(true);
                                            },
                                            on_drag_start: move |idx| {
                                                drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(idx);
                                            },
                                            on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                                if let Some(payload) = drag() {
                                                    let mut eng = engine.write();
                                                    match payload.zone {
                                                        FocusZone::Deck => {
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(drop_idx);
                                                        }
                                                        FocusZone::Hand => {
                                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                            }
                                                            let from = eng.state.collection.len().saturating_sub(1);
                                                            let to = drop_idx.min(from);
                                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                            focus.set(FocusZone::Deck);
                                                            sel_collection.set(to);
                                                        }
                                                        FocusZone::Sidebar => {}
                                                    }
                                                }
                                                drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.10) saturate(1.18);
  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.26;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.045),
      rgba(255, 255, 255, 0.045) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.020),
      rgba(255, 0, 0, 0.020) 1px,
      rgba(0, 255, 0, 0.018) 2px,
      rgba(0, 0, 255, 0.020) 3px
    );
  animation: scanlines 7.2s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.94;
  animation: flicker 2.6s infinite steps(60);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto 1fr auto;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 14px 14px 12px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 32px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 96px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.playfield {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.12);
  background:
    linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.30)),
    radial-gradient(900px 520px at 55% 35%, rgba(0, 255, 156, 0.06), transparent 55%);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 14px;
  padding: 18px;
  min-height: 0;
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
  position: sticky;
  bottom: 14px;
  z-index: 8;
  backdrop-filter: blur(12px);
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: auto;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row-scroll::-webkit-scrollbar {
  height: 8px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```markdown
## Kardinality

Kardinality is a **single‑player, browser‑deployed** card game where your “hand” is an ordered stack of executable code‑cards. The vibe is roguelike deck‑building (Balatro‑adjacent), but the mechanics are intentionally **programming‑shaped**: cards compose, control flow exists, and you win by hitting ever‑higher score targets.

### Tech stack

* **Rust**: all game logic (rules, state, interpreter)
* **WASM (web)**: cross‑platform browser deploy
* **Dioxus**: UI rendered via **HTML DOM + CSS**, no traditional rendering engine
* **Browser APIs**: accessed from Rust (`web_sys` / `wasm_bindgen`) with minimal/no hand‑written JS

### Quick start (dev)

Recommended workflow:

* Install Rust (stable) and add the WASM target:
  * `rustup target add wasm32-unknown-unknown`
* Install Dioxus CLI:
  * `cargo install dioxus-cli`
  * (optional, faster installs) `cargo install cargo-binstall && cargo binstall dioxus-cli`
* Run the dev server:
  * `dx serve`
* Build for release:
  * `dx build --release`
* Run core logic tests:
  * `cargo test`

### Docs

* `AGENTS.md`: guidance for future AI agents (commands, constraints, conventions)
* `KARDLANG.md`: language philosophy + cost model + registers + function reference



```

### Iteration shipped

* **Program Space removed + layout fixed**: the center “Program Space” panel is gone, `min-height: 0` was added so the grid can actually shrink, and the **Hand bar is sticky + high z-index** so it stays visible and on top.
* **Deck/Hand naming cleaned up**:
  * The big row is now **Deck** (what used to be “collection” in UI).
  * The bottom row is **Hand**.
  * The top-right widget is now **Source** (so “Deck” isn’t duplicated).
* **Hover clipping fixed**: the card rows now use `row-scroll` + padding so hover lift doesn’t get chopped by headers.
* **CRT goes harder**: more intense scanlines + phosphor-ish RGB mask + stronger vignette + subtle “fisheye” via perspective transform (and it still respects the **Effects** toggle).
* **Drag & drop between Deck ↔ Hand**: cards are now draggable; dropping on a card reorders/inserts, dropping on empty row space appends.
* **Keyboard/controller-style navigation started**:
  * Left from the first card jumps you to the **sidebar**, Up/Down selects actions, Enter triggers, Right returns to Deck.
  * Cards still support arrows + Shift+arrows reorder + Enter executes (and Tab still toggles Deck/Hand focus).
* **Starter cards updated**: you now start with exactly **3 cards** in your Deck:
  * `draw(5)`, `score(4)`, `bank(6)`
* **New Kardlang function**: `draw(n)` implemented (adds cards from **Source** into your **Deck**).
* **New doc file**: added **`KARDLANG.md`** (philosophy, cost model, registers, functions). Also linked from `README.md`.

### Key files to tweak next

* **Cards + docs**: `src/game/cards.rs`
* **Kardlang doc**: `KARDLANG.md`
* **UI layout + input**: `src/ui/app.rs`, `src/ui/views/sidebar.rs`, `src/ui/views/cards.rs`
* **CRT/theme insanity**: `src/ui/theme.rs`

---

**User**

* Let's make the top bars with "score" / registers a bit shorter (maybe 40% ish)
* there seems to be an extra wrapper around the "DECK" section, remove it and have its own primary pane
* Again, hand is at the bottom of the screen and deck is on top. Let's make the "deck" be at the bottom, and "hand" on top of it (but still below the score pane)
* Drag and drop and arrow key controls are not working. Let's get that fixed, so I can play by just hitting "up/down/left/right" (for card movement) and "tab/enter" for selecting which action and executing it
* Let's animate the swapping of cards so its easier to track their movements. Make everything animated so it seems really interactive and cool
* CRT effects need to be crazy, try making it really pop. Make all the effects 1000x more visible and extreme. It's part of the game vibes
* For the "debug" tab let's clean up the format and pretty print each action with indentation. Also, lets make tooltips showing the changes and deltas that came as a result of the card being played
* Apply styling everywhere, It needs to be super overemphasized and extreme

CRT effects idea: <filter id="SphereMapTest" filterUnits="objectBoundingBox" x="-0.45" y="-1.29" width="1.6" height="3.5"> <feImage id="mapa" result="Map" xlink:href="img/sphere_wide_1.png" /> <feDisplacementMap id="despMap" in="SourceGraphic" in2="map" scale="100" xChannelSelector="R" yChannelSelector="G" /> </filter>

Like I want the whole screen space effect going on

Cards/Kardinomicon/VM:

* We should have these functions implemented and available for cards: bank, score, tri, fibo, clone, again, mutate, draw
* We should have these registers (read-only, able to be used): deck, hand, lvl
* We should have a writable register called "acc" for accumulator, which is what is used by tri, fibo, and other numerical methods, and then later referenced for scoring or bankroll. Make the syntax highlighting different for writable vs read-only registers
* We need to keep track of the full history as part of the state, since some cards will reference it (i.e. "clone()" has to reference the last played card)
* The kardinomicon should have a tab for: overview, list of all functions, some example combos/strats, and a "technical reference" with the grammar. Make it more inviting and well organized


Go ahead and get it done! Good job so far

---

**Cursor**

```rust
*** Begin Patch
*** Update File: src/ui/app.rs
@@
 pub fn App() -> Element {
     let mut engine = use_signal(|| kardinality::Engine::new(0));
     let mut tab = use_signal(|| SidebarTab::Controls);
@@
     let mut sidebar_index = use_signal(|| 0usize);
+
+    // Ensure keyboard controls work without clicking: focus the root container on mount.
+    let root_ref = use_node_ref();
+    use_effect({
+        let root_ref = root_ref.clone();
+        move || {
+            if let Some(el) = root_ref.cast::<web_sys::HtmlElement>() {
+                let _ = el.focus();
+            }
+        }
+    });
@@
         div {
             class: "{app_class}",
+            node_ref: root_ref,
+            tabindex: 0,
             onkeydown: move |evt: KeyboardEvent| {
@@
             },
@@
             div { class: "main",
                 div { class: "topbar",
@@
                     }
                 }
-
-                div { class: "arena" }
 
                 div { class: "handbar",
*** End Patch
```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls tab currently has 5 actions.
                            let max = 4usize;
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            let mut eng = engine.write();
                            match idx {
                                0 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                1 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                2 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                3 => {
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                4 => {
                                    kardinomicon_target.set(None);
                                    kardinomicon_open.set(true);
                                }
                                _ => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(4));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
*** Begin Patch
*** Update File: src/ui/theme.rs
@@
 .main {
   padding: 18px;
   display: grid;
-  grid-template-rows: auto 1fr auto auto;
+  grid-template-rows: auto auto 1fr;
   gap: 14px;
   position: relative;
   z-index: 1;
   min-height: 0;
 }
@@
-.arena {
-  border-radius: var(--radius);
-  border: 1px solid rgba(0, 255, 156, 0.10);
-  background:
-    radial-gradient(700px 420px at 30% 20%, rgba(0, 255, 156, 0.06), transparent 60%),
-    radial-gradient(600px 380px at 70% 40%, rgba(0, 200, 255, 0.045), transparent 60%),
-    linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.26));
-  min-height: 0;
-  overflow: hidden;
-}
-
 .deckbar {
   border-radius: var(--radius);
   border: 1px solid rgba(0, 255, 156, 0.14);
   background: rgba(0, 0, 0, 0.18);
   padding: 12px;
-  position: sticky;
-  bottom: 14px;
-  z-index: 9;
-  backdrop-filter: blur(12px);
+  min-height: 0;
 }
 
 .handbar {
   border-radius: var(--radius);
   border: 1px solid rgba(0, 255, 156, 0.18);
   background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
   padding: 12px;
-  overflow: hidden;
+  min-height: 0;
+  z-index: 10;
 }
*** End Patch
```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.10) saturate(1.18);
  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.26;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.045),
      rgba(255, 255, 255, 0.045) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.020),
      rgba(255, 0, 0, 0.020) 1px,
      rgba(0, 255, 0, 0.018) 2px,
      rgba(0, 0, 255, 0.020) 3px
    );
  animation: scanlines 7.2s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.94;
  animation: flicker 2.6s infinite steps(60);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 10px 12px 10px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 26px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 76px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.arena {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.10);
  background:
    radial-gradient(700px 420px at 30% 20%, rgba(0, 255, 156, 0.06), transparent 60%),
    radial-gradient(600px 380px at 70% 40%, rgba(0, 200, 255, 0.045), transparent 60%),
    linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.26));
  min-height: 0;
  overflow: hidden;
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
  position: sticky;
  bottom: 14px;
  z-index: 9;
  backdrop-filter: blur(12px);
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  overflow: hidden;
  position: relative;
  z-index: 8;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: auto;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row-scroll::-webkit-scrollbar {
  height: 8px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-fn {
  color: rgba(255, 158, 0, 0.92);
  text-shadow: 0 0 14px rgba(255, 158, 0, 0.12);
}

.tok-reg {
  color: rgba(0, 200, 255, 0.94);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-acc {
  color: rgba(255, 77, 255, 0.92);
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.10) saturate(1.18);
  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.26;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.045),
      rgba(255, 255, 255, 0.045) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.020),
      rgba(255, 0, 0, 0.020) 1px,
      rgba(0, 255, 0, 0.018) 2px,
      rgba(0, 0, 255, 0.020) 3px
    );
  animation: scanlines 7.2s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.94;
  animation: flicker 2.6s infinite steps(60);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 10px 12px 10px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 26px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 14px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 76px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 10px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
  min-height: 0;
  position: relative;
  z-index: 8;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  position: relative;
  z-index: 10;
  min-height: 0;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: auto;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row-scroll::-webkit-scrollbar {
  height: 8px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-fn {
  color: rgba(255, 158, 0, 0.92);
  text-shadow: 0 0 14px rgba(255, 158, 0, 0.12);
}

.tok-reg {
  color: rgba(0, 200, 255, 0.94);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-acc {
  color: rgba(255, 77, 255, 0.92);
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
*** Begin Patch
*** Update File: src/ui/theme.rs
@@
 .hud-panel {
-  padding: 10px 12px 10px;
+  padding: 8px 10px 8px;
 }
@@
 .scorebig {
-  font-size: 32px;
+  font-size: 28px;
   letter-spacing: 0.6px;
   color: rgba(238, 255, 248, 0.96);
   text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
 }
@@
 .deck-widget {
   width: 238px;
-  padding: 14px;
+  padding: 10px;
   position: relative;
   overflow: hidden;
 }
@@
 .deck-stack {
   position: relative;
-  height: 96px;
-  margin-top: 6px;
+  height: 86px;
+  margin-top: 6px;
 }
*** End Patch
```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.10) saturate(1.18);
  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.26;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.045),
      rgba(255, 255, 255, 0.045) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.020),
      rgba(255, 0, 0, 0.020) 1px,
      rgba(0, 255, 0, 0.018) 2px,
      rgba(0, 0, 255, 0.020) 3px
    );
  animation: scanlines 7.2s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.94;
  animation: flicker 2.6s infinite steps(60);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 8px 10px 8px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 26px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 10px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 8px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 76px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 8px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
  min-height: 0;
  position: relative;
  z-index: 8;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  position: relative;
  z-index: 10;
  min-height: 0;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: auto;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 6px;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row-scroll::-webkit-scrollbar {
  height: 8px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-fn {
  color: rgba(255, 158, 0, 0.92);
  text-shadow: 0 0 14px rgba(255, 158, 0, 0.12);
}

.tok-reg {
  color: rgba(0, 200, 255, 0.94);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-acc {
  color: rgba(255, 77, 255, 0.92);
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
*** Begin Patch
*** Update File: src/game/model.rs
@@
 #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
 pub struct GameState {
     pub bankroll: i64,
     pub score: i64,
+    pub acc: i64,
     pub level: u32,
     pub target_score: i64,
     pub phase: Phase,
@@
     pub discard: Vec<CardInstance>,
 
     pub trace: Vec<crate::game::TraceEvent>,
 
+    /// Full play history for cards and future effects that reference it (clone/again/etc).
+    pub history: Vec<HistoryEntry>,
+
+    /// Convenience pointer to the last executed card definition id.
+    pub last_played: Option<String>,
+
     pub limits: Limits,
 }
 
+#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
+pub struct HistoryEntry {
+    pub card_def_id: String,
+}
+
 impl GameState {
     pub fn new(deck: Vec<CardInstance>, limits: Limits) -> Self {
         Self {
             bankroll: 10,
             score: 0,
+            acc: 0,
             level: 1,
             target_score: 10,
             phase: Phase::InLevel,
             deck,
             collection: Vec::new(),
             hand: Vec::new(),
             discard: Vec::new(),
             trace: Vec::new(),
+            history: Vec::new(),
+            last_played: None,
             limits,
         }
     }
 }
*** End Patch
```

---

**User**

Okay, you need to fix this. It doesn't start with any cards in your deck

---

**Cursor**

Plan: I’ll add a core test that asserts `Engine::new(0)` starts with the 3 starter cards in the player Deck (and that those card defs exist), then I’ll run tests. If it fails, we’ll fix the initialization path immediately.

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use std::collections::VecDeque;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmContext, VmError};

use crate::game::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
    next_id: u64,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        // Draw pile ("source") is a shuffled pool of all known cards (with repeats).
        let mut draw_pile: Vec<CardInstance> = Vec::new();
        let mut next_id: u64 = 1;
        for _ in 0..4 {
            for def in cards::catalog() {
                draw_pile.push(CardInstance::new(next_id, def.id));
                next_id += 1;
            }
        }

        let mut engine = Self::with_deck(seed, draw_pile, Limits::default());

        // Player starts with a small starter deck.
        engine.state.collection = cards::starter_deck_ids()
            .iter()
            .map(|id| engine.new_card(*id))
            .collect();

        engine
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        let next_id = deck.iter().map(|c| c.id).max().unwrap_or(0).saturating_add(1);
        Self {
            state: GameState::new(deck, limits),
            rng,
            next_id,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn new_card(&mut self, def_id: &str) -> CardInstance {
        let id = self.next_id;
        self.next_id = self.next_id.saturating_add(1);
        CardInstance::new(id, def_id)
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let mut queue: VecDeque<CardInstance> = std::mem::take(&mut self.state.hand).into();
        let mut exec_index: usize = 0;

        while let Some(card) = queue.pop_front() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let before = Snapshot::capture(&self.state);

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index: exec_index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            let mut post_queue: Vec<CardInstance> = Vec::new();

            for call in &program.calls {
                let args = call.args.iter().map(expr_to_string).collect::<Vec<_>>();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let ctx = GameCtx { state: &self.state };
                let effects = vm.eval_call(call, &ctx)?;
                for effect in effects {
                    self.apply_effect_for_hand(&effect, &mut post_queue);
                    self.state
                        .trace
                        .push(TraceEvent::EffectApplied { effect });
                }
            }

            // After execution, cards return to the player's deck (selection pool).
            self.state.collection.push(card.clone());

            // Track full history for cards like clone/again/mutate.
            self.state.history.push(crate::game::HistoryEntry {
                card_id: card.id,
                def_id: card.def_id.clone(),
            });

            let after = Snapshot::capture(&self.state);
            self.state.trace.push(TraceEvent::CardEnd {
                index: exec_index,
                name: def.name.to_string(),
                delta: after.delta_from(before),
            });

            // Queue any extra executions to run immediately after this card.
            for c in post_queue.into_iter().rev() {
                queue.push_front(c);
            }

            exec_index = exec_index.saturating_add(1);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effect_for_hand(&mut self, effect: &Effect, post_queue: &mut Vec<CardInstance>) {
        match effect {
            Effect::AddScore(n) => self.state.score += *n,
            Effect::AddBankroll(n) => self.state.bankroll += *n,
            Effect::MulBankroll(n) => self.state.bankroll *= *n,
            Effect::Draw(n) => {
                let count: usize = (*n).clamp(0, 25) as usize;
                if let Err(e) = self.draw_to_collection(count) {
                    self.state.trace.push(TraceEvent::Error(e.to_string()));
                }
            }
            Effect::SetAcc(v) => self.state.acc = *v,
            Effect::Clone(n) | Effect::Again(n) => {
                let count: usize = (*n).clamp(0, 12) as usize;
                if count == 0 {
                    return;
                }

                let Some(last) = self.state.history.last() else {
                    self.state
                        .trace
                        .push(TraceEvent::Info("clone/again: no last played card".to_string()));
                    return;
                };

                // If the last played card was mutated, clone its current def_id from the deck.
                let def_id = self
                    .state
                    .collection
                    .iter()
                    .find(|c| c.id == last.card_id)
                    .map(|c| c.def_id.clone())
                    .unwrap_or_else(|| last.def_id.clone());

                for _ in 0..count {
                    post_queue.push(self.new_card(&def_id));
                }
            }
            Effect::Mutate => {
                let Some(last) = self.state.history.last() else {
                    self.state
                        .trace
                        .push(TraceEvent::Info("mutate: no last played card".to_string()));
                    return;
                };

                let Some(target) = self
                    .state
                    .collection
                    .iter_mut()
                    .find(|c| c.id == last.card_id)
                else {
                    self.state.trace.push(TraceEvent::Info(
                        "mutate: last played card not in deck".to_string(),
                    ));
                    return;
                };

                if let Some(new_def) = cards::catalog().choose(&mut self.rng) {
                    let old = target.def_id.clone();
                    target.def_id = new_def.id.to_string();
                    self.state.trace.push(TraceEvent::Info(format!(
                        "mutate: {} → {}",
                        old, target.def_id
                    )));
                }
            }
        }
    }
}

#[derive(Debug, Clone, Copy)]
struct Snapshot {
    score: i64,
    bankroll: i64,
    acc: i64,
    len_source: i64,
    len_deck: i64,
    len_hand: i64,
}

impl Snapshot {
    fn capture(state: &GameState) -> Self {
        Self {
            score: state.score,
            bankroll: state.bankroll,
            acc: state.acc,
            len_source: state.deck.len() as i64,
            len_deck: state.collection.len() as i64,
            len_hand: state.hand.len() as i64,
        }
    }

    fn delta_from(self, before: Snapshot) -> crate::game::trace::StateDelta {
        crate::game::trace::StateDelta {
            score: self.score - before.score,
            bankroll: self.bankroll - before.bankroll,
            acc: self.acc - before.acc,
            len_source: self.len_source - before.len_source,
            len_deck: self.len_deck - before.len_deck,
            len_hand: self.len_hand - before.len_hand,
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || to >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    v.insert(to, item);
}

struct GameCtx<'a> {
    state: &'a GameState,
}

impl VmContext for GameCtx<'_> {
    fn get(&self, name: &str) -> Option<i64> {
        match name {
            // Terminology:
            // - "deck" is the player's owned deck (selection pool)
            // - "source" is the generator/draw pile we pull new cards from
            "len_deck" | "len_pool" | "len_collection" => Some(self.state.collection.len() as i64),
            "len_source" | "len_draw" => Some(self.state.deck.len() as i64),
            "len_hand" => Some(self.state.hand.len() as i64),
            "len_discard" => Some(self.state.discard.len() as i64),
            "deck" => Some(self.state.collection.len() as i64),
            "hand" => Some(self.state.hand.len() as i64),
            "lvl" => Some(self.state.level as i64),
            "acc" => Some(self.state.acc),
            "score" => Some(self.state.score),
            "bankroll" => Some(self.state.bankroll),
            "level" => Some(self.state.level as i64),
            "target" => Some(self.state.target_score),
            "max_step" | "max_steps" => Some(self.state.limits.max_steps as i64),
            "max_loop" | "max_loop_iters" => Some(self.state.limits.max_loop_iters as i64),
            _ => None,
        }
    }
}

fn expr_to_string(expr: &crate::kardlang::Expr) -> String {
    use crate::kardlang::{BinOp, Expr};
    match expr {
        Expr::Int(n, _) => n.to_string(),
        Expr::Var(name, _) => name.clone(),
        Expr::Group(inner, _) => format!("({})", expr_to_string(inner)),
        Expr::Binary { op, lhs, rhs, .. } => {
            let op_str = match op {
                BinOp::Add => "+",
                BinOp::Mul => "*",
            };
            format!("{}{}{}", expr_to_string(lhs), op_str, expr_to_string(rhs))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_returns_cards_to_deck() {
        let deck = vec![CardInstance::new(1, "score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);
    }

    #[test]
    fn engine_new_starts_with_starter_deck() {
        let engine = Engine::new(0);
        let expected = cards::starter_deck_ids().len();
        assert_eq!(engine.state.collection.len(), expected);
        assert_eq!(engine.state.hand.len(), 0);

        for c in &engine.state.collection {
            assert!(
                c.def().is_some(),
                "starter card def missing for id={}",
                c.def_id
            );
        }
    }
}



```

### What I found

Core logic is **already starting with cards in the player Deck** (`state.collection`) — I added a regression test and it passes:

- `Engine::new(0)` starts with **3 cards in `state.collection`** (`draw_5`, `score_4`, `bank_6`)
- WASM build + tests are green

So if you’re seeing “no cards in Deck” in the browser, it’s a **UI/rendering/state wiring issue**, not game init.

### One thing I need from you to fix it precisely

When it “doesn’t start with any cards”, what do you see?

- **A)** The **Deck pane exists** and shows the empty text: “Generate cards into your deck…”
- **B)** The Deck pane is there but **cards are invisible/blank**
- **C)** The Deck pane isn’t visible at all / layout collapsed

If you tell me A/B/C (or paste a screenshot), I’ll patch the right UI layer immediately.

---

**User**

See how it doesn't start with anything in my deck, or even a visible deck section underneath the hand?

---

**Cursor**

Plan: I’ll inspect the layout CSS around `.app/.layout/.main` to see why the `deckbar` is not visible, then patch the grid/overflow/z-index so the deck pane renders under hand. After that, I’ll also verify the starter deck is shown in the deck row.

Nice catch from the screenshot: the game *does* have 35 cards in Deck (telemetry confirms), but the **Deck pane isn’t rendering because it accidentally got nested inside the `else` branch of “Hand is empty”**. I’m going to fix the RSX nesting so Deck always shows (even when hand is empty), then rebuild WASM to confirm.

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls tab currently has 5 actions.
                            let max = 4usize;
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            let mut eng = engine.write();
                            match idx {
                                0 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                1 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                2 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                3 => {
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                4 => {
                                    kardinomicon_target.set(None);
                                    kardinomicon_open.set(true);
                                }
                                _ => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(4));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            deck_count,
                            collection_count,
                            hand_count,
                            discard_count,
                            trace_count: state.trace.len(),
                            max_steps: state.limits.max_steps,
                            max_loop_iters: state.limits.max_loop_iters,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

### Fixed: Deck pane was accidentally hidden when Hand is empty

Your screenshot shows **Deck = 35** in telemetry, so the deck *was there* — the **Deck UI wasn’t rendering** because `deckbar` was mistakenly nested inside the `else { ... }` block for “hand is empty”.

I fixed the RSX nesting so **Deck always renders**, even when Hand is empty.

- **File**: `src/ui/app.rs`
- **Build**: `cargo build --target wasm32-unknown-unknown` ✅

Reload `dx serve` and you should see the **Deck section under Hand immediately**, with your starter cards available to move up into Hand.

---

**User**

Okay, looks good now! A few more changes to the UI:

* When a lot of cards are in the deck, it goes off the screen to the right. Can you change it so that they have a scrollbar at the bottom?
* Drag and drop works within the deck or hand fine, but not between the 2 (i.e. moving from deck to hand or vice versa). So allow that
* With any drag and drop, or moving or swapping cards, can you animate the position change in all cases? I always want to see the card travel even if it is by keyboard control
* Remove all the extra registers -- for now, we need just len_deck, len_hand, lvl, and score
* Let's change up the contrtols section -- it should only have legal moves (no generate 5 -> deck). It should have (at the top) "Play Hand", "Open Docs", and "Reset Game"

The "clear trace" and telemetry should be in the debug tab

---

**Cursor**

Plan: I’ll (1) tighten the controls/debug UX by moving “Clear trace” + telemetry into the Debug tab and making Controls only show legal actions, (2) fix deck/hand overflow with a bottom scrollbar, (3) make cross-zone drag/drop work (deck↔hand), and (4) add a simple but strong “card travel” animation for all reorder/move operations (mouse + keyboard) by animating transform/opacity + list transitions. Then I’ll rebuild WASM and sanity-check interactions.

Aha — the “deck off to the right” is already scrollable, but we can make the scrollbar always obvious/stable, and the cross-zone drag issue is likely because when Hand/Deck is empty there’s no drop target. Next I’ll patch sidebar controls/debug, restrict registers, add empty-dropzones, then add FLIP animations so cards visibly “travel” on keyboard + drag.

```rust
use dioxus::prelude::*;

#[component]
pub fn TopHud(
    bankroll: i64,
    score: i64,
    target: i64,
    collection_count: usize,
    hand_count: usize,
    level: u32,
) -> Element {
    let pct = if target <= 0 {
        0.0
    } else {
        (score as f64 / target as f64).clamp(0.0, 1.25)
    };
    let pct100 = (pct * 100.0).clamp(0.0, 125.0);
    let fill_style = format!("width: {pct100:.2}%");

    let stage = if pct < 0.33 {
        "low"
    } else if pct < 0.66 {
        "mid"
    } else if pct < 1.0 {
        "high"
    } else {
        "clear"
    };

    rsx! {
        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Score" }

            div { class: "scoreline",
                div { class: "scorebig", "{score}" }
                div { class: "scoremeta",
                    div { class: "hint", "Target" }
                    div { class: "scoretarget", "{target}" }
                }
            }

            div { class: "progress",
                div { class: "progress-fill {stage}", style: "{fill_style}" }
            }

            div { class: "bankline",
                div { class: "hint", "Bankroll" }
                div { class: "bankbig", "${bankroll}" }
            }
        }

        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Registers" }
            div { class: "kv", span { "len_deck" } code { "{collection_count}" } }
            div { class: "kv", span { "len_hand" } code { "{hand_count}" } }
            div { class: "kv", span { "lvl" } code { "{level}" } }
            div { class: "kv", span { "score" } code { "{score}" } }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls tab currently has 5 actions.
                            let max = 4usize;
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            let mut eng = engine.write();
                            match idx {
                                0 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                1 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::DrawToCollection { count: 5 }) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                2 => {
                                    if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                        eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                    }
                                }
                                3 => {
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                4 => {
                                    kardinomicon_target.set(None);
                                    kardinomicon_open.set(true);
                                }
                                _ => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(4));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
    focused: bool,
    focus_index: usize,
) -> Element {
    let tab_value = tab();
    let cur_settings = settings();

    // Sidebar focus highlight (used for keyboard/controller navigation).
    let c0 = if focused && focus_index == 0 {
        "btn focused"
    } else {
        "btn"
    };
    let c1 = if focused && focus_index == 1 {
        "btn secondary focused"
    } else {
        "btn secondary"
    };
    let c2 = if focused && focus_index == 2 {
        "btn focused"
    } else {
        "btn"
    };
    let c3 = if focused && focus_index == 3 {
        "btn danger focused"
    } else {
        "btn danger"
    };
    let c4 = if focused && focus_index == 4 {
        "btn secondary focused"
    } else {
        "btn secondary"
    };

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: "{c0}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                "Reset game"
                    }
                    button {
                class: "{c1}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                "Play hand"
                    }
                    button {
                class: "{c2}",
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                "Open docs"
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
            button {
                class: "btn danger",
                onclick: move |_| {
                    let mut eng = engine.write();
                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                },
                "Clear trace"
            }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Assemble a hand and execute." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }

        div { class: "panel sidebar-panel",
            h3 { "Telemetry" }
            div { class: "kv", span { "Source" } code { "{state.deck.len()}" } }
            div { class: "kv", span { "Deck" } code { "{state.collection.len()}" } }
            div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
            div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
            div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
            div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
        }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur_settings.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur_settings.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur_settings.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 2usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        2 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(2));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "empty", "Move cards from your Deck into your Hand, then execute." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div { class: "empty", "Generate cards into your deck, then move them into your hand." }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.10) saturate(1.18);
  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.26;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.045),
      rgba(255, 255, 255, 0.045) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.020),
      rgba(255, 0, 0, 0.020) 1px,
      rgba(0, 255, 0, 0.018) 2px,
      rgba(0, 0, 255, 0.020) 3px
    );
  animation: scanlines 7.2s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.94;
  animation: flicker 2.6s infinite steps(60);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 8px 10px 8px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 26px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 10px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 8px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 76px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 8px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
  min-height: 0;
  position: relative;
  z-index: 8;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  position: relative;
  z-index: 10;
  min-height: 0;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: scroll;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 10px;
  scrollbar-gutter: stable both-edges;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row-scroll::-webkit-scrollbar {
  height: 10px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-fn {
  color: rgba(255, 158, 0, 0.92);
  text-shadow: 0 0 14px rgba(255, 158, 0, 0.12);
}

.tok-reg {
  color: rgba(0, 200, 255, 0.94);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-acc {
  color: rgba(255, 77, 255, 0.92);
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
use dioxus::prelude::*;

#[component]
pub fn CardView(
    index: usize,
    card: kardinality::game::CardInstance,
    selected: bool,
    primary_icon: &'static str,
    on_select: EventHandler<usize>,
    on_primary: EventHandler<usize>,
    on_move_left: EventHandler<usize>,
    on_move_right: EventHandler<usize>,
    on_docs: EventHandler<String>,
    on_drag_start: EventHandler<usize>,
    on_drag_end: EventHandler<()>,
    on_drop: EventHandler<usize>,
) -> Element {
    let badge = format!("#{index}");

    let def_id = card.def_id.clone();
    let (name, script, budget, icon, doc_hint) = card
        .def()
        .map(|d| (d.name, d.script, d.budget, d.icon, d.kind))
        .map(|(name, script, budget, icon, kind)| (name, script, budget, icon, format!("{kind:?}")))
        .unwrap_or(("Missing Card", "/* missing */", 0, "?", "Missing".to_string()));

    let script_spans: Vec<(String, &'static str)> = match kardinality::kardlang::lex(script) {
        Ok(tokens) => tokens
            .into_iter()
            .filter(|t| !matches!(t.kind, kardinality::kardlang::TokenKind::Eof))
            .map(|t| {
                let text = script
                    .get(t.span.start..t.span.end)
                    .unwrap_or("")
                    .to_string();
                let class = match t.kind {
                    kardinality::kardlang::TokenKind::Ident(name) => {
                        let is_fn = matches!(
                            name.as_str(),
                            "draw" | "score" | "bank" | "dbl" | "tri" | "fibo" | "clone" | "again" | "mutate"
                        );
                        let is_reg = matches!(
                            name.as_str(),
                            "len_deck" | "len_hand" | "lvl" | "score"
                        );

                        if name == "acc" {
                            "acc"
                        } else if is_fn {
                            "fn"
                        } else if is_reg {
                            "reg"
                        } else {
                            "ident"
                        }
                    }
                    kardinality::kardlang::TokenKind::NumUnary(_) => "num",
                    kardinality::kardlang::TokenKind::NumDigit(_) => "num",
                    kardinality::kardlang::TokenKind::Plus => "op",
                    kardinality::kardlang::TokenKind::Star => "op",
                    kardinality::kardlang::TokenKind::LParen => "punct",
                    kardinality::kardlang::TokenKind::RParen => "punct",
                    kardinality::kardlang::TokenKind::Comma => "punct",
                    kardinality::kardlang::TokenKind::Semi => "punct",
                    kardinality::kardlang::TokenKind::Eof => "punct",
                };
                (text, class)
            })
            .collect(),
        Err(_) => vec![(script.to_string(), "raw")],
    };

    let class = if selected { "card selected" } else { "card" };

    rsx! {
        div {
            class: "{class}",
            id: "card-{card.id}",
            onclick: move |_| on_select.call(index),
            draggable: "true",
            ondragstart: move |evt: DragEvent| {
                let _ = evt
                    .data()
                    .data_transfer()
                    .set_data("text/plain", "kardinality-card");
                evt.data().data_transfer().set_effect_allowed("move");
                on_drag_start.call(index);
            },
            ondragend: move |_| on_drag_end.call(()),
            ondragover: move |evt| evt.prevent_default(),
            ondrop: move |evt| {
                evt.prevent_default();
                evt.stop_propagation();
                on_drop.call(index);
            },
            div { class: "card-badge", "{badge}" }
            div { class: "card-art" }
            div { class: "card-body",
                h3 { class: "card-title", "{icon} {name}" }
                div { class: "card-sub", "{doc_hint} • Budget: {budget}" }
                div { class: "card-script",
                    for (text, cls) in script_spans {
                        span { class: "tok tok-{cls}", "{text}" }
                    }
                }
            }

            div { class: "card-actions",
                button {
                    class: "card-btn",
                    title: "Docs",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_docs.call(def_id.clone());
                    },
                    "📖"
                }
                button {
                    class: "card-btn",
                    title: "Move",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_primary.call(index);
                    },
                    "{primary_icon}"
                }
                button {
                    class: "card-btn",
                    title: "Move left",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_left.call(index);
                    },
                    "←"
                }
                button {
                    class: "card-btn",
                    title: "Move right",
                    onclick: move |evt| {
                        evt.stop_propagation();
                        on_move_right.call(index);
                    },
                    "→"
                }
            }
        }
    }
}



```

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, Copy)]
pub struct Rect {
    pub left: f64,
    pub top: f64,
}

pub fn visible_card_ids(deck: &[kardinality::game::CardInstance], hand: &[kardinality::game::CardInstance]) -> Vec<String> {
    let mut ids = Vec::with_capacity(deck.len() + hand.len());
    for c in deck {
        ids.push(format!("card-{}", c.id));
    }
    for c in hand {
        ids.push(format!("card-{}", c.id));
    }
    ids
}

pub fn capture_rects(ids: &[String]) -> HashMap<String, Rect> {
    let mut out = HashMap::new();
    let Some(window) = web_sys::window() else {
        return out;
    };
    let Some(doc) = window.document() else {
        return out;
    };

    for id in ids {
        if let Some(el) = doc.get_element_by_id(id) {
            let rect = el.get_bounding_client_rect();
            out.insert(
                id.clone(),
                Rect {
                    left: rect.left(),
                    top: rect.top(),
                },
            );
        }
    }
    out
}

pub fn play_flip(before: HashMap<String, Rect>, duration_ms: f64) {
    let Some(window) = web_sys::window() else {
        return;
    };
    let Some(doc) = window.document() else {
        return;
    };

    // Run on the next frame so Dioxus has applied DOM updates after state changes.
    let cb = wasm_bindgen::closure::Closure::wrap(Box::new(move || {
        for (id, b) in before.iter() {
            let Some(el) = doc.get_element_by_id(id) else { continue };
            let a = el.get_bounding_client_rect();
            let dx = b.left - a.left();
            let dy = b.top - a.top();
            if dx.abs() < 0.5 && dy.abs() < 0.5 {
                continue;
            }

            // Web Animations API: animate the transform from previous position to new.
            let keyframes = js_sys::Array::new();
            let k0 = js_sys::Object::new();
            let k1 = js_sys::Object::new();
            let _ = js_sys::Reflect::set(
                &k0,
                &"transform".into(),
                &format!("translate({dx}px, {dy}px)").into(),
            );
            let _ = js_sys::Reflect::set(&k1, &"transform".into(), &"translate(0px, 0px)".into());
            keyframes.push(&k0);
            keyframes.push(&k1);

            let mut opts = web_sys::KeyframeAnimationOptions::new();
            opts.duration(duration_ms);
            opts.easing("cubic-bezier(0.16, 1, 0.3, 1)");

            let _ = el.animate_with_keyframe_animation_options(&keyframes.into(), &opts);
        }
    }) as Box<dyn FnMut()>);

    let _ = window.request_animation_frame(cb.as_ref().unchecked_ref());
    cb.forget();
}


```

```rust
*** Begin Patch
*** Update File: src/ui/mod.rs
@@
 pub mod app;
+pub mod anim;
 pub mod theme;
 pub mod views;
 pub mod state; // New module for UI-specific state
*** End Patch
```

```rust
mod app;
pub mod anim;
pub mod state;
pub mod theme;

pub mod views;

pub use app::App;



```

Nice: we’ve now tightened the HUD registers to exactly the 4 you wanted, simplified the Controls tab, and improved scrollbars. Next I’ll wire in FLIP animations around *every* move/reorder (keyboard + drag) and add “empty dropzones” so deck↔hand drag works even when the target is empty.

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let st = &engine.read().state;
                                let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                let before = anim::capture_rects(&ids);
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let st = &engine.read().state;
                                let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                let before = anim::capture_rects(&ids);
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let st = &engine.read().state;
                                let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                let before = anim::capture_rects(&ids);
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let st = &engine.read().state;
                                let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                let before = anim::capture_rects(&ids);
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let st = &engine.read().state;
                            let ids = anim::visible_card_ids(&st.collection, &st.hand);
                            let before = anim::capture_rects(&ids);
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 2usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let st = &engine.read().state;
                            let ids = anim::visible_card_ids(&st.collection, &st.hand);
                            let before = anim::capture_rects(&ids);
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        2 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(2));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let st = &engine.read().state;
                                    let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                    let before = anim::capture_rects(&ids);
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Deck {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Hand"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let st = &engine.read().state;
                                    let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                    let before = anim::capture_rects(&ids);
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let st = &engine.read().state;
                                            let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                            let before = anim::capture_rects(&ids);
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let st = &engine.read().state;
                                            let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                            let before = anim::capture_rects(&ids);
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let st = &engine.read().state;
                                            let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                            let before = anim::capture_rects(&ids);
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let st = &engine.read().state;
                                                let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                                let before = anim::capture_rects(&ids);
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let st = &engine.read().state;
                                    let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                    let before = anim::capture_rects(&ids);
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Hand {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Deck"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let st = &engine.read().state;
                                    let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                    let before = anim::capture_rects(&ids);
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let st = &engine.read().state;
                                            let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                            let before = anim::capture_rects(&ids);
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let st = &engine.read().state;
                                            let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                            let before = anim::capture_rects(&ids);
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let st = &engine.read().state;
                                            let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                            let before = anim::capture_rects(&ids);
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let st = &engine.read().state;
                                                let ids = anim::visible_card_ids(&st.collection, &st.hand);
                                                let before = anim::capture_rects(&ids);
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
*** Begin Patch
*** Update File: src/ui/theme.rs
@@
 .empty {
   padding: 14px 12px;
   border-radius: 14px;
   border: 1px dashed rgba(0, 255, 156, 0.16);
   color: rgba(238, 255, 248, 0.62);
   background: rgba(0, 0, 0, 0.14);
 }
+
+.empty.dropzone {
+  cursor: copy;
+  text-align: center;
+  padding: 18px 12px;
+  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
+}
+.empty.dropzone:hover {
+  transform: translateY(-1px);
+  border-color: rgba(0, 255, 156, 0.34);
+  box-shadow: 0 0 22px rgba(0, 255, 156, 0.10);
+}
*** End Patch
```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.10) saturate(1.18);
  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.26;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.045),
      rgba(255, 255, 255, 0.045) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.020),
      rgba(255, 0, 0, 0.020) 1px,
      rgba(0, 255, 0, 0.018) 2px,
      rgba(0, 0, 255, 0.020) 3px
    );
  animation: scanlines 7.2s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.94;
  animation: flicker 2.6s infinite steps(60);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 8px 10px 8px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 26px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 10px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 8px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 76px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 8px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
  min-height: 0;
  position: relative;
  z-index: 8;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  position: relative;
  z-index: 10;
  min-height: 0;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: scroll;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 10px;
  scrollbar-gutter: stable both-edges;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row-scroll::-webkit-scrollbar {
  height: 10px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-fn {
  color: rgba(255, 158, 0, 0.92);
  text-shadow: 0 0 14px rgba(255, 158, 0, 0.12);
}

.tok-reg {
  color: rgba(0, 200, 255, 0.94);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-acc {
  color: rgba(255, 77, 255, 0.92);
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.empty.dropzone {
  border-radius: 14px;
  border: 1px dashed rgba(0, 255, 156, 0.20);
  background: rgba(0, 0, 0, 0.14);
  cursor: copy;
  text-align: center;
  padding: 18px 12px;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}
.empty.dropzone:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.34);
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.10);
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

Got it — we’re very close, but the build failed for two reasons: we introduced a tiny WASM animation helper that needs `js-sys/web-sys` deps + wasm-only gating, and a bunch of closures held an `engine.read()` borrow while also calling `engine.write()`. Next I’ll add the missing deps, make `ui::anim` a no-op on non-wasm targets, and refactor those handlers to avoid borrow conflicts.

```toml
[package]
name = "kardinality"
version = "0.1.0"
edition = "2024"

[dependencies]
rand = "0.8"
rand_chacha = "0.3"
serde = { version = "1", features = ["derive"] }
thiserror = "1"

[target.'cfg(target_arch = "wasm32")'.dependencies]
# Dioxus UI (DOM + CSS) for the browser build.
dioxus = { version = "0.7.2", features = ["web"] }

# Better panics in the browser console.
console_error_panic_hook = "0.1"

# Browser APIs for animations and DOM inspection (used via Rust; no hand-written JS).
wasm-bindgen = "0.2"
js-sys = "0.3"
web-sys = { version = "0.3", features = ["Window", "Document", "Element", "DomRect", "Animation", "KeyframeEffect", "KeyframeAnimationOptions"] }

# Ensure `rand` works on wasm by enabling JS-backed entropy (even though we prefer deterministic seeds).
getrandom = { version = "0.2", features = ["js"] }

```

```rust
// FLIP animations are only meaningful in the browser build.
// Provide no-op stubs for native builds so `cargo test` remains pleasant.

#[cfg(target_arch = "wasm32")]
mod imp {
    use std::collections::HashMap;

    use wasm_bindgen::JsCast;

    #[derive(Debug, Clone, Copy)]
    pub struct Rect {
        pub left: f64,
        pub top: f64,
    }

    pub fn visible_card_ids(
        deck: &[kardinality::game::CardInstance],
        hand: &[kardinality::game::CardInstance],
    ) -> Vec<String> {
        let mut ids = Vec::with_capacity(deck.len() + hand.len());
        for c in deck {
            ids.push(format!("card-{}", c.id));
        }
        for c in hand {
            ids.push(format!("card-{}", c.id));
        }
        ids
    }

    pub fn capture_rects(ids: &[String]) -> HashMap<String, Rect> {
        let mut out = HashMap::new();
        let Some(window) = web_sys::window() else {
            return out;
        };
        let Some(doc) = window.document() else {
            return out;
        };

        for id in ids {
            if let Some(el) = doc.get_element_by_id(id) {
                let rect = el.get_bounding_client_rect();
                out.insert(
                    id.clone(),
                    Rect {
                        left: rect.left(),
                        top: rect.top(),
                    },
                );
            }
        }
        out
    }

    pub fn play_flip(before: HashMap<String, Rect>, duration_ms: f64) {
        let Some(window) = web_sys::window() else {
            return;
        };
        let Some(doc) = window.document() else {
            return;
        };

        // Run on the next frame so Dioxus has applied DOM updates after state changes.
        let cb = wasm_bindgen::closure::Closure::wrap(Box::new(move || {
            for (id, b) in before.iter() {
                let Some(el) = doc.get_element_by_id(id) else {
                    continue;
                };
                let a = el.get_bounding_client_rect();
                let dx = b.left - a.left();
                let dy = b.top - a.top();
                if dx.abs() < 0.5 && dy.abs() < 0.5 {
                    continue;
                }

                // Web Animations API: animate the transform from previous position to new.
                let keyframes = js_sys::Array::new();
                let k0 = js_sys::Object::new();
                let k1 = js_sys::Object::new();
                let _ = js_sys::Reflect::set(
                    &k0,
                    &"transform".into(),
                    &format!("translate({dx}px, {dy}px)").into(),
                );
                let _ =
                    js_sys::Reflect::set(&k1, &"transform".into(), &"translate(0px, 0px)".into());
                keyframes.push(&k0);
                keyframes.push(&k1);

                let mut opts = web_sys::KeyframeAnimationOptions::new();
                opts.duration(duration_ms);
                opts.easing("cubic-bezier(0.16, 1, 0.3, 1)");

                let _ = el.animate_with_keyframe_animation_options(&keyframes.into(), &opts);
            }
        }) as Box<dyn FnMut()>);

        let _ = window.request_animation_frame(cb.as_ref().unchecked_ref());
        cb.forget();
    }
}

#[cfg(not(target_arch = "wasm32"))]
mod imp {
    use std::collections::HashMap;

    #[derive(Debug, Clone, Copy)]
    pub struct Rect {
        pub left: f64,
        pub top: f64,
    }

    pub fn visible_card_ids(
        _deck: &[kardinality::game::CardInstance],
        _hand: &[kardinality::game::CardInstance],
    ) -> Vec<String> {
        Vec::new()
    }

    pub fn capture_rects(_ids: &[String]) -> HashMap<String, Rect> {
        HashMap::new()
    }

    pub fn play_flip(_before: HashMap<String, Rect>, _duration_ms: f64) {}
}

pub use imp::*;



```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
    focused: bool,
    focus_index: usize,
) -> Element {
    let tab_value = tab();
    let cur_settings = settings();

    // Sidebar focus highlight (used for keyboard/controller navigation).
    let c0 = if focused && focus_index == 0 {
        "btn focused"
    } else {
        "btn"
    };
    let c1 = if focused && focus_index == 1 {
        "btn secondary focused"
    } else {
        "btn secondary"
    };
    let c2 = if focused && focus_index == 2 {
        "btn focused"
    } else {
        "btn"
    };

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: "{c0}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                "Reset game"
                    }
                    button {
                class: "{c1}",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                "Play hand"
                    }
                    button {
                class: "{c2}",
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                "Open docs"
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
            button {
                class: "btn danger",
                onclick: move |_| {
                    let mut eng = engine.write();
                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                },
                "Clear trace"
            }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Assemble a hand and execute." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }

        div { class: "panel sidebar-panel",
            h3 { "Telemetry" }
            div { class: "kv", span { "Source" } code { "{state.deck.len()}" } }
            div { class: "kv", span { "Deck" } code { "{state.collection.len()}" } }
            div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
            div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
            div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
            div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
        }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur_settings.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur_settings.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur_settings.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 2usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        2 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(2));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Deck {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Hand"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Hand {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Deck"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```toml
[package]
name = "kardinality"
version = "0.1.0"
edition = "2024"

[dependencies]
rand = "0.8"
rand_chacha = "0.3"
serde = { version = "1", features = ["derive"] }
thiserror = "1"

[target.'cfg(target_arch = "wasm32")'.dependencies]
# Dioxus UI (DOM + CSS) for the browser build.
dioxus = { version = "0.7.2", features = ["web"] }

# Better panics in the browser console.
console_error_panic_hook = "0.1"

# Browser APIs for animations and DOM inspection (used via Rust; no hand-written JS).
wasm-bindgen = "0.2"
js-sys = "0.3"
web-sys = { version = "0.3", features = ["Window", "Document", "Element", "DomRect", "HtmlElement", "CssStyleDeclaration"] }

# Ensure `rand` works on wasm by enabling JS-backed entropy (even though we prefer deterministic seeds).
getrandom = { version = "0.2", features = ["js"] }

```

```rust
// FLIP animations are only meaningful in the browser build.
// Provide no-op stubs for native builds so `cargo test` remains pleasant.

#[cfg(target_arch = "wasm32")]
mod imp {
    use std::collections::HashMap;

    use wasm_bindgen::JsCast;

    #[derive(Debug, Clone, Copy)]
    pub struct Rect {
        pub left: f64,
        pub top: f64,
    }

    pub fn visible_card_ids(
        deck: &[kardinality::game::CardInstance],
        hand: &[kardinality::game::CardInstance],
    ) -> Vec<String> {
        let mut ids = Vec::with_capacity(deck.len() + hand.len());
        for c in deck {
            ids.push(format!("card-{}", c.id));
        }
        for c in hand {
            ids.push(format!("card-{}", c.id));
        }
        ids
    }

    pub fn capture_rects(ids: &[String]) -> HashMap<String, Rect> {
        let mut out = HashMap::new();
        let Some(window) = web_sys::window() else {
            return out;
        };
        let Some(doc) = window.document() else {
            return out;
        };

        for id in ids {
            if let Some(el) = doc.get_element_by_id(id) {
                let rect = el.get_bounding_client_rect();
                out.insert(
                    id.clone(),
                    Rect {
                        left: rect.left(),
                        top: rect.top(),
                    },
                );
            }
        }
        out
    }

    pub fn play_flip(before: HashMap<String, Rect>, duration_ms: f64) {
        let Some(window) = web_sys::window() else {
            return;
        };
        let Some(doc) = window.document() else {
            return;
        };

        // Run on the next frame so Dioxus has applied DOM updates after state changes.
        let cb = wasm_bindgen::closure::Closure::wrap(Box::new(move || {
            // Step 1: apply inverse transforms (no transition)
            let mut animated: Vec<web_sys::HtmlElement> = Vec::new();
            for (id, b) in before.iter() {
                let Some(el) = doc.get_element_by_id(id) else {
                    continue;
                };
                let a = el.get_bounding_client_rect();
                let dx = b.left - a.left();
                let dy = b.top - a.top();
                if dx.abs() < 0.5 && dy.abs() < 0.5 {
                    continue;
                }

                let Ok(html) = el.dyn_into::<web_sys::HtmlElement>() else {
                    continue;
                };

                let style = html.style();
                let _ = style.set_property("transition", "none");
                let _ = style.set_property("transform", &format!("translate({dx}px, {dy}px)"));
                animated.push(html);
            }

            // Step 2: next frame, animate back to identity
            let Some(window2) = web_sys::window() else { return };
            let cb2 = wasm_bindgen::closure::Closure::wrap(Box::new(move || {
                for html in animated.iter() {
                    let style = html.style();
                    let _ = style.set_property(
                        "transition",
                        &format!(
                            "transform {}ms cubic-bezier(0.16, 1, 0.3, 1)",
                            duration_ms
                        ),
                    );
                    let _ = style.set_property("transform", "translate(0px, 0px)");
                }
            }) as Box<dyn FnMut()>);
            let _ = window2.request_animation_frame(cb2.as_ref().unchecked_ref());
            cb2.forget();
        }) as Box<dyn FnMut()>);

        let _ = window.request_animation_frame(cb.as_ref().unchecked_ref());
        cb.forget();
    }
}

#[cfg(not(target_arch = "wasm32"))]
mod imp {
    use std::collections::HashMap;

    #[derive(Debug, Clone, Copy)]
    pub struct Rect {
        pub left: f64,
        pub top: f64,
    }

    pub fn visible_card_ids(
        _deck: &[kardinality::game::CardInstance],
        _hand: &[kardinality::game::CardInstance],
    ) -> Vec<String> {
        Vec::new()
    }

    pub fn capture_rects(_ids: &[String]) -> HashMap<String, Rect> {
        HashMap::new()
    }

    pub fn play_flip(_before: HashMap<String, Rect>, _duration_ms: f64) {}
}

pub use imp::*;



```

### Done — all requested UI changes (and the build is green)

#### Scrollbar for big decks/hands
- **Changed `.row-scroll` to `overflow-x: scroll` + `scrollbar-gutter: stable both-edges`**, and bumped scrollbar height so it’s always visible and doesn’t “disappear” when content grows.
- **File**: `src/ui/theme.rs`

#### Deck ↔ Hand drag & drop
- **Fixed the main failure case**: when Hand/Deck is empty, there used to be **no drop target**, so cross-zone drops failed.
- Added **explicit empty dropzones** (“Drop here to add to Hand/Deck”) that accept drops and move cards across.
- Also added `stop_propagation()` on card `ondrop` so dropping onto a card doesn’t double-trigger the row container handler.
- **Files**: `src/ui/app.rs`, `src/ui/views/cards.rs`, `src/ui/theme.rs`

#### Animate *all* card moves/reorders (mouse + keyboard)
- Implemented a **FLIP-style animation** (capture rects → mutate state → animate transform back to identity) using **browser APIs from Rust** (no hand-written JS).
- Wired it into:
  - **Keyboard moves** (Shift+←/→ reorder, ↑/↓ move between zones)
  - **Click buttons** (move/reorder)
  - **Drag/drop** (within + cross-zone + empty dropzones)
- **Files**: `src/ui/anim.rs` (new), `src/ui/mod.rs`, `src/ui/app.rs`
- Added wasm-only deps: **`wasm-bindgen`, `js-sys`, `web-sys`**
- **File**: `Cargo.toml`

#### Registers trimmed
- Top registers panel now shows only: **`len_deck`, `len_hand`, `lvl`, `score`**
- **Files**: `src/ui/views/hud.rs`, `src/ui/app.rs`
- Syntax highlighting for registers now recognizes only those four.
- **File**: `src/ui/views/cards.rs`

#### Controls tab shows only legal actions; Debug owns trace+telemetry
- **Controls**: “Reset game”, “Play hand”, “Open docs”
- **Debug**: “Clear trace” + telemetry block + trace list
- Updated keyboard “Sidebar Enter” mappings + sidebar selection bounds.
- **Files**: `src/ui/views/sidebar.rs`, `src/ui/app.rs`

### What to do now
Reload `dx serve` and try:
- Drag a card **Deck → Hand** (even when Hand is empty)
- Use keyboard: **Tab** to focus Deck/Hand, **↑/↓** to move between zones, **Shift+←/→** to reorder
- You should see cards visibly “travel” on every move.

If you want the animation to be even more dramatic (longer duration / overshoot / blur trail), tell me the vibe (snappy vs floaty) and I’ll tune the FLIP easing + add a glow trail.

---

**User**

Looks great! A few suggestions about the UI:

* Lets keep the "Reset Game" and "Open Docs" in the left hand panel, and make sure that Reset Game is red with a warning!
* Play Hand should be on the right side in the main content window, preferably with an icon or something so its obvious (maybe a big green button vibes?)
* The "empty card" section is a different height so the layout changes which is not ideal -- can you make it a sort of "ghost" card outline with a + in the middle (so the layout doesn't change)
* The dragging and dropping works successfully! The only change I want to make is that when you drag and drop on top of another card, they should swap places. You should be able to put the card "in-between" 2 other cards as well


Add visual feedback for every action and possible action (like highlighting and giving a icon) when you are hovering over and about to swap a card, or highlighting a between area when you are going to insert it.


Also, can you make the whole screen CSS effect of the ENTIRE page more CRT like? It should have scanlines, little subtle overlay effects, and so on. It's not been extreme enough


---

**Cursor**

Plan: I’ll move “Play Hand” into the main right rail as a big neon-green action button, keep only “Reset Game” (red/warning) + “Open Docs” in the sidebar. Then I’ll rework drag/drop to support **swap-on-card** and **insert-between** using explicit drop slots (with strong visual highlights) and replace the empty areas with fixed-size “ghost card” outlines so layout never jumps. Finally I’ll crank the CRT overlay intensity globally (scanlines + wobble + chroma).

```rust
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand_chacha::ChaCha8Rng;
use thiserror::Error;

use std::collections::VecDeque;

use crate::kardlang::{effective_len, parse_program};
use crate::vm::{Effect, Limits, Machine, VmContext, VmError};

use crate::game::{cards, CardInstance, GameState, Phase, TraceEvent};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Action {
    NewRun { seed: u64 },
    DrawToCollection { count: usize },
    MoveCollectionToHand { index: usize },
    MoveHandToCollection { index: usize },
    ReorderCollection { from: usize, to: usize },
    ReorderHand { from: usize, to: usize },
    SwapCollection { a: usize, b: usize },
    SwapHand { a: usize, b: usize },
    PlayHand,
    ClearTrace,
}

#[derive(Debug, Error)]
pub enum GameError {
    #[error("kardlang parse error: {0}")]
    Parse(#[from] crate::kardlang::ParseError),

    #[error("vm error: {0}")]
    Vm(#[from] VmError),

    #[error("unknown card definition id: {0}")]
    UnknownCardDef(String),

    #[error("card script cost {cost} exceeds budget {budget}: {name}")]
    CardOverBudget { name: String, cost: usize, budget: usize },

    #[error("cannot draw a hand: deck and discard are empty")]
    NoCards,
}

#[derive(Debug)]
pub struct Engine {
    pub state: GameState,
    rng: ChaCha8Rng,
    next_id: u64,
}

impl Engine {
    pub fn new(seed: u64) -> Self {
        // Draw pile ("source") is a shuffled pool of all known cards (with repeats).
        let mut draw_pile: Vec<CardInstance> = Vec::new();
        let mut next_id: u64 = 1;
        for _ in 0..4 {
            for def in cards::catalog() {
                draw_pile.push(CardInstance::new(next_id, def.id));
                next_id += 1;
            }
        }

        let mut engine = Self::with_deck(seed, draw_pile, Limits::default());

        // Player starts with a small starter deck.
        engine.state.collection = cards::starter_deck_ids()
            .iter()
            .map(|id| engine.new_card(*id))
            .collect();

        engine
    }

    pub fn with_deck(seed: u64, mut deck: Vec<CardInstance>, limits: Limits) -> Self {
        let mut rng = ChaCha8Rng::seed_from_u64(seed);
        deck.shuffle(&mut rng);
        let next_id = deck.iter().map(|c| c.id).max().unwrap_or(0).saturating_add(1);
        Self {
            state: GameState::new(deck, limits),
            rng,
            next_id,
        }
    }

    pub fn dispatch(&mut self, action: Action) -> Result<(), GameError> {
        self.state
            .trace
            .push(TraceEvent::Action { action: format!("{action:?}") });

        match action {
            Action::NewRun { seed } => {
                *self = Self::new(seed);
                Ok(())
            }
            Action::DrawToCollection { count } => self.draw_to_collection(count),
            Action::MoveCollectionToHand { index } => {
                if let Some(card) = take_at(&mut self.state.collection, index) {
                    self.state.hand.push(card);
                }
                Ok(())
            }
            Action::MoveHandToCollection { index } => {
                if let Some(card) = take_at(&mut self.state.hand, index) {
                    self.state.collection.push(card);
                }
                Ok(())
            }
            Action::ReorderCollection { from, to } => {
                move_within(&mut self.state.collection, from, to);
                Ok(())
            }
            Action::ReorderHand { from, to } => {
                move_within(&mut self.state.hand, from, to);
                Ok(())
            }
            Action::SwapCollection { a, b } => {
                swap_within(&mut self.state.collection, a, b);
                Ok(())
            }
            Action::SwapHand { a, b } => {
                swap_within(&mut self.state.hand, a, b);
                Ok(())
            }
            Action::PlayHand => self.play_hand(),
            Action::ClearTrace => {
                self.state.trace.clear();
                Ok(())
            }
        }
    }

    fn new_card(&mut self, def_id: &str) -> CardInstance {
        let id = self.next_id;
        self.next_id = self.next_id.saturating_add(1);
        CardInstance::new(id, def_id)
    }

    fn draw_to_collection(&mut self, count: usize) -> Result<(), GameError> {
        for _ in 0..count {
            if let Some(card) = self.draw_one()? {
                self.state.collection.push(card);
            }
        }
        Ok(())
    }

    fn draw_one(&mut self) -> Result<Option<CardInstance>, GameError> {
        if self.state.deck.is_empty() {
            if self.state.discard.is_empty() {
                return Err(GameError::NoCards);
            }

            self.state.deck.append(&mut self.state.discard);
            self.state.deck.shuffle(&mut self.rng);
        }

        Ok(self.state.deck.pop())
    }

    fn play_hand(&mut self) -> Result<(), GameError> {
        if self.state.phase != Phase::InLevel {
            return Ok(());
        }

        let mut vm = Machine::new(self.state.limits);

        let mut queue: VecDeque<CardInstance> = std::mem::take(&mut self.state.hand).into();
        let mut exec_index: usize = 0;

        while let Some(card) = queue.pop_front() {
            let def = card
                .def()
                .ok_or_else(|| GameError::UnknownCardDef(card.def_id.clone()))?;

            let before = Snapshot::capture(&self.state);

            let cost = effective_len(def.script);
            self.state.trace.push(TraceEvent::CardStart {
                index: exec_index,
                name: def.name.to_string(),
                script: def.script.to_string(),
                budget: def.budget,
                cost,
            });

            if cost > def.budget {
                return Err(GameError::CardOverBudget {
                    name: def.name.to_string(),
                    cost,
                    budget: def.budget,
                });
            }

            let program = parse_program(def.script)?;
            let mut post_queue: Vec<CardInstance> = Vec::new();

            for call in &program.calls {
                let args = call.args.iter().map(expr_to_string).collect::<Vec<_>>();

                self.state.trace.push(TraceEvent::Call {
                    name: call.name.clone(),
                    args,
                });

                let ctx = GameCtx { state: &self.state };
                let effects = vm.eval_call(call, &ctx)?;
                for effect in effects {
                    self.apply_effect_for_hand(&effect, &mut post_queue);
                    self.state
                        .trace
                        .push(TraceEvent::EffectApplied { effect });
                }
            }

            // After execution, cards return to the player's deck (selection pool).
            self.state.collection.push(card.clone());

            // Track full history for cards like clone/again/mutate.
            self.state.history.push(crate::game::HistoryEntry {
                card_id: card.id,
                def_id: card.def_id.clone(),
            });

            let after = Snapshot::capture(&self.state);
            self.state.trace.push(TraceEvent::CardEnd {
                index: exec_index,
                name: def.name.to_string(),
                delta: after.delta_from(before),
            });

            // Queue any extra executions to run immediately after this card.
            for c in post_queue.into_iter().rev() {
                queue.push_front(c);
            }

            exec_index = exec_index.saturating_add(1);
        }

        if self.state.score >= self.state.target_score {
            self.state.level += 1;
            self.state.target_score += 10;
            self.state.trace.push(TraceEvent::Info(format!(
                "Level cleared! Next target: {}",
                self.state.target_score
            )));
        }

        Ok(())
    }

    fn apply_effect_for_hand(&mut self, effect: &Effect, post_queue: &mut Vec<CardInstance>) {
        match effect {
            Effect::AddScore(n) => self.state.score += *n,
            Effect::AddBankroll(n) => self.state.bankroll += *n,
            Effect::MulBankroll(n) => self.state.bankroll *= *n,
            Effect::Draw(n) => {
                let count: usize = (*n).clamp(0, 25) as usize;
                if let Err(e) = self.draw_to_collection(count) {
                    self.state.trace.push(TraceEvent::Error(e.to_string()));
                }
            }
            Effect::SetAcc(v) => self.state.acc = *v,
            Effect::Clone(n) | Effect::Again(n) => {
                let count: usize = (*n).clamp(0, 12) as usize;
                if count == 0 {
                    return;
                }

                let Some(last) = self.state.history.last() else {
                    self.state
                        .trace
                        .push(TraceEvent::Info("clone/again: no last played card".to_string()));
                    return;
                };

                // If the last played card was mutated, clone its current def_id from the deck.
                let def_id = self
                    .state
                    .collection
                    .iter()
                    .find(|c| c.id == last.card_id)
                    .map(|c| c.def_id.clone())
                    .unwrap_or_else(|| last.def_id.clone());

                for _ in 0..count {
                    post_queue.push(self.new_card(&def_id));
                }
            }
            Effect::Mutate => {
                let Some(last) = self.state.history.last() else {
                    self.state
                        .trace
                        .push(TraceEvent::Info("mutate: no last played card".to_string()));
                    return;
                };

                let Some(target) = self
                    .state
                    .collection
                    .iter_mut()
                    .find(|c| c.id == last.card_id)
                else {
                    self.state.trace.push(TraceEvent::Info(
                        "mutate: last played card not in deck".to_string(),
                    ));
                    return;
                };

                if let Some(new_def) = cards::catalog().choose(&mut self.rng) {
                    let old = target.def_id.clone();
                    target.def_id = new_def.id.to_string();
                    self.state.trace.push(TraceEvent::Info(format!(
                        "mutate: {} → {}",
                        old, target.def_id
                    )));
                }
            }
        }
    }
}

#[derive(Debug, Clone, Copy)]
struct Snapshot {
    score: i64,
    bankroll: i64,
    acc: i64,
    len_source: i64,
    len_deck: i64,
    len_hand: i64,
}

impl Snapshot {
    fn capture(state: &GameState) -> Self {
        Self {
            score: state.score,
            bankroll: state.bankroll,
            acc: state.acc,
            len_source: state.deck.len() as i64,
            len_deck: state.collection.len() as i64,
            len_hand: state.hand.len() as i64,
        }
    }

    fn delta_from(self, before: Snapshot) -> crate::game::trace::StateDelta {
        crate::game::trace::StateDelta {
            score: self.score - before.score,
            bankroll: self.bankroll - before.bankroll,
            acc: self.acc - before.acc,
            len_source: self.len_source - before.len_source,
            len_deck: self.len_deck - before.len_deck,
            len_hand: self.len_hand - before.len_hand,
        }
    }
}

fn take_at<T>(v: &mut Vec<T>, index: usize) -> Option<T> {
    if index >= v.len() {
        return None;
    }
    Some(v.remove(index))
}

fn move_within<T>(v: &mut Vec<T>, from: usize, to: usize) {
    if from >= v.len() || from == to {
        return;
    }
    let item = v.remove(from);
    // Allow "insert at end" by clamping to the new len (after removal).
    let to = to.min(v.len());
    v.insert(to, item);
}

fn swap_within<T>(v: &mut Vec<T>, a: usize, b: usize) {
    if a >= v.len() || b >= v.len() || a == b {
        return;
    }
    v.swap(a, b);
}

struct GameCtx<'a> {
    state: &'a GameState,
}

impl VmContext for GameCtx<'_> {
    fn get(&self, name: &str) -> Option<i64> {
        match name {
            // Terminology:
            // - "deck" is the player's owned deck (selection pool)
            // - "source" is the generator/draw pile we pull new cards from
            "len_deck" | "len_pool" | "len_collection" => Some(self.state.collection.len() as i64),
            "len_source" | "len_draw" => Some(self.state.deck.len() as i64),
            "len_hand" => Some(self.state.hand.len() as i64),
            "len_discard" => Some(self.state.discard.len() as i64),
            "deck" => Some(self.state.collection.len() as i64),
            "hand" => Some(self.state.hand.len() as i64),
            "lvl" => Some(self.state.level as i64),
            "acc" => Some(self.state.acc),
            "score" => Some(self.state.score),
            "bankroll" => Some(self.state.bankroll),
            "level" => Some(self.state.level as i64),
            "target" => Some(self.state.target_score),
            "max_step" | "max_steps" => Some(self.state.limits.max_steps as i64),
            "max_loop" | "max_loop_iters" => Some(self.state.limits.max_loop_iters as i64),
            _ => None,
        }
    }
}

fn expr_to_string(expr: &crate::kardlang::Expr) -> String {
    use crate::kardlang::{BinOp, Expr};
    match expr {
        Expr::Int(n, _) => n.to_string(),
        Expr::Var(name, _) => name.clone(),
        Expr::Group(inner, _) => format!("({})", expr_to_string(inner)),
        Expr::Binary { op, lhs, rhs, .. } => {
            let op_str = match op {
                BinOp::Add => "+",
                BinOp::Mul => "*",
            };
            format!("{}{}{}", expr_to_string(lhs), op_str, expr_to_string(rhs))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn draw_then_play_applies_effects_and_returns_cards_to_deck() {
        let deck = vec![CardInstance::new(1, "score_2")];
        let mut engine = Engine::with_deck(123, deck, Limits::default());

        engine
            .dispatch(Action::DrawToCollection { count: 1 })
            .unwrap();
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);

        engine
            .dispatch(Action::MoveCollectionToHand { index: 0 })
            .unwrap();
        assert_eq!(engine.state.hand.len(), 1);

        engine.dispatch(Action::PlayHand).unwrap();
        assert_eq!(engine.state.score, 2);
        assert_eq!(engine.state.hand.len(), 0);
        assert_eq!(engine.state.collection.len(), 1);
        assert_eq!(engine.state.discard.len(), 0);
    }

    #[test]
    fn engine_new_starts_with_starter_deck() {
        let engine = Engine::new(0);
        let expected = cards::starter_deck_ids().len();
        assert_eq!(engine.state.collection.len(), expected);
        assert_eq!(engine.state.hand.len(), 0);

        for c in &engine.state.collection {
            assert!(
                c.def().is_some(),
                "starter card def missing for id={}",
                c.def_id
            );
        }
    }
}



```

```rust
*** Begin Patch
*** Update File: src/ui/views/sidebar.rs
@@
-    let c1 = if focused && focus_index == 1 {
-        "btn secondary focused"
-    } else {
-        "btn secondary"
-    };
-    let c2 = if focused && focus_index == 2 {
-        "btn focused"
-    } else {
-        "btn"
-    };
+    let c1 = if focused && focus_index == 1 {
+        "btn secondary focused"
+    } else {
+        "btn secondary"
+    };
@@
     if tab_value == SidebarTab::Controls {
         div { class: "panel sidebar-panel",
             h3 { "Run" }
             button {
-                class: "{c0}",
+                class: if focused && focus_index == 0 { "btn danger focused" } else { "btn danger" },
+                title: "Warning: resets your run state",
                 onclick: move |_| {
                     let mut eng = engine.write();
                     if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                         eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                     }
                 },
                 "Reset game"
             }
             button {
-                class: "{c1}",
+                class: "{c1}",
                 onclick: move |_| {
                     kardinomicon_target.set(None);
                     kardinomicon_open.set(true);
                 },
                 "Open docs"
             }
         }
*** End Patch
```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
    focused: bool,
    focus_index: usize,
) -> Element {
    let tab_value = tab();
    let cur_settings = settings();

    // Sidebar focus highlight (used for keyboard/controller navigation).
    let c0 = if focused && focus_index == 0 {
        "btn focused"
    } else {
        "btn"
    };
    let c1 = if focused && focus_index == 1 {
        "btn secondary focused"
    } else {
        "btn secondary"
    };
    let c2 = if focused && focus_index == 2 {
        "btn focused"
    } else {
        "btn"
    };

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: if focused && focus_index == 0 { "btn danger focused" } else { "btn danger" },
                        title: "Warning: resets your run state",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Reset game"
                    }
                    button {
                        class: if focused && focus_index == 1 { "btn secondary focused" } else { "btn secondary" },
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                        "Open docs"
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
            button {
                class: "btn danger",
                onclick: move |_| {
                    let mut eng = engine.write();
                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                },
                "Clear trace"
            }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Assemble a hand and execute." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }

        div { class: "panel sidebar-panel",
            h3 { "Telemetry" }
            div { class: "kv", span { "Source" } code { "{state.deck.len()}" } }
            div { class: "kv", span { "Deck" } code { "{state.collection.len()}" } }
            div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
            div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
            div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
            div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
        }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur_settings.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur_settings.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur_settings.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 1usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(1));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    DeckWidget {
                        deck_count,
                        discard_count,
                        collection_count,
                        hand_count,
                        level: state.level,
                        target: state.target_score,
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Deck {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Hand"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Hand {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Deck"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 1usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(1));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    div { class: "right-rail",
                        button {
                            class: "play-btn",
                            onclick: move |_| {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                }
                                anim::play_flip(before, 360.0);
                            },
                            span { class: "play-icon", "▶" }
                            span { class: "play-text", "Play Hand" }
                        }

                        DeckWidget {
                            deck_count,
                            discard_count,
                            collection_count,
                            hand_count,
                            level: state.level,
                            target: state.target_score,
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Deck {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Hand);
                                        sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Hand"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Hand {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Deck"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
*** Begin Patch
*** Update File: src/ui/app.rs
@@
                 div { class: "handbar",
@@
                     if state.hand.is_empty() {
-                        div {
-                            class: "empty dropzone",
-                            ondragover: move |evt| evt.prevent_default(),
-                            ondrop: move |evt| {
-                                evt.prevent_default();
-                                if let Some(payload) = drag() {
-                                    let before = {
-                                        let st = engine.read();
-                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
-                                        anim::capture_rects(&ids)
-                                    };
-                                    let mut eng = engine.write();
-                                    if payload.zone == FocusZone::Deck {
-                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
-                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
-                                        }
-                                        focus.set(FocusZone::Hand);
-                                        sel_hand.set(eng.state.hand.len().saturating_sub(1));
-                                    }
-                                    anim::play_flip(before, 280.0);
-                                }
-                                drag.set(None);
-                            },
-                            "Drop here to add to Hand"
-                        }
+                        div { class: "row-scroll",
+                            div { class: "row",
+                                div {
+                                    class: "ghost-card dropzone",
+                                    ondragover: move |evt| evt.prevent_default(),
+                                    ondrop: move |evt| {
+                                        evt.prevent_default();
+                                        if let Some(payload) = drag() {
+                                            let before = {
+                                                let st = engine.read();
+                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
+                                                anim::capture_rects(&ids)
+                                            };
+                                            let mut eng = engine.write();
+                                            if payload.zone == FocusZone::Deck {
+                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
+                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
+                                                }
+                                                focus.set(FocusZone::Hand);
+                                                sel_hand.set(eng.state.hand.len().saturating_sub(1));
+                                            }
+                                            anim::play_flip(before, 280.0);
+                                        }
+                                        drag.set(None);
+                                    },
+                                    div { class: "ghost-plus", "+" }
+                                    div { class: "ghost-hint", "Drop to add" }
+                                }
+                            }
+                        }
                     } else {
                         div {
                             class: "row-scroll",
@@
-                            div { class: "row",
-                                for (i, card) in state.hand.iter().cloned().enumerate() {
+                            div { class: "row",
+                                // Insert slots (between cards) + swap-on-card drops.
+                                for slot in 0..=state.hand.len() {
+                                    div {
+                                        key: "hand-slot-{slot}",
+                                        class: "drop-slot",
+                                        ondragover: move |evt| evt.prevent_default(),
+                                        ondrop: move |evt| {
+                                            evt.prevent_default();
+                                            if let Some(payload) = drag() {
+                                                let before = {
+                                                    let st = engine.read();
+                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
+                                                    anim::capture_rects(&ids)
+                                                };
+                                                let mut eng = engine.write();
+                                                match payload.zone {
+                                                    FocusZone::Hand => {
+                                                        let mut to = slot;
+                                                        if payload.index < to { to = to.saturating_sub(1); }
+                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
+                                                        focus.set(FocusZone::Hand);
+                                                        sel_hand.set(to.min(eng.state.hand.len().saturating_sub(1)));
+                                                    }
+                                                    FocusZone::Deck => {
+                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
+                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
+                                                        }
+                                                        let from = eng.state.hand.len().saturating_sub(1);
+                                                        let to = slot.min(from);
+                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
+                                                        focus.set(FocusZone::Hand);
+                                                        sel_hand.set(to);
+                                                    }
+                                                    FocusZone::Sidebar => {}
+                                                }
+                                                anim::play_flip(before, 320.0);
+                                            }
+                                            drag.set(None);
+                                        }
+                                    }
+                                    if slot < state.hand.len() {
+                                        let i = slot;
+                                        let card = state.hand[i].clone();
                                     crate::ui::views::CardView {
                                         index: i,
                                         card,
                                         selected: focus_value == FocusZone::Hand && selected_hand == i,
                                         primary_icon: "↓",
                                         on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                         on_primary: move |idx| {
@@
                                         on_drop: move |drop_idx| {
                                             if let Some(payload) = drag() {
                                                 let before = {
                                                     let st = engine.read();
                                                     let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                     anim::capture_rects(&ids)
                                                 };
                                                 let mut eng = engine.write();
                                                 match payload.zone {
                                                     FocusZone::Hand => {
-                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
+                                                        // Drop on card => swap positions.
+                                                        let _ = eng.dispatch(kardinality::Action::SwapHand { a: payload.index, b: drop_idx });
                                                         focus.set(FocusZone::Hand);
                                                         sel_hand.set(drop_idx);
                                                     }
                                                     FocusZone::Deck => {
                                                         if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                             eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                         }
                                                         let from = eng.state.hand.len().saturating_sub(1);
                                                         let to = drop_idx.min(from);
                                                         let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                         focus.set(FocusZone::Hand);
                                                         sel_hand.set(to);
                                                     }
                                                     FocusZone::Sidebar => {}
                                                 }
                                                 anim::play_flip(before, 280.0);
                                             }
                                             drag.set(None);
                                         },
                                     }
+                                    }
                                 }
                             }
                         }
                     }
                 }
@@
                 div { class: "deckbar",
@@
                     if state.collection.is_empty() {
-                        div {
-                            class: "empty dropzone",
+                        div { class: "row-scroll",
+                            div { class: "row",
+                                div {
+                                    class: "ghost-card dropzone",
                             ondragover: move |evt| evt.prevent_default(),
                             ondrop: move |evt| {
                                 evt.prevent_default();
                                 if let Some(payload) = drag() {
                                     let before = {
                                         let st = engine.read();
                                         let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                         anim::capture_rects(&ids)
                                     };
                                     let mut eng = engine.write();
                                     if payload.zone == FocusZone::Hand {
                                         if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                             eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                         }
                                         focus.set(FocusZone::Deck);
                                         sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                     }
                                     anim::play_flip(before, 280.0);
                                 }
                                 drag.set(None);
                             },
-                            "Drop here to add to Deck"
+                                    div { class: "ghost-plus", "+" }
+                                    div { class: "ghost-hint", "Drop to add" }
+                                }
+                            }
+                        }
                     } else {
                         div {
                             class: "row-scroll",
@@
-                            div { class: "row",
-                                for (i, card) in state.collection.iter().cloned().enumerate() {
+                            div { class: "row",
+                                for slot in 0..=state.collection.len() {
+                                    div {
+                                        key: "deck-slot-{slot}",
+                                        class: "drop-slot",
+                                        ondragover: move |evt| evt.prevent_default(),
+                                        ondrop: move |evt| {
+                                            evt.prevent_default();
+                                            if let Some(payload) = drag() {
+                                                let before = {
+                                                    let st = engine.read();
+                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
+                                                    anim::capture_rects(&ids)
+                                                };
+                                                let mut eng = engine.write();
+                                                match payload.zone {
+                                                    FocusZone::Deck => {
+                                                        let mut to = slot;
+                                                        if payload.index < to { to = to.saturating_sub(1); }
+                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
+                                                        focus.set(FocusZone::Deck);
+                                                        sel_collection.set(to.min(eng.state.collection.len().saturating_sub(1)));
+                                                    }
+                                                    FocusZone::Hand => {
+                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
+                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
+                                                        }
+                                                        let from = eng.state.collection.len().saturating_sub(1);
+                                                        let to = slot.min(from);
+                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
+                                                        focus.set(FocusZone::Deck);
+                                                        sel_collection.set(to);
+                                                    }
+                                                    FocusZone::Sidebar => {}
+                                                }
+                                                anim::play_flip(before, 320.0);
+                                            }
+                                            drag.set(None);
+                                        }
+                                    }
+                                    if slot < state.collection.len() {
+                                        let i = slot;
+                                        let card = state.collection[i].clone();
                                     crate::ui::views::CardView {
                                         index: i,
                                         card,
                                         selected: focus_value == FocusZone::Deck && selected_collection == i,
                                         primary_icon: "↑",
@@
                                         on_drop: move |drop_idx| {
                                             if let Some(payload) = drag() {
                                                 let before = {
                                                     let st = engine.read();
                                                     let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                     anim::capture_rects(&ids)
                                                 };
                                                 let mut eng = engine.write();
                                                 match payload.zone {
                                                     FocusZone::Deck => {
-                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
+                                                        // Drop on card => swap positions.
+                                                        let _ = eng.dispatch(kardinality::Action::SwapCollection { a: payload.index, b: drop_idx });
                                                         focus.set(FocusZone::Deck);
                                                         sel_collection.set(drop_idx);
                                                     }
                                                     FocusZone::Hand => {
                                                         if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                             eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                         }
                                                         let from = eng.state.collection.len().saturating_sub(1);
                                                         let to = drop_idx.min(from);
                                                         let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                         focus.set(FocusZone::Deck);
                                                         sel_collection.set(to);
                                                     }
                                                     FocusZone::Sidebar => {}
                                                 }
                                                 anim::play_flip(before, 280.0);
                                             }
                                             drag.set(None);
                                         },
                                     }
+                                    }
                                 }
                             }
                         }
                     }
                 }
*** End Patch
```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 1usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(1));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    div { class: "right-rail",
                        button {
                            class: "play-btn",
                            onclick: move |_| {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                }
                                anim::play_flip(before, 360.0);
                            },
                            span { class: "play-icon", "▶" }
                            span { class: "play-text", "Play Hand" }
                        }

                        DeckWidget {
                            deck_count,
                            discard_count,
                            collection_count,
                            hand_count,
                            level: state.level,
                            target: state.target_score,
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Deck {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.hand.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Hand && selected_hand == i,
                                        primary_icon: "↓",
                                        on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                        on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Hand {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Deck"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 1usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(1));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    div { class: "right-rail",
                        button {
                            class: "play-btn",
                            onclick: move |_| {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                }
                                anim::play_flip(before, 360.0);
                            },
                            span { class: "play-icon", "▶" }
                            span { class: "play-text", "Play Hand" }
                        }

                        DeckWidget {
                            deck_count,
                            discard_count,
                            collection_count,
                            hand_count,
                            level: state.level,
                            target: state.target_score,
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Deck {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                // Drop slots allow inserting between cards. Dropping onto a card swaps.
                                for slot in 0..=state.hand.len() {
                                    div {
                                        key: "hand-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to.min(eng.state.hand.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.hand.len() {
                                        let i = slot;
                                        let card = state.hand[i].clone();
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Hand && selected_hand == i,
                                            primary_icon: "↓",
                                            on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapHand { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div {
                            class: "empty dropzone",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    if payload.zone == FocusZone::Hand {
                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                        }
                                        focus.set(FocusZone::Deck);
                                        sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            "Drop here to add to Deck"
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for (i, card) in state.collection.iter().cloned().enumerate() {
                                    crate::ui::views::CardView {
                                        index: i,
                                        card,
                                        selected: focus_value == FocusZone::Deck && selected_collection == i,
                                        primary_icon: "↑",
                                        on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                        on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                        on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                        },
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 1usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(1));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    div { class: "right-rail",
                        button {
                            class: "play-btn",
                            onclick: move |_| {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                }
                                anim::play_flip(before, 360.0);
                            },
                            span { class: "play-icon", "▶" }
                            span { class: "play-text", "Play Hand" }
                        }

                        DeckWidget {
                            deck_count,
                            discard_count,
                            collection_count,
                            hand_count,
                            level: state.level,
                            target: state.target_score,
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Deck {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                // Drop slots allow inserting between cards. Dropping onto a card swaps.
                                for slot in 0..=state.hand.len() {
                                    div {
                                        key: "hand-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to.min(eng.state.hand.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.hand.len() {
                                        let i = slot;
                                        let card = state.hand[i].clone();
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Hand && selected_hand == i,
                                            primary_icon: "↓",
                                            on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapHand { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Hand {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for slot in 0..=state.collection.len() {
                                    div {
                                        key: "deck-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to.min(eng.state.collection.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.collection.len() {
                                        let i = slot;
                                        let card = state.collection[i].clone();
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapCollection { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
*** Begin Patch
*** Update File: src/ui/theme.rs
@@
 .topbar {
   display: flex;
   gap: 14px;
   align-items: stretch;
 }
 
+.right-rail {
+  width: 238px;
+  display: grid;
+  grid-template-rows: auto 1fr;
+  gap: 12px;
+}
+
+.play-btn {
+  width: 238px;
+  border-radius: 16px;
+  border: 1px solid rgba(0, 255, 156, 0.42);
+  background:
+    radial-gradient(240px 140px at 20% 20%, rgba(0, 255, 156, 0.22), transparent 60%),
+    linear-gradient(180deg, rgba(0, 0, 0, 0.10), rgba(0, 0, 0, 0.30));
+  box-shadow: 0 18px 50px rgba(0, 0, 0, 0.52), 0 0 44px rgba(0, 255, 156, 0.18);
+  color: rgba(238, 255, 248, 0.96);
+  padding: 12px 14px;
+  cursor: pointer;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  gap: 10px;
+  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease, filter 140ms ease;
+}
+.play-btn:hover {
+  transform: translateY(-1px) scale(1.01);
+  border-color: rgba(0, 255, 156, 0.62);
+  box-shadow: 0 22px 60px rgba(0, 0, 0, 0.55), 0 0 64px rgba(0, 255, 156, 0.28);
+  filter: saturate(1.12) contrast(1.08);
+}
+.play-btn:active {
+  transform: translateY(0px) scale(0.99);
+}
+.play-icon {
+  font-size: 18px;
+  color: rgba(0, 255, 156, 0.95);
+  text-shadow: 0 0 22px rgba(0, 255, 156, 0.35);
+}
+.play-text {
+  font-size: 14px;
+  letter-spacing: 0.4px;
+  text-transform: uppercase;
+}
+
 .row-scroll {
   overflow-x: scroll;
   overflow-y: visible;
   padding-top: 10px;
   padding-bottom: 10px;
   scrollbar-gutter: stable both-edges;
   scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
 }
 
+.drop-slot {
+  width: 18px;
+  height: 242px;
+  border-radius: 10px;
+  border: 1px dashed rgba(0, 255, 156, 0.00);
+  background: rgba(0, 0, 0, 0.00);
+  transition: border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
+}
+.drop-slot:hover {
+  border-color: rgba(0, 255, 156, 0.38);
+  background: rgba(0, 255, 156, 0.04);
+  box-shadow: 0 0 22px rgba(0, 255, 156, 0.10);
+}
+
+.ghost-card {
+  width: 176px;
+  min-width: 176px;
+  height: 242px;
+  border-radius: 18px;
+  border: 1px dashed rgba(0, 255, 156, 0.30);
+  background:
+    radial-gradient(220px 160px at 50% 30%, rgba(0, 255, 156, 0.06), transparent 60%),
+    linear-gradient(135deg, rgba(0, 255, 156, 0.04), rgba(0, 200, 255, 0.02) 35%, rgba(0, 0, 0, 0.18));
+  display: grid;
+  place-items: center;
+  gap: 8px;
+  color: rgba(238, 255, 248, 0.72);
+  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
+  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
+}
+.ghost-card:hover {
+  transform: translateY(-2px);
+  border-color: rgba(0, 255, 156, 0.55);
+  box-shadow: 0 24px 56px rgba(0, 0, 0, 0.46), 0 0 44px rgba(0, 255, 156, 0.14);
+}
+.ghost-plus {
+  width: 44px;
+  height: 44px;
+  border-radius: 999px;
+  display: grid;
+  place-items: center;
+  border: 1px solid rgba(0, 255, 156, 0.32);
+  background: rgba(0, 0, 0, 0.22);
+  font-size: 24px;
+  color: rgba(0, 255, 156, 0.88);
+  text-shadow: 0 0 22px rgba(0, 255, 156, 0.25);
+}
+.ghost-hint {
+  font-size: 12px;
+  color: rgba(238, 255, 248, 0.62);
+}
+
@@
 .app.theme-crt:not(.effects-off) {
-  filter: contrast(1.10) saturate(1.18);
-  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
+  filter: contrast(1.22) saturate(1.34) brightness(1.06);
+  transform: perspective(1100px) rotateX(0.95deg) rotateY(-0.85deg) scale(1.02);
   transform-origin: 50% 50%;
   will-change: transform, filter;
 }
@@
 .app.theme-crt:not(.effects-off)::before {
-  opacity: 0.26;
+  opacity: 0.60;
   background:
     repeating-linear-gradient(
       to bottom,
-      rgba(255, 255, 255, 0.045),
-      rgba(255, 255, 255, 0.045) 1px,
+      rgba(255, 255, 255, 0.090),
+      rgba(255, 255, 255, 0.090) 1px,
       rgba(0, 0, 0, 0.00) 2px,
-      rgba(0, 0, 0, 0.00) 4px
+      rgba(0, 0, 0, 0.00) 5px
     ),
     repeating-linear-gradient(
       to right,
-      rgba(255, 0, 0, 0.020),
-      rgba(255, 0, 0, 0.020) 1px,
-      rgba(0, 255, 0, 0.018) 2px,
-      rgba(0, 0, 255, 0.020) 3px
+      rgba(255, 0, 0, 0.045),
+      rgba(255, 0, 0, 0.045) 1px,
+      rgba(0, 255, 0, 0.040) 2px,
+      rgba(0, 0, 255, 0.045) 3px
     );
-  animation: scanlines 7.2s linear infinite;
+  mix-blend-mode: screen;
+  animation: scanlines 3.4s linear infinite;
 }
@@
 .app.theme-crt:not(.effects-off)::after {
   background:
     radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
-    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
-    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
-    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
-  opacity: 0.94;
-  animation: flicker 2.6s infinite steps(60);
+    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.080), transparent 60%),
+    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.060), transparent 62%),
+    linear-gradient(90deg, rgba(0, 255, 156, 0.06), rgba(0, 200, 255, 0.03));
+  opacity: 0.98;
+  mix-blend-mode: overlay;
+  animation: flicker 1.6s infinite steps(40);
 }
*** End Patch
```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.10) saturate(1.18);
  transform: perspective(1400px) rotateX(0.45deg) rotateY(-0.35deg) scale(1.01);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.26;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.045),
      rgba(255, 255, 255, 0.045) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.020),
      rgba(255, 0, 0, 0.020) 1px,
      rgba(0, 255, 0, 0.018) 2px,
      rgba(0, 0, 255, 0.020) 3px
    );
  animation: scanlines 7.2s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.035), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.028), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.94;
  animation: flicker 2.6s infinite steps(60);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.right-rail {
  width: 238px;
  display: grid;
  grid-template-rows: auto 1fr;
  gap: 12px;
}

.play-btn {
  width: 238px;
  border-radius: 16px;
  border: 1px solid rgba(0, 255, 156, 0.42);
  background:
    radial-gradient(240px 140px at 20% 20%, rgba(0, 255, 156, 0.22), transparent 60%),
    linear-gradient(180deg, rgba(0, 0, 0, 0.10), rgba(0, 0, 0, 0.30));
  box-shadow: 0 18px 50px rgba(0, 0, 0, 0.52), 0 0 44px rgba(0, 255, 156, 0.18);
  color: rgba(238, 255, 248, 0.96);
  padding: 12px 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease, filter 140ms ease;
}
.play-btn:hover {
  transform: translateY(-1px) scale(1.01);
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 22px 60px rgba(0, 0, 0, 0.55), 0 0 64px rgba(0, 255, 156, 0.28);
  filter: saturate(1.12) contrast(1.08);
}
.play-btn:active {
  transform: translateY(0px) scale(0.99);
}
.play-icon {
  font-size: 18px;
  color: rgba(0, 255, 156, 0.95);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.35);
}
.play-text {
  font-size: 14px;
  letter-spacing: 0.4px;
  text-transform: uppercase;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 8px 10px 8px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 26px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 10px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 8px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 76px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 8px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
  min-height: 0;
  position: relative;
  z-index: 8;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  position: relative;
  z-index: 10;
  min-height: 0;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: scroll;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 10px;
  scrollbar-gutter: stable both-edges;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.drop-slot {
  width: 18px;
  height: 242px;
  border-radius: 10px;
  border: 1px dashed rgba(0, 255, 156, 0.00);
  background: rgba(0, 0, 0, 0.00);
  transition: border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}
.drop-slot:hover {
  border-color: rgba(0, 255, 156, 0.38);
  background: rgba(0, 255, 156, 0.04);
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.10);
}

.ghost-card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px dashed rgba(0, 255, 156, 0.30);
  background:
    radial-gradient(220px 160px at 50% 30%, rgba(0, 255, 156, 0.06), transparent 60%),
    linear-gradient(135deg, rgba(0, 255, 156, 0.04), rgba(0, 200, 255, 0.02) 35%, rgba(0, 0, 0, 0.18));
  display: grid;
  place-items: center;
  gap: 8px;
  color: rgba(238, 255, 248, 0.72);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
}
.ghost-card:hover {
  transform: translateY(-2px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 24px 56px rgba(0, 0, 0, 0.46), 0 0 44px rgba(0, 255, 156, 0.14);
}
.ghost-plus {
  width: 44px;
  height: 44px;
  border-radius: 999px;
  display: grid;
  place-items: center;
  border: 1px solid rgba(0, 255, 156, 0.32);
  background: rgba(0, 0, 0, 0.22);
  font-size: 24px;
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.25);
}
.ghost-hint {
  font-size: 12px;
  color: rgba(238, 255, 248, 0.62);
}

.row-scroll::-webkit-scrollbar {
  height: 10px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-fn {
  color: rgba(255, 158, 0, 0.92);
  text-shadow: 0 0 14px rgba(255, 158, 0, 0.12);
}

.tok-reg {
  color: rgba(0, 200, 255, 0.94);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-acc {
  color: rgba(255, 77, 255, 0.92);
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.empty.dropzone {
  border-radius: 14px;
  border: 1px dashed rgba(0, 255, 156, 0.20);
  background: rgba(0, 0, 0, 0.14);
  cursor: copy;
  text-align: center;
  padding: 18px 12px;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}
.empty.dropzone:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.34);
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.10);
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.22) saturate(1.34) brightness(1.06);
  transform: perspective(1100px) rotateX(0.95deg) rotateY(-0.85deg) scale(1.02);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.60;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.090),
      rgba(255, 255, 255, 0.090) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 5px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.045),
      rgba(255, 0, 0, 0.045) 1px,
      rgba(0, 255, 0, 0.040) 2px,
      rgba(0, 0, 255, 0.045) 3px
    );
  mix-blend-mode: screen;
  animation: scanlines 3.4s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.080), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.060), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.06), rgba(0, 200, 255, 0.03));
  opacity: 0.98;
  mix-blend-mode: overlay;
  animation: flicker 1.6s infinite steps(40);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.right-rail {
  width: 238px;
  display: grid;
  grid-template-rows: auto 1fr;
  gap: 12px;
}

.play-btn {
  width: 238px;
  border-radius: 16px;
  border: 1px solid rgba(0, 255, 156, 0.42);
  background:
    radial-gradient(240px 140px at 20% 20%, rgba(0, 255, 156, 0.22), transparent 60%),
    linear-gradient(180deg, rgba(0, 0, 0, 0.10), rgba(0, 0, 0, 0.30));
  box-shadow: 0 18px 50px rgba(0, 0, 0, 0.52), 0 0 44px rgba(0, 255, 156, 0.18);
  color: rgba(238, 255, 248, 0.96);
  padding: 12px 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease, filter 140ms ease;
}
.play-btn:hover {
  transform: translateY(-1px) scale(1.01);
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 22px 60px rgba(0, 0, 0, 0.55), 0 0 64px rgba(0, 255, 156, 0.28);
  filter: saturate(1.12) contrast(1.08);
}
.play-btn:active {
  transform: translateY(0px) scale(0.99);
}
.play-icon {
  font-size: 18px;
  color: rgba(0, 255, 156, 0.95);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.35);
}
.play-text {
  font-size: 14px;
  letter-spacing: 0.4px;
  text-transform: uppercase;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 8px 10px 8px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 26px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 10px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 8px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 76px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 8px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
  min-height: 0;
  position: relative;
  z-index: 8;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  position: relative;
  z-index: 10;
  min-height: 0;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: scroll;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 10px;
  scrollbar-gutter: stable both-edges;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.drop-slot {
  width: 18px;
  height: 242px;
  border-radius: 10px;
  border: 1px dashed rgba(0, 255, 156, 0.00);
  background: rgba(0, 0, 0, 0.00);
  transition: border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}
.drop-slot:hover {
  border-color: rgba(0, 255, 156, 0.38);
  background: rgba(0, 255, 156, 0.04);
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.10);
}

.ghost-card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px dashed rgba(0, 255, 156, 0.30);
  background:
    radial-gradient(220px 160px at 50% 30%, rgba(0, 255, 156, 0.06), transparent 60%),
    linear-gradient(135deg, rgba(0, 255, 156, 0.04), rgba(0, 200, 255, 0.02) 35%, rgba(0, 0, 0, 0.18));
  display: grid;
  place-items: center;
  gap: 8px;
  color: rgba(238, 255, 248, 0.72);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
}
.ghost-card:hover {
  transform: translateY(-2px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 24px 56px rgba(0, 0, 0, 0.46), 0 0 44px rgba(0, 255, 156, 0.14);
}
.ghost-plus {
  width: 44px;
  height: 44px;
  border-radius: 999px;
  display: grid;
  place-items: center;
  border: 1px solid rgba(0, 255, 156, 0.32);
  background: rgba(0, 0, 0, 0.22);
  font-size: 24px;
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.25);
}
.ghost-hint {
  font-size: 12px;
  color: rgba(238, 255, 248, 0.62);
}

.row-scroll::-webkit-scrollbar {
  height: 10px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-fn {
  color: rgba(255, 158, 0, 0.92);
  text-shadow: 0 0 14px rgba(255, 158, 0, 0.12);
}

.tok-reg {
  color: rgba(0, 200, 255, 0.94);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-acc {
  color: rgba(255, 77, 255, 0.92);
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

.empty.dropzone {
  border-radius: 14px;
  border: 1px dashed rgba(0, 255, 156, 0.20);
  background: rgba(0, 0, 0, 0.14);
  cursor: copy;
  text-align: center;
  padding: 18px 12px;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}
.empty.dropzone:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.34);
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.10);
}

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.22) saturate(1.34) brightness(1.06);
  transform: perspective(1100px) rotateX(0.95deg) rotateY(-0.85deg) scale(1.02);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.60;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.090),
      rgba(255, 255, 255, 0.090) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 5px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.045),
      rgba(255, 0, 0, 0.045) 1px,
      rgba(0, 255, 0, 0.040) 2px,
      rgba(0, 0, 255, 0.045) 3px
    );
  mix-blend-mode: screen;
  animation: scanlines 3.4s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.080), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.060), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.06), rgba(0, 200, 255, 0.03));
  opacity: 0.98;
  mix-blend-mode: overlay;
  animation: flicker 1.6s infinite steps(40);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.right-rail {
  width: 238px;
  display: grid;
  grid-template-rows: auto 1fr;
  gap: 12px;
}

.play-btn {
  width: 238px;
  border-radius: 16px;
  border: 1px solid rgba(0, 255, 156, 0.42);
  background:
    radial-gradient(240px 140px at 20% 20%, rgba(0, 255, 156, 0.22), transparent 60%),
    linear-gradient(180deg, rgba(0, 0, 0, 0.10), rgba(0, 0, 0, 0.30));
  box-shadow: 0 18px 50px rgba(0, 0, 0, 0.52), 0 0 44px rgba(0, 255, 156, 0.18);
  color: rgba(238, 255, 248, 0.96);
  padding: 12px 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease, filter 140ms ease;
}
.play-btn:hover {
  transform: translateY(-1px) scale(1.01);
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 22px 60px rgba(0, 0, 0, 0.55), 0 0 64px rgba(0, 255, 156, 0.28);
  filter: saturate(1.12) contrast(1.08);
}
.play-btn:active {
  transform: translateY(0px) scale(0.99);
}
.play-icon {
  font-size: 18px;
  color: rgba(0, 255, 156, 0.95);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.35);
}
.play-text {
  font-size: 14px;
  letter-spacing: 0.4px;
  text-transform: uppercase;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 8px 10px 8px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 26px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 10px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 8px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 76px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 8px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
  min-height: 0;
  position: relative;
  z-index: 8;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  position: relative;
  z-index: 10;
  min-height: 0;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: scroll;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 10px;
  scrollbar-gutter: stable both-edges;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.drop-slot {
  width: 18px;
  height: 242px;
  border-radius: 10px;
  border: 1px dashed rgba(0, 255, 156, 0.00);
  background: rgba(0, 0, 0, 0.00);
  transition: border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}
.drop-slot:hover {
  border-color: rgba(0, 255, 156, 0.38);
  background: rgba(0, 255, 156, 0.04);
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.10);
}

.ghost-card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px dashed rgba(0, 255, 156, 0.30);
  background:
    radial-gradient(220px 160px at 50% 30%, rgba(0, 255, 156, 0.06), transparent 60%),
    linear-gradient(135deg, rgba(0, 255, 156, 0.04), rgba(0, 200, 255, 0.02) 35%, rgba(0, 0, 0, 0.18));
  display: grid;
  place-items: center;
  gap: 8px;
  color: rgba(238, 255, 248, 0.72);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
}
.ghost-card:hover {
  transform: translateY(-2px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 24px 56px rgba(0, 0, 0, 0.46), 0 0 44px rgba(0, 255, 156, 0.14);
}
.ghost-plus {
  width: 44px;
  height: 44px;
  border-radius: 999px;
  display: grid;
  place-items: center;
  border: 1px solid rgba(0, 255, 156, 0.32);
  background: rgba(0, 0, 0, 0.22);
  font-size: 24px;
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.25);
}
.ghost-hint {
  font-size: 12px;
  color: rgba(238, 255, 248, 0.62);
}

.row-scroll::-webkit-scrollbar {
  height: 10px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-fn {
  color: rgba(255, 158, 0, 0.92);
  text-shadow: 0 0 14px rgba(255, 158, 0, 0.12);
}

.tok-reg {
  color: rgba(0, 200, 255, 0.94);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-acc {
  color: rgba(255, 77, 255, 0.92);
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

/* Legacy empty dropzones were replaced by ghost-card placeholders to avoid layout jumps. */

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 1usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(1));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    div { class: "right-rail",
                        button {
                            class: "play-btn",
                            onclick: move |_| {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                }
                                anim::play_flip(before, 360.0);
                            },
                            span { class: "play-icon", "▶" }
                            span { class: "play-text", "Play Hand" }
                        }

                        DeckWidget {
                            deck_count,
                            discard_count,
                            collection_count,
                            hand_count,
                            level: state.level,
                            target: state.target_score,
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Deck {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                // Drop slots allow inserting between cards. Dropping onto a card swaps.
                                for slot in 0..=state.hand.len() {
                                    div {
                                        key: "hand-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to.min(eng.state.hand.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.hand.len() {
                                        crate::ui::views::CardView {
                                            index: slot,
                                            card: state.hand[slot].clone(),
                                            selected: focus_value == FocusZone::Hand && selected_hand == slot,
                                            primary_icon: "↓",
                                            on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapHand { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Hand {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for slot in 0..=state.collection.len() {
                                    div {
                                        key: "deck-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to.min(eng.state.collection.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.collection.len() {
                                        let i = slot;
                                        let card = state.collection[i].clone();
                                        crate::ui::views::CardView {
                                            index: i,
                                            card,
                                            selected: focus_value == FocusZone::Deck && selected_collection == i,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapCollection { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 1usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(1));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    div { class: "right-rail",
                        button {
                            class: "play-btn",
                            onclick: move |_| {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                }
                                anim::play_flip(before, 360.0);
                            },
                            span { class: "play-icon", "▶" }
                            span { class: "play-text", "Play Hand" }
                        }

                        DeckWidget {
                            deck_count,
                            discard_count,
                            collection_count,
                            hand_count,
                            level: state.level,
                            target: state.target_score,
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Deck {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                // Drop slots allow inserting between cards. Dropping onto a card swaps.
                                for slot in 0..=state.hand.len() {
                                    div {
                                        key: "hand-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to.min(eng.state.hand.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.hand.len() {
                                        crate::ui::views::CardView {
                                            index: slot,
                                            card: state.hand[slot].clone(),
                                            selected: focus_value == FocusZone::Hand && selected_hand == slot,
                                            primary_icon: "↓",
                                            on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapHand { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Hand {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for slot in 0..=state.collection.len() {
                                    div {
                                        key: "deck-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to.min(eng.state.collection.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.collection.len() {
                                        crate::ui::views::CardView {
                                            index: slot,
                                            card: state.collection[slot].clone(),
                                            selected: focus_value == FocusZone::Deck && selected_collection == slot,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapCollection { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
    focused: bool,
    focus_index: usize,
) -> Element {
    let tab_value = tab();
    let cur_settings = settings();

    // Sidebar focus highlight handled inline for each button (controls are dynamic).

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        class: if focused && focus_index == 0 { "btn danger focused" } else { "btn danger" },
                        title: "Warning: resets your run state",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Reset game"
                    }
                    button {
                        class: if focused && focus_index == 1 { "btn secondary focused" } else { "btn secondary" },
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                        "Open docs"
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
            button {
                class: "btn danger",
                onclick: move |_| {
                    let mut eng = engine.write();
                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                },
                "Clear trace"
            }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Assemble a hand and execute." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }

        div { class: "panel sidebar-panel",
            h3 { "Telemetry" }
            div { class: "kv", span { "Source" } code { "{state.deck.len()}" } }
            div { class: "kv", span { "Deck" } code { "{state.collection.len()}" } }
            div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
            div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
            div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
            div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
        }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur_settings.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur_settings.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur_settings.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

### Shipped UI changes you asked for

#### Sidebar: keep **Reset Game** + **Open Docs**
- **Reset Game is now red + warning** (danger styling + tooltip), and it’s the first/primary control.
- **Open Docs** stays in the left panel.
- **Play Hand removed from sidebar** (it’s now in the main area).

#### Main window: big **Play Hand** button on the right
- Added a **big neon-green “▶ Play Hand”** button in the right rail above the deck widget so it’s super obvious.

#### Empty areas: no layout jump
- Replaced the variable-height “empty dropzone” text blocks with a **fixed-size ghost card outline** (same dimensions as a card) with a **“+”** and “Drop to add”.
- This keeps Hand/Deck sections the same height whether empty or not.

#### Drag/drop behavior: swap on card + insert between cards
- **Drop ON a card → swaps** with that card (same zone).
- **Drop BETWEEN cards → inserts** at that position (works within a zone and cross-zone).
- Implemented by rendering thin **drop slots** between every pair of cards (and at ends).

#### Visual feedback + more CRT
- **Drop slots highlight on hover** (you’ll see where insert will happen).
- **CRT overlay is stronger**: higher contrast/saturation, more visible scanlines + faster flicker.
- (If you want *even more* “glass wobble” and chroma separation, I can push another pass.)

### Files touched
- **Drag/swap/insert + ghost slots + Play button**: `src/ui/app.rs`
- **Swap actions**: `src/game/engine.rs`
- **Sidebar controls**: `src/ui/views/sidebar.rs`
- **CSS (right rail, play button, ghost card, drop slots, stronger CRT)**: `src/ui/theme.rs`

Reload `dx serve` and you should get exactly the behavior in your screenshot goals. If you want the **drop slots to show an actual glowing “insert line”** (not just a highlighted gap), say “make insert line obvious” and I’ll add a vertical neon marker + icon.

---

**User**

Okay, looks pretty good! Except its not centered correctly. Also, when I'm moving them with my keyboard, they go "under" the borders of their containers. Can you make it always on top?

Also, change the kardinomicon layout to be multiple tabs of view, separated by Overview, Functions, Examples, and References

---

**Cursor**

Plan: I’ll fix the layout centering (the empty “ghost card” should be centered), then I’ll make cards always render above their container borders during keyboard/FLIP movement by bumping z-index during animation/selection. After that, I’ll restructure the Kardinomicon modal into 4 tabs: Overview / Functions / Examples / Reference.

Good — I can reproduce both issues from your screenshot: the empty ghost area is left-aligned (needs centering), and the FLIP travel can visually slip “under” panel edges unless we elevate z-index during movement. Next I’ll patch CSS + the FLIP helper, then refactor the Kardinomicon modal into a 4-tab layout.

```rust
pub const CSS: &str = r#"
:root {
  --bg0: #05070c;
  --bg1: #070b12;
  --panel: rgba(10, 14, 20, 0.78);
  --panel2: rgba(8, 11, 16, 0.82);
  --border: rgba(0, 255, 156, 0.24);
  --border-strong: rgba(0, 255, 156, 0.55);
  --accent: #00ff9c;
  --accent2: #00c8ff;
  --danger: #ff4d6d;
  --text: rgba(238, 255, 248, 0.92);
  --muted: rgba(238, 255, 248, 0.66);
  --shadow: rgba(0, 0, 0, 0.55);
  --radius: 16px;
  --radius-sm: 12px;
  --glow: 0 0 12px rgba(0, 255, 156, 0.22), 0 0 44px rgba(0, 200, 255, 0.10);
}

html, body {
  height: 100%;
}

body {
  margin: 0;
  overflow: hidden;
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  background:
    radial-gradient(1200px 900px at 18% 10%, rgba(0, 255, 156, 0.12), transparent 55%),
    radial-gradient(900px 700px at 82% 20%, rgba(0, 200, 255, 0.10), transparent 52%),
    radial-gradient(700px 520px at 60% 110%, rgba(255, 77, 109, 0.06), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
}

* {
  box-sizing: border-box;
}

button, input, select {
  font-family: inherit;
}

.app {
  height: 100vh;
  display: grid;
  grid-template-columns: 308px 1fr;
  position: relative;
}

.app.theme-terminal {
  --accent: #7CFF00;
  --accent2: #00ff9c;
  --bg0: #020402;
  --bg1: #030604;
  --border: rgba(124, 255, 0, 0.22);
  --border-strong: rgba(124, 255, 0, 0.55);
  --glow: 0 0 12px rgba(124, 255, 0, 0.22), 0 0 44px rgba(0, 255, 156, 0.08);
}

.app.theme-magic {
  --accent: #ff4dff;
  --accent2: #7a5cff;
  --bg0: #07030c;
  --bg1: #090417;
  --border: rgba(255, 77, 255, 0.20);
  --border-strong: rgba(255, 77, 255, 0.55);
  --glow: 0 0 14px rgba(255, 77, 255, 0.22), 0 0 54px rgba(122, 92, 255, 0.14);
}

.app.effects-off::before,
.app.effects-off::after {
  display: none;
}

.app.effects-off {
  filter: none;
  transform: none;
}

.app.theme-crt:not(.effects-off) {
  filter: contrast(1.22) saturate(1.34) brightness(1.06);
  transform: perspective(1100px) rotateX(0.95deg) rotateY(-0.85deg) scale(1.02);
  transform-origin: 50% 50%;
  will-change: transform, filter;
}

.app.theme-crt:not(.effects-off)::before {
  opacity: 0.60;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.090),
      rgba(255, 255, 255, 0.090) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 5px
    ),
    repeating-linear-gradient(
      to right,
      rgba(255, 0, 0, 0.045),
      rgba(255, 0, 0, 0.045) 1px,
      rgba(0, 255, 0, 0.040) 2px,
      rgba(0, 0, 255, 0.045) 3px
    );
  mix-blend-mode: screen;
  animation: scanlines 3.4s linear infinite;
}

.app.theme-crt:not(.effects-off)::after {
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 58%, rgba(0, 0, 0, 0.62) 100%),
    radial-gradient(1200px 900px at 50% 50%, rgba(0, 255, 156, 0.080), transparent 60%),
    radial-gradient(1100px 820px at 56% 46%, rgba(0, 200, 255, 0.060), transparent 62%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.06), rgba(0, 200, 255, 0.03));
  opacity: 0.98;
  mix-blend-mode: overlay;
  animation: flicker 1.6s infinite steps(40);
}

.app::before {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.14;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.035),
      rgba(255, 255, 255, 0.035) 1px,
      rgba(0, 0, 0, 0.00) 2px,
      rgba(0, 0, 0, 0.00) 4px
    );
  mix-blend-mode: overlay;
  animation: scanlines 8s linear infinite;
}

.app::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(0, 0, 0, 0.00) 62%, rgba(0, 0, 0, 0.52) 100%),
    linear-gradient(90deg, rgba(0, 255, 156, 0.02), rgba(0, 200, 255, 0.01));
  opacity: 0.9;
  animation: flicker 3.2s infinite steps(60);
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

@keyframes flicker {
  0% { opacity: 0.88; }
  13% { opacity: 0.93; }
  17% { opacity: 0.86; }
  27% { opacity: 0.94; }
  52% { opacity: 0.90; }
  73% { opacity: 0.95; }
  100% { opacity: 0.89; }
}

.sidebar {
  border-right: 1px solid var(--border);
  background:
    linear-gradient(180deg, rgba(9, 12, 18, 0.90), rgba(6, 9, 13, 0.86));
  padding: 18px 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  position: relative;
  z-index: 1;
}

.brand {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.brand-title {
  font-size: 20px;
  letter-spacing: 0.6px;
  text-transform: uppercase;
  margin: 0;
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.22);
}

.brand-subtitle {
  color: var(--muted);
  font-size: 12px;
  letter-spacing: 0.2px;
}

.tabs {
  display: flex;
  gap: 10px;
}

.tab {
  flex: 1;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0, 0, 0, 0.20);
  color: var(--muted);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}

.tab:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.45);
}

.tab.active {
  color: var(--text);
  border-color: var(--border-strong);
  background: rgba(0, 255, 156, 0.08);
  box-shadow: var(--glow);
}

.panel {
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  backdrop-filter: blur(10px);
}

.sidebar-panel {
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.sidebar-panel h3 {
  margin: 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  color: var(--muted);
}

.btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.28);
  background:
    linear-gradient(180deg, rgba(0, 255, 156, 0.14), rgba(0, 0, 0, 0.20));
  color: var(--text);
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
  text-align: left;
}

.btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.56);
  box-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.btn.focused {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 26px rgba(0, 255, 156, 0.18);
}

.btn.secondary.focused {
  border-color: rgba(0, 200, 255, 0.85);
  box-shadow: 0 0 0 1px rgba(0, 200, 255, 0.10) inset, 0 0 26px rgba(0, 200, 255, 0.16);
}

.btn.danger.focused {
  border-color: rgba(255, 77, 109, 0.90);
  box-shadow: 0 0 0 1px rgba(255, 77, 109, 0.10) inset, 0 0 26px rgba(255, 77, 109, 0.16);
}

.btn:active {
  transform: translateY(0px);
}

.btn.secondary {
  border-color: rgba(0, 200, 255, 0.28);
  background: linear-gradient(180deg, rgba(0, 200, 255, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.secondary:hover {
  border-color: rgba(0, 200, 255, 0.55);
  box-shadow: 0 0 18px rgba(0, 200, 255, 0.12);
}

.btn.danger {
  border-color: rgba(255, 77, 109, 0.30);
  background: linear-gradient(180deg, rgba(255, 77, 109, 0.12), rgba(0, 0, 0, 0.20));
}

.btn.danger:hover {
  border-color: rgba(255, 77, 109, 0.65);
  box-shadow: 0 0 18px rgba(255, 77, 109, 0.12);
}

.hint {
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}

.main {
  padding: 18px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
  position: relative;
  z-index: 1;
  min-height: 0;
}

.topbar {
  display: flex;
  gap: 14px;
  align-items: stretch;
}

.right-rail {
  width: 238px;
  display: grid;
  grid-template-rows: auto 1fr;
  gap: 12px;
}

.play-btn {
  width: 238px;
  border-radius: 16px;
  border: 1px solid rgba(0, 255, 156, 0.42);
  background:
    radial-gradient(240px 140px at 20% 20%, rgba(0, 255, 156, 0.22), transparent 60%),
    linear-gradient(180deg, rgba(0, 0, 0, 0.10), rgba(0, 0, 0, 0.30));
  box-shadow: 0 18px 50px rgba(0, 0, 0, 0.52), 0 0 44px rgba(0, 255, 156, 0.18);
  color: rgba(238, 255, 248, 0.96);
  padding: 12px 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease, filter 140ms ease;
}
.play-btn:hover {
  transform: translateY(-1px) scale(1.01);
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 22px 60px rgba(0, 0, 0, 0.55), 0 0 64px rgba(0, 255, 156, 0.28);
  filter: saturate(1.12) contrast(1.08);
}
.play-btn:active {
  transform: translateY(0px) scale(0.99);
}
.play-icon {
  font-size: 18px;
  color: rgba(0, 255, 156, 0.95);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.35);
}
.play-text {
  font-size: 14px;
  letter-spacing: 0.4px;
  text-transform: uppercase;
}

.hud {
  flex: 1;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 14px;
}

.hud-panel {
  padding: 8px 10px 8px;
}

.hud-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.scoreline {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 14px;
  margin-bottom: 10px;
}

.scorebig {
  font-size: 26px;
  letter-spacing: 0.6px;
  color: rgba(238, 255, 248, 0.96);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.08);
}

.scoremeta {
  text-align: right;
}

.scoretarget {
  font-size: 14px;
  color: rgba(0, 255, 156, 0.88);
}

.progress {
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.28);
  overflow: hidden;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.24) inset;
}

.progress-fill {
  height: 100%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.15), rgba(0, 200, 255, 0.55));
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.14);
}

.progress-fill.low {
  background: linear-gradient(90deg, rgba(255, 77, 109, 0.55), rgba(255, 158, 0, 0.45));
}

.progress-fill.mid {
  background: linear-gradient(90deg, rgba(255, 158, 0, 0.55), rgba(0, 200, 255, 0.50));
}

.progress-fill.high {
  background: linear-gradient(90deg, rgba(0, 200, 255, 0.55), rgba(0, 255, 156, 0.70));
}

.progress-fill.clear {
  background: linear-gradient(90deg, rgba(0, 255, 156, 0.75), rgba(255, 77, 255, 0.55));
  box-shadow: 0 0 28px rgba(0, 255, 156, 0.22), 0 0 64px rgba(255, 77, 255, 0.10);
}

.bankline {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-top: 12px;
}

.bankbig {
  font-size: 18px;
  color: rgba(238, 255, 248, 0.94);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.12);
}

.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 14px;
}

.stat {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 13px;
  color: var(--muted);
}

.stat strong {
  color: var(--text);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
}

.kv {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
}

.kv code {
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.deck-widget {
  width: 238px;
  padding: 10px;
  position: relative;
  overflow: hidden;
}

.deck-title {
  margin: 0 0 8px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
}

.deck-stack {
  position: relative;
  height: 76px;
  margin-top: 6px;
}

.deck-card {
  position: absolute;
  inset: 0;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.20);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 45%, rgba(0, 0, 0, 0.35));
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
}

.deck-card:nth-child(2) { transform: translate(8px, 7px); opacity: 0.70; }
.deck-card:nth-child(3) { transform: translate(16px, 14px); opacity: 0.45; }

.deck-meta {
  position: relative;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 12px;
  margin-top: 8px;
}

.pill {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
}

.pill strong {
  color: var(--text);
}

.deckbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  padding: 12px;
  min-height: 0;
  position: relative;
  z-index: 8;
}

.handbar {
  border-radius: var(--radius);
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.28));
  padding: 12px;
  position: relative;
  z-index: 10;
  min-height: 0;
}

.hand-title {
  margin: 0 0 10px 0;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.45px;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.row-scroll {
  overflow-x: scroll;
  overflow-y: visible;
  padding-top: 10px;
  padding-bottom: 10px;
  scrollbar-gutter: stable both-edges;
  scrollbar-color: rgba(0, 255, 156, 0.35) rgba(0, 0, 0, 0.20);
}

.row {
  display: flex;
  gap: 12px;
  align-items: flex-end;
}

.row.center {
  justify-content: center;
  min-width: 100%;
}

.drop-slot {
  width: 18px;
  height: 242px;
  border-radius: 10px;
  border: 1px dashed rgba(0, 255, 156, 0.00);
  background: rgba(0, 0, 0, 0.00);
  transition: border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
}
.drop-slot:hover {
  border-color: rgba(0, 255, 156, 0.38);
  background: rgba(0, 255, 156, 0.04);
  box-shadow: 0 0 22px rgba(0, 255, 156, 0.10);
}

.ghost-card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px dashed rgba(0, 255, 156, 0.30);
  background:
    radial-gradient(220px 160px at 50% 30%, rgba(0, 255, 156, 0.06), transparent 60%),
    linear-gradient(135deg, rgba(0, 255, 156, 0.04), rgba(0, 200, 255, 0.02) 35%, rgba(0, 0, 0, 0.18));
  display: grid;
  place-items: center;
  gap: 8px;
  color: rgba(238, 255, 248, 0.72);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.40);
  transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
}
.ghost-card:hover {
  transform: translateY(-2px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 24px 56px rgba(0, 0, 0, 0.46), 0 0 44px rgba(0, 255, 156, 0.14);
}
.ghost-plus {
  width: 44px;
  height: 44px;
  border-radius: 999px;
  display: grid;
  place-items: center;
  border: 1px solid rgba(0, 255, 156, 0.32);
  background: rgba(0, 0, 0, 0.22);
  font-size: 24px;
  color: rgba(0, 255, 156, 0.88);
  text-shadow: 0 0 22px rgba(0, 255, 156, 0.25);
}
.ghost-hint {
  font-size: 12px;
  color: rgba(238, 255, 248, 0.62);
}

.row-scroll::-webkit-scrollbar {
  height: 10px;
}
.row-scroll::-webkit-scrollbar-thumb {
  background: rgba(0, 255, 156, 0.25);
  border-radius: 999px;
}
.row-scroll::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.18);
  border-radius: 999px;
}

.card {
  width: 176px;
  min-width: 176px;
  height: 242px;
  border-radius: 18px;
  border: 1px solid rgba(0, 255, 156, 0.22);
  background:
    linear-gradient(135deg, rgba(0, 255, 156, 0.10), rgba(0, 200, 255, 0.06) 35%, rgba(0, 0, 0, 0.38));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(0, 255, 156, 0.05) inset;
  overflow: hidden;
  position: relative;
  z-index: 1;
  transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
}

.card::before {
  content: "";
  position: absolute;
  inset: -60px -60px auto -60px;
  height: 120px;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.10), transparent 60%);
  transform: rotate(-8deg);
  pointer-events: none;
}

.card:hover {
  transform: translateY(-6px) rotate(-0.5deg);
  border-color: rgba(0, 255, 156, 0.60);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 28px rgba(0, 255, 156, 0.16), 0 0 64px rgba(0, 200, 255, 0.10);
}

.card.selected {
  border-color: rgba(0, 255, 156, 0.92);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(0, 255, 156, 0.26), 0 0 84px rgba(0, 200, 255, 0.14);
  z-index: 80;
}

/* Theme overrides: punch up terminal + magic vibes */
.app.theme-terminal .brand-title {
  text-shadow: 0 0 20px rgba(124, 255, 0, 0.26);
}

.app.theme-terminal .card {
  border-color: rgba(124, 255, 0, 0.24);
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.50), 0 0 0 1px rgba(124, 255, 0, 0.06) inset;
}

.app.theme-terminal .card:hover {
  border-color: rgba(124, 255, 0, 0.78);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 30px rgba(124, 255, 0, 0.20), 0 0 64px rgba(0, 255, 156, 0.10);
}

.app.theme-magic .brand-title {
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.24), 0 0 44px rgba(122, 92, 255, 0.14);
}

.app.theme-magic .card {
  border-color: rgba(255, 77, 255, 0.24);
  background:
    linear-gradient(135deg, rgba(255, 77, 255, 0.12), rgba(122, 92, 255, 0.10) 38%, rgba(0, 0, 0, 0.42));
  box-shadow: 0 22px 54px rgba(0, 0, 0, 0.52), 0 0 0 1px rgba(255, 77, 255, 0.06) inset;
}

.app.theme-magic .card:hover {
  border-color: rgba(255, 77, 255, 0.80);
  box-shadow: 0 28px 64px rgba(0, 0, 0, 0.58), 0 0 34px rgba(255, 77, 255, 0.20), 0 0 70px rgba(122, 92, 255, 0.14);
}

.card-actions {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 8px;
}

.card-btn {
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.30);
  color: rgba(238, 255, 248, 0.86);
  padding: 8px 8px;
  cursor: pointer;
  transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
}

.card-btn:hover {
  transform: translateY(-1px);
  border-color: rgba(0, 255, 156, 0.55);
  box-shadow: 0 0 16px rgba(0, 255, 156, 0.10);
}

.card-art {
  margin: 10px 10px 0;
  height: 88px;
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background:
    radial-gradient(90px 60px at 20% 35%, rgba(0, 255, 156, 0.22), transparent 60%),
    radial-gradient(100px 70px at 70% 30%, rgba(0, 200, 255, 0.18), transparent 62%),
    linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.42));
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.30) inset;
  position: relative;
  overflow: hidden;
}

.card-art::after {
  content: "";
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255, 255, 255, 0.05),
    rgba(255, 255, 255, 0.05) 1px,
    rgba(0, 0, 0, 0.00) 2px,
    rgba(0, 0, 0, 0.00) 4px
  );
}

.card-body {
  padding: 10px 12px 12px;
}

.card-title {
  margin: 0;
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.card-sub {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.card-script {
  margin-top: 10px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.28);
  padding: 8px 9px;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  text-shadow: 0 0 14px rgba(0, 255, 156, 0.14);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.tok {
  white-space: pre;
}

.tok-ident {
  color: rgba(0, 200, 255, 0.92);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-fn {
  color: rgba(255, 158, 0, 0.92);
  text-shadow: 0 0 14px rgba(255, 158, 0, 0.12);
}

.tok-reg {
  color: rgba(0, 200, 255, 0.94);
  text-shadow: 0 0 14px rgba(0, 200, 255, 0.14);
}

.tok-acc {
  color: rgba(255, 77, 255, 0.92);
  text-shadow: 0 0 18px rgba(255, 77, 255, 0.14);
}

.tok-num {
  color: rgba(0, 255, 156, 0.92);
}

.tok-op {
  color: rgba(255, 158, 0, 0.90);
}

.tok-punct {
  color: rgba(238, 255, 248, 0.60);
}

.tok-raw {
  color: rgba(0, 255, 156, 0.86);
}

.card-badge {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 999px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.22);
  padding: 7px 9px;
  font-size: 11px;
  color: var(--muted);
}

.empty {
  padding: 12px;
  color: var(--muted);
  font-size: 12px;
}

/* Legacy empty dropzones were replaced by ghost-card placeholders to avoid layout jumps. */

.trace-list {
  max-height: 56vh;
  overflow: auto;
  padding-right: 4px;
  font-size: 11px;
  color: var(--muted);
  border-radius: 12px;
}

.trace-item {
  padding: 8px 8px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
}

.trace-item:last-child {
  border-bottom: none;
}

.trace-item.error {
  color: rgba(255, 77, 109, 0.92);
}

.trace-item.call {
  color: rgba(0, 200, 255, 0.90);
}

.trace-item.effect {
  color: rgba(0, 255, 156, 0.92);
}

.modal-overlay {
  position: fixed;
  inset: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 18px;
  background: rgba(0, 0, 0, 0.62);
  backdrop-filter: blur(10px);
}

.modal {
  width: min(980px, 96vw);
  max-height: 92vh;
  overflow: hidden;
  border-color: rgba(0, 255, 156, 0.28);
}

.modal-header {
  padding: 14px 14px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.12);
  background: rgba(0, 0, 0, 0.18);
}

.modal-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.55px;
}

.modal-glyph {
  color: rgba(0, 255, 156, 0.90);
  text-shadow: 0 0 18px rgba(0, 255, 156, 0.18);
}

.modal-body {
  padding: 14px;
  overflow: auto;
  max-height: calc(92vh - 62px);
}

.kdoc {
  color: var(--muted);
  font-size: 13px;
  line-height: 1.55;
  margin-bottom: 14px;
}

.kcard-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.kcard {
  border-radius: 14px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.18);
  overflow: hidden;
}

.kcard.highlight {
  border-color: rgba(0, 255, 156, 0.62);
  box-shadow: 0 0 0 1px rgba(0, 255, 156, 0.10) inset, 0 0 24px rgba(0, 255, 156, 0.16);
}

.kcard-head {
  display: grid;
  grid-template-columns: 44px 1fr 220px;
  gap: 12px;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid rgba(0, 255, 156, 0.10);
  background: rgba(0, 0, 0, 0.22);
}

.kcard-icon {
  display: grid;
  place-items: center;
  width: 44px;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.18);
  background: rgba(0, 0, 0, 0.20);
  color: rgba(0, 255, 156, 0.86);
}

.kcard-title {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.kcard-name {
  font-size: 13px;
  letter-spacing: 0.45px;
  text-transform: uppercase;
}

.kcard-id {
  font-size: 11px;
  color: var(--muted);
}

.kcard-script {
  justify-self: end;
  font-size: 12px;
  color: rgba(0, 255, 156, 0.86);
  border-radius: 12px;
  border: 1px solid rgba(0, 255, 156, 0.14);
  background: rgba(0, 0, 0, 0.24);
  padding: 8px 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.kcard-doc {
  margin: 0;
  padding: 12px;
  white-space: pre-wrap;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.55;
}
"#;



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 1usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(1));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    div { class: "right-rail",
                        button {
                            class: "play-btn",
                            onclick: move |_| {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                }
                                anim::play_flip(before, 360.0);
                            },
                            span { class: "play-icon", "▶" }
                            span { class: "play-text", "Play Hand" }
                        }

                        DeckWidget {
                            deck_count,
                            discard_count,
                            collection_count,
                            hand_count,
                            level: state.level,
                            target: state.target_score,
                        }
                    }
                }

                div { class: "handbar",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row center",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Deck {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                // Drop slots allow inserting between cards. Dropping onto a card swaps.
                                for slot in 0..=state.hand.len() {
                                    div {
                                        key: "hand-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to.min(eng.state.hand.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.hand.len() {
                                        crate::ui::views::CardView {
                                            index: slot,
                                            card: state.hand[slot].clone(),
                                            selected: focus_value == FocusZone::Hand && selected_hand == slot,
                                            primary_icon: "↓",
                                            on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapHand { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row center",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Hand {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for slot in 0..=state.collection.len() {
                                    div {
                                        key: "deck-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to.min(eng.state.collection.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.collection.len() {
                                        crate::ui::views::CardView {
                                            index: slot,
                                            card: state.collection[slot].clone(),
                                            selected: focus_value == FocusZone::Deck && selected_collection == slot,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapCollection { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```rust
// FLIP animations are only meaningful in the browser build.
// Provide no-op stubs for native builds so `cargo test` remains pleasant.

#[cfg(target_arch = "wasm32")]
mod imp {
    use std::collections::HashMap;

    use wasm_bindgen::JsCast;

    #[derive(Debug, Clone, Copy)]
    pub struct Rect {
        pub left: f64,
        pub top: f64,
    }

    pub fn visible_card_ids(
        deck: &[kardinality::game::CardInstance],
        hand: &[kardinality::game::CardInstance],
    ) -> Vec<String> {
        let mut ids = Vec::with_capacity(deck.len() + hand.len());
        for c in deck {
            ids.push(format!("card-{}", c.id));
        }
        for c in hand {
            ids.push(format!("card-{}", c.id));
        }
        ids
    }

    pub fn capture_rects(ids: &[String]) -> HashMap<String, Rect> {
        let mut out = HashMap::new();
        let Some(window) = web_sys::window() else {
            return out;
        };
        let Some(doc) = window.document() else {
            return out;
        };

        for id in ids {
            if let Some(el) = doc.get_element_by_id(id) {
                let rect = el.get_bounding_client_rect();
                out.insert(
                    id.clone(),
                    Rect {
                        left: rect.left(),
                        top: rect.top(),
                    },
                );
            }
        }
        out
    }

    pub fn play_flip(before: HashMap<String, Rect>, duration_ms: f64) {
        let Some(window) = web_sys::window() else {
            return;
        };
        let Some(doc) = window.document() else {
            return;
        };

        // Run on the next frame so Dioxus has applied DOM updates after state changes.
        let cb = wasm_bindgen::closure::Closure::wrap(Box::new(move || {
            // Step 1: apply inverse transforms (no transition)
            let mut animated: Vec<web_sys::HtmlElement> = Vec::new();
            for (id, b) in before.iter() {
                let Some(el) = doc.get_element_by_id(id) else {
                    continue;
                };
                let a = el.get_bounding_client_rect();
                let dx = b.left - a.left();
                let dy = b.top - a.top();
                if dx.abs() < 0.5 && dy.abs() < 0.5 {
                    continue;
                }

                let Ok(html) = el.dyn_into::<web_sys::HtmlElement>() else {
                    continue;
                };

                let style = html.style();
                let _ = style.set_property("transition", "none");
                let _ = style.set_property("position", "relative");
                let _ = style.set_property("z-index", "9999");
                let _ = style.set_property("transform", &format!("translate({dx}px, {dy}px)"));
                animated.push(html);
            }

            // Step 2: next frame, animate back to identity
            let Some(window2) = web_sys::window() else { return };
            let cb2 = wasm_bindgen::closure::Closure::wrap(Box::new(move || {
                for html in animated.iter() {
                    let style = html.style();
                    let _ = style.set_property(
                        "transition",
                        &format!(
                            "transform {}ms cubic-bezier(0.16, 1, 0.3, 1)",
                            duration_ms
                        ),
                    );
                    let _ = style.set_property("transform", "translate(0px, 0px)");
                }

                // Step 3: after animation, restore stacking order.
                if let Some(window3) = web_sys::window() {
                    let animated2 = animated.clone();
                    let cb3 = wasm_bindgen::closure::Closure::wrap(Box::new(move || {
                        for html in animated2.iter() {
                            let style = html.style();
                            let _ = style.set_property("z-index", "1");
                        }
                    }) as Box<dyn FnMut()>);

                    let _ = window3.set_timeout_with_callback_and_timeout_and_arguments_0(
                        cb3.as_ref().unchecked_ref(),
                        duration_ms.max(0.0) as i32,
                    );
                    cb3.forget();
                }
            }) as Box<dyn FnMut()>);
            let _ = window2.request_animation_frame(cb2.as_ref().unchecked_ref());
            cb2.forget();
        }) as Box<dyn FnMut()>);

        let _ = window.request_animation_frame(cb.as_ref().unchecked_ref());
        cb.forget();
    }
}

#[cfg(not(target_arch = "wasm32"))]
mod imp {
    use std::collections::HashMap;

    #[derive(Debug, Clone, Copy)]
    pub struct Rect {
        pub left: f64,
        pub top: f64,
    }

    pub fn visible_card_ids(
        _deck: &[kardinality::game::CardInstance],
        _hand: &[kardinality::game::CardInstance],
    ) -> Vec<String> {
        Vec::new()
    }

    pub fn capture_rects(_ids: &[String]) -> HashMap<String, Rect> {
        HashMap::new()
    }

    pub fn play_flip(_before: HashMap<String, Rect>, _duration_ms: f64) {}
}

pub use imp::*;



```

```rust
use dioxus::prelude::*;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum KTab {
    Overview,
    Functions,
    Examples,
    Reference,
}

#[component]
pub fn KardinomiconModal(
    open: bool,
    target: Option<String>,
    on_close: EventHandler<()>,
) -> Element {
    let catalog = kardinality::game::cards::catalog();
    let mut tab = use_signal(|| KTab::Overview);

    // If a target is provided, show it first.
    let mut ordered: Vec<kardinality::game::cards::CardDef> = Vec::with_capacity(catalog.len());
    if let Some(t) = target.as_deref() {
        if let Some(found) = catalog.iter().find(|c| c.id == t) {
            ordered.push(*found);
        }
    }
    for c in catalog {
        if ordered.first().is_some_and(|first| first.id == c.id) {
            continue;
        }
        ordered.push(*c);
    }

    let tab_value = tab();

    rsx! {
        if open {
            div {
                class: "modal-overlay",
                onclick: move |_| on_close.call(()),

                div {
                    class: "modal panel",
                    onclick: move |evt| evt.stop_propagation(),

                    div { class: "modal-header",
                        div { class: "modal-title",
                            span { class: "modal-glyph", "⟡" }
                            span { "Kardinomicon" }
                        }
                        button { class: "btn danger", onclick: move |_| on_close.call(()), "Close" }
                    }

                    div { class: "modal-body",
                        div { class: "tabs",
                            button {
                                class: if tab_value == KTab::Overview { "tab active" } else { "tab" },
                                onclick: move |_| tab.set(KTab::Overview),
                                "Overview"
                            }
                            button {
                                class: if tab_value == KTab::Functions { "tab active" } else { "tab" },
                                onclick: move |_| tab.set(KTab::Functions),
                                "Functions"
                            }
                            button {
                                class: if tab_value == KTab::Examples { "tab active" } else { "tab" },
                                onclick: move |_| tab.set(KTab::Examples),
                                "Examples"
                            }
                            button {
                                class: if tab_value == KTab::Reference { "tab active" } else { "tab" },
                                onclick: move |_| tab.set(KTab::Reference),
                                "Reference"
                            }
                        }

                        if tab_value == KTab::Overview {
                            h2 { class: "hud-title", "What is this?" }
                            div { class: "kdoc",
                                "Cards are little programs. You assemble a Hand (top), then hit "
                                strong { "Play Hand" }
                                " to execute them in order."
                                br {}
                                "Kardlang is integer-only with strict budgets. Power scales with length."
                                br {}
                                "Key registers: "
                                code { "len_deck" } " • " code { "len_hand" } " • " code { "lvl" } " • " code { "score" }
                                br {}
                                "Tip: drop between cards to insert, or on a card to swap."
                            }

                            h2 { class: "hud-title", "Cards" }
                            div { class: "kcard-list",
                                for c in ordered {
                                    KardinomiconCard {
                                        card: c,
                                        highlight: target.as_deref().is_some_and(|t| t == c.id),
                                    }
                                }
                            }
                        } else if tab_value == KTab::Functions {
                            h2 { class: "hud-title", "Built-in functions" }
                            div { class: "kdoc",
                                strong { "Economy / score" } br {}
                                code { "score(n)" } " → score += n" br {}
                                code { "bank(n)" } " → bankroll += n" br {}
                                code { "dbl()" } " → bankroll *= 2" br {}
                                br {}
                                strong { "Deck ops" } br {}
                                code { "draw(n)" } " → generate n new cards into your Deck" br {}
                                br {}
                                strong { "Acc / math" } br {}
                                code { "tri(x)" } " → acc = x*(x+1)/2" br {}
                                code { "fibo(x)" } " → acc = F(x)" br {}
                                br {}
                                strong { "Meta" } br {}
                                code { "clone(n)" } " → queue n copies of last played card" br {}
                                code { "again(n)" } " → queue n replays of last played card" br {}
                                code { "mutate()" } " → mutate last played card into a random new one" br {}
                            }
                        } else if tab_value == KTab::Examples {
                            h2 { class: "hud-title", "Example combos" }
                            div { class: "kdoc",
                                strong { "Build then score" } br {}
                                code { "draw(5)" } " → expand options" br {}
                                code { "tri(len_deck); score(acc)" } " → score based on deck size" br {}
                                br {}
                                strong { "Snowball economy" } br {}
                                code { "bank(6); dbl()" } " → bankroll growth" br {}
                                br {}
                                strong { "Chaos loop" } br {}
                                code { "mutate(); again(2)" } " → roll the dice twice" br {}
                            }
                        } else {
                            h2 { class: "hud-title", "Language reference" }
                            div { class: "kdoc",
                                "Numbers are unary (" code { "111" } " = 3) or digit shorthand (" code { "4" } " = 4 but costs 4)."
                                br {}
                                "Expressions support " code { "+" } " and " code { "*" } " with parentheses."
                                br {}
                                "Registers: " code { "len_deck" } ", " code { "len_hand" } ", " code { "lvl" } ", " code { "score" } ", and writable " code { "acc" } "."
                            }
                            pre { class: "kcard-doc", "{kardinality::kardlang::GRAMMAR.trim()}" }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn KardinomiconCard(card: kardinality::game::cards::CardDef, highlight: bool) -> Element {
    let class = if highlight { "kcard highlight" } else { "kcard" };
    rsx! {
        div { class: "{class}",
            div { class: "kcard-head",
                span { class: "kcard-icon", "{card.icon}" }
                div { class: "kcard-title",
                    div { class: "kcard-name", "{card.name}" }
                    div { class: "kcard-id", "{card.id}" }
                }
                div { class: "kcard-script", "{card.script}" }
            }
            pre { class: "kcard-doc", "{card.doc.trim()}" }
        }
    }
}



```

### Fixed centering + “always on top” during keyboard moves

- **Centered empty ghost slots**: the ghost “+ Drop to add” card now sits centered in Hand/Deck empty states (no weird left alignment).
  - **Files**: `src/ui/app.rs`, `src/ui/theme.rs` (added `.row.center`)

- **Cards stay above borders while moving** (keyboard + FLIP travel):
  - Added **base z-index** to cards and a higher z-index for `.card.selected`
  - During FLIP, we now temporarily set `z-index: 9999` on any moving element, then restore after the animation finishes.
  - **Files**: `src/ui/theme.rs`, `src/ui/anim.rs`

### Kardinomicon: now 4 tabs

Reworked the modal into **Overview / Functions / Examples / Reference** tabs.

- **Overview**: what Kardlang is + full card list (still supports highlighting the target card)
- **Functions**: organized list of built-ins
- **Examples**: a few starter combos
- **Reference**: registers summary + grammar (from `kardlang::GRAMMAR`)

- **File**: `src/ui/views/kardinomicon.rs`

### Build status
- `cargo build --target wasm32-unknown-unknown` ✅

If you want, I can also make the Kardinomicon remember the last selected tab between opens (right now it defaults to Overview each time).

---

**User**

Hey, can you set up a system so you can automatically try out the web GUI? I want you to be able to debug automatically, what do you think?

This could also be useful for some tests and automated deployment

---

**Cursor**

Plan: I’ll add a lightweight “E2E harness” that can launch the built WASM app, drive it in a real browser headlessly, and assert core UX flows (starter deck visible, move card to hand, play hand). I’ll wire it so it can run locally and in CI (useful for deployment confidence), without adding any hand-written JS to the app itself—only test tooling. Next I’ll add `package.json` + Playwright tests + a `scripts/e2e` runner, and document the workflow in `README.md`.

Plan: I’ll add an **end-to-end (E2E) harness** using Playwright that can launch the built Dioxus web app, click/keyboard-drive the UI, and assert key flows (starter deck visible → move card to hand → play hand → score changes; docs modal tabs render). I’ll also add a GitHub Actions workflow stub so this can run in CI for future automated deploys—tests/tooling only, no hand-written JS in the app itself.

Plan: I’ll add stable `data-testid` hooks to the UI so a headless browser can reliably find elements, then I’ll add a Playwright E2E test suite + a small runner script that starts `dx serve`, waits for the page, runs tests, and shuts down. Finally I’ll add an optional GitHub Actions workflow so this can run on every push (great for automated deployment confidence).

```rust
use dioxus::prelude::*;

#[component]
pub fn TopHud(
    bankroll: i64,
    score: i64,
    target: i64,
    collection_count: usize,
    hand_count: usize,
    level: u32,
) -> Element {
    let pct = if target <= 0 {
        0.0
    } else {
        (score as f64 / target as f64).clamp(0.0, 1.25)
    };
    let pct100 = (pct * 100.0).clamp(0.0, 125.0);
    let fill_style = format!("width: {pct100:.2}%");

    let stage = if pct < 0.33 {
        "low"
    } else if pct < 0.66 {
        "mid"
    } else if pct < 1.0 {
        "high"
    } else {
        "clear"
    };

    rsx! {
        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Score" }

            div { class: "scoreline",
                div { class: "scorebig", "data-testid": "score-value", "{score}" }
                div { class: "scoremeta",
                    div { class: "hint", "Target" }
                    div { class: "scoretarget", "{target}" }
                }
            }

            div { class: "progress",
                div { class: "progress-fill {stage}", style: "{fill_style}" }
            }

            div { class: "bankline",
                div { class: "hint", "Bankroll" }
                div { class: "bankbig", "${bankroll}" }
            }
        }

        div { class: "panel hud-panel",
            h2 { class: "hud-title", "Registers" }
            div { class: "kv", span { "len_deck" } code { "{collection_count}" } }
            div { class: "kv", span { "len_hand" } code { "{hand_count}" } }
            div { class: "kv", span { "lvl" } code { "{level}" } }
            div { class: "kv", span { "score" } code { "{score}" } }
        }
    }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::{UiSettings, UiTheme};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SidebarTab {
    Controls,
    Debug,
    Settings,
}

#[component]
pub fn Sidebar(
    mut engine: Signal<kardinality::Engine>,
    mut tab: Signal<SidebarTab>,
    mut settings: Signal<UiSettings>,
    mut kardinomicon_open: Signal<bool>,
    mut kardinomicon_target: Signal<Option<String>>,
    focused: bool,
    focus_index: usize,
) -> Element {
    let tab_value = tab();
    let cur_settings = settings();

    // Sidebar focus highlight handled inline for each button (controls are dynamic).

    let engine_read = engine.read();
    let state = &engine_read.state;

    rsx! {
        aside { class: "sidebar",
            div { class: "brand",
                h1 { class: "brand-title", "Kardinality" }
                div { class: "brand-subtitle",
                    "retro CRT deckbuilder • cards-as-code • rust+wasm"
                }
            }

            div { class: "tabs",
                button {
                    class: if tab_value == SidebarTab::Controls { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Controls),
                    "Controls"
                }
                button {
                    class: if tab_value == SidebarTab::Debug { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Debug),
                    "Debug"
                }
                button {
                    class: if tab_value == SidebarTab::Settings { "tab active" } else { "tab" },
                    onclick: move |_| tab.set(SidebarTab::Settings),
                    "Settings"
                }
            }

            if tab_value == SidebarTab::Controls {
                div { class: "panel sidebar-panel",
                    h3 { "Run" }
                    button {
                        "data-testid": "reset-game",
                        class: if focused && focus_index == 0 { "btn danger focused" } else { "btn danger" },
                        title: "Warning: resets your run state",
                        onclick: move |_| {
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                        },
                        "Reset game"
                    }
                    button {
                        "data-testid": "open-docs",
                        class: if focused && focus_index == 1 { "btn secondary focused" } else { "btn secondary" },
                        onclick: move |_| {
                            kardinomicon_target.set(None);
                            kardinomicon_open.set(true);
                        },
                        "Open docs"
                    }
                }
            } else if tab_value == SidebarTab::Debug {
                div { class: "panel sidebar-panel",
                    h3 { "Trace (latest first)" }
            button {
                class: "btn danger",
                "data-testid": "clear-trace",
                onclick: move |_| {
                    let mut eng = engine.write();
                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                },
                "Clear trace"
            }
                    if state.trace.is_empty() {
                        div { class: "empty", "No trace yet. Assemble a hand and execute." }
                    } else {
                        div { class: "trace-list",
                            for evt in state.trace.iter().rev().take(120) {
                                TraceItem { evt: evt.clone() }
                            }
                        }
                    }
                }

        div { class: "panel sidebar-panel",
            h3 { "Telemetry" }
            div { class: "kv", span { "Source" } code { "{state.deck.len()}" } }
            div { class: "kv", span { "Deck" } code { "{state.collection.len()}" } }
            div { class: "kv", span { "Hand" } code { "{state.hand.len()}" } }
            div { class: "kv", span { "Discard" } code { "{state.discard.len()}" } }
            div { class: "kv", span { "Trace" } code { "{state.trace.len()}" } }
            div { class: "kv", span { "Phase" } code { "{state.phase:?}" } }
        }
            } else {
                div { class: "panel sidebar-panel",
                    h3 { "Theme" }
                    div { class: "tabs",
                        for theme in [UiTheme::Crt, UiTheme::Terminal, UiTheme::Magic] {
                            button {
                                class: if cur_settings.theme == theme { "tab active" } else { "tab" },
                                onclick: move |_| {
                                    let mut s = settings.write();
                                    s.theme = theme;
                                },
                                "{theme.label()}"
                            }
                        }
                    }

                    h3 { "Effects" }
                    button {
                        class: if cur_settings.effects { "btn" } else { "btn secondary" },
                        onclick: move |_| {
                            let mut s = settings.write();
                            s.effects = !s.effects;
                        },
                        if cur_settings.effects { "CRT overlays: ON" } else { "CRT overlays: OFF" }
                    }

                    div { class: "hint",
                        "Hotkeys: arrows select • ↑/↓ move • Shift+←/→ reorder • Enter executes."
                    }
                }
            }
        }
    }
}

#[component]
fn TraceItem(evt: kardinality::TraceEvent) -> Element {
    let (class, text) = match &evt {
        kardinality::TraceEvent::Error(_) => ("trace-item error", format!("{evt:?}")),
        kardinality::TraceEvent::Call { .. } => ("trace-item call", format!("{evt:?}")),
        kardinality::TraceEvent::EffectApplied { .. } => ("trace-item effect", format!("{evt:?}")),
        _ => ("trace-item", format!("{evt:?}")),
    };

    rsx! { div { class: "{class}", "{text}" } }
}



```

```rust
use dioxus::prelude::*;

use crate::ui::state::UiSettings;
use crate::ui::theme;
use crate::ui::views::{DeckWidget, KardinomiconModal, Sidebar, SidebarTab, TopHud};
use crate::ui::anim;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FocusZone {
    Sidebar,
    Deck,
    Hand,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct DragPayload {
    zone: FocusZone,
    index: usize,
}

#[component]
pub fn App() -> Element {
    let mut engine = use_signal(|| kardinality::Engine::new(0));
    let mut tab = use_signal(|| SidebarTab::Controls);

    let settings = use_signal(UiSettings::default);
    let mut kardinomicon_open = use_signal(|| false);
    let mut kardinomicon_target = use_signal(|| None::<String>);

    // Keyboard-first selection state.
    let mut focus = use_signal(|| FocusZone::Deck);
    let mut sel_collection = use_signal(|| 0usize);
    let mut sel_hand = use_signal(|| 0usize);
    let mut drag = use_signal(|| None::<DragPayload>);
    let mut sidebar_index = use_signal(|| 0usize);

    let engine_read = engine.read();
    let state = &engine_read.state;

    let deck_count = state.deck.len();
    let discard_count = state.discard.len();
    let collection_count = state.collection.len();
    let hand_count = state.hand.len();

    let focus_value = focus();
    let selected_collection = sel_collection();
    let selected_hand = sel_hand();

    let settings_value = settings();
    let app_class = if settings_value.effects {
        format!("app {}", settings_value.theme.class())
    } else {
        format!("app {} effects-off", settings_value.theme.class())
    };

    rsx! {
        style { {theme::CSS} }

        div {
            class: "{app_class}",
            tabindex: "0",
            onmounted: move |evt| {
                // Keep the app keyboard-first: focus the root so arrow keys work immediately.
                let node = evt.data();
                spawn(async move {
                    let _ = node.set_focus(true).await;
                });
            },
            onkeydown: move |evt: KeyboardEvent| {
                use dioxus::prelude::Key;
                use keyboard_types::Modifiers;

                let key = evt.key();
                let shift = evt.modifiers().contains(Modifiers::SHIFT);

                // Avoid the browser interpreting arrows/tab as scrolling/focus shifts.
                if matches!(
                    key,
                    Key::ArrowLeft | Key::ArrowRight | Key::ArrowUp | Key::ArrowDown | Key::Tab
                ) {
                    evt.prevent_default();
                }

                // Helper: clamp an index into [0, len-1] (or 0 if empty).
                let clamp = |idx: usize, len: usize| -> usize {
                    if len == 0 { 0 } else { idx.min(len - 1) }
                };

                match key {
                    Key::ArrowLeft => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                sel_collection.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx.saturating_sub(1), len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx > 0 {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                sel_hand.set(idx - 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx.saturating_sub(1), len));
                            }
                        }
                    }
                    Key::ArrowRight => {
                        if focus() == FocusZone::Sidebar {
                            // no-op for now (reserved for tab switching)
                        } else if focus() == FocusZone::Deck {
                            let len = engine.read().state.collection.len();
                            let idx = sel_collection();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                sel_collection.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_collection.set(clamp(idx + 1, len));
                            }
                        } else if focus() == FocusZone::Hand {
                            let len = engine.read().state.hand.len();
                            let idx = sel_hand();
                            if shift && len > 0 && idx + 1 < len {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                sel_hand.set(idx + 1);
                                anim::play_flip(before, 260.0);
                            } else {
                                sel_hand.set(clamp(idx + 1, len));
                            }
                        }
                    }
                    Key::ArrowUp => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            sidebar_index.set(idx.saturating_sub(1));
                            return;
                        }
                        // Move from collection -> hand and focus hand.
                        if focus() == FocusZone::Deck {
                            let idx = sel_collection();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Hand);
                            let new_hand_len = eng.state.hand.len();
                            if new_hand_len > 0 {
                                sel_hand.set(new_hand_len - 1);
                            }
                            let new_coll_len = eng.state.collection.len();
                            sel_collection.set(clamp(idx, new_coll_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::ArrowDown => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            // Controls has 3 actions; Debug has 1 action (clear trace); Settings has 0 focusable actions.
                            let max = match tab() {
                                SidebarTab::Controls => 1usize,
                                SidebarTab::Debug => 0usize,
                                SidebarTab::Settings => 0usize,
                            };
                            sidebar_index.set((idx + 1).min(max));
                            return;
                        }
                        // Move from hand -> collection and focus collection.
                        if focus() == FocusZone::Hand {
                            let idx = sel_hand();
                            let before = {
                                let st = engine.read();
                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                anim::capture_rects(&ids)
                            };
                            let mut eng = engine.write();
                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                            }
                            focus.set(FocusZone::Deck);
                            let new_coll_len = eng.state.collection.len();
                            if new_coll_len > 0 {
                                sel_collection.set(new_coll_len - 1);
                            }
                            let new_hand_len = eng.state.hand.len();
                            sel_hand.set(clamp(idx, new_hand_len));
                            anim::play_flip(before, 280.0);
                        }
                    }
                    Key::Enter => {
                        if focus() == FocusZone::Sidebar {
                            let idx = sidebar_index();
                            match tab() {
                                SidebarTab::Controls => {
                                    let mut eng = engine.write();
                                    match idx {
                                        0 => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::NewRun { seed: 0 }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                        }
                                        1 => {
                                            kardinomicon_target.set(None);
                                            kardinomicon_open.set(true);
                                        }
                                        _ => {}
                                    }
                                }
                                SidebarTab::Debug => {
                                    let mut eng = engine.write();
                                    let _ = eng.dispatch(kardinality::Action::ClearTrace);
                                }
                                SidebarTab::Settings => {}
                            }
                            return;
                        }

                        let mut eng = engine.write();
                        if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                        }
                    }
                    Key::Tab => {
                        // Cycle focus through Sidebar -> Hand -> Deck.
                        match focus() {
                            FocusZone::Sidebar => {
                                focus.set(FocusZone::Hand);
                                let len = engine.read().state.hand.len();
                                sel_hand.set(clamp(sel_hand(), len));
                            }
                            FocusZone::Hand => {
                                focus.set(FocusZone::Deck);
                                let len = engine.read().state.collection.len();
                                sel_collection.set(clamp(sel_collection(), len));
                            }
                            FocusZone::Deck => {
                                focus.set(FocusZone::Sidebar);
                                tab.set(SidebarTab::Controls);
                                sidebar_index.set(sidebar_index().min(1));
                            }
                        }
                    }
                    _ => {}
                }
            },
            Sidebar {
                engine,
                tab,
                settings,
                kardinomicon_open,
                kardinomicon_target,
                focused: focus_value == FocusZone::Sidebar,
                focus_index: sidebar_index(),
            }

            div { class: "main",
                div { class: "topbar",
                    div { class: "hud",
                        TopHud {
                            bankroll: state.bankroll,
                            score: state.score,
                            target: state.target_score,
                            collection_count,
                            hand_count,
                            level: state.level,
                        }
                    }

                    div { class: "right-rail",
                        button {
                            class: "play-btn",
                            "data-testid": "play-hand",
                            onclick: move |_| {
                                let before = {
                                    let st = engine.read();
                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                    anim::capture_rects(&ids)
                                };
                                let mut eng = engine.write();
                                if let Err(e) = eng.dispatch(kardinality::Action::PlayHand) {
                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                }
                                anim::play_flip(before, 360.0);
                            },
                            span { class: "play-icon", "▶" }
                            span { class: "play-text", "Play Hand" }
                        }

                        DeckWidget {
                            deck_count,
                            discard_count,
                            collection_count,
                            hand_count,
                            level: state.level,
                            target: state.target_score,
                        }
                    }
                }

                div { class: "handbar", "data-testid": "hand-zone",
                    div { class: "hand-title",
                        span { "Hand" }
                        span { class: "hint", "{hand_count} cards" }
                    }

                    if state.hand.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row center",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Deck {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Hand => {
                                            let len = eng.state.hand.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                focus.set(FocusZone::Hand);
                                                sel_hand.set(to);
                                            }
                                        }
                                        FocusZone::Deck => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(eng.state.hand.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                // Drop slots allow inserting between cards. Dropping onto a card swaps.
                                for slot in 0..=state.hand.len() {
                                    div {
                                        key: "hand-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from: payload.index, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to.min(eng.state.hand.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.hand.len() {
                                        crate::ui::views::CardView {
                                            index: slot,
                                            card: state.hand[slot].clone(),
                                            selected: focus_value == FocusZone::Hand && selected_hand == slot,
                                            primary_icon: "↓",
                                            on_select: move |idx| { focus.set(FocusZone::Hand); sel_hand.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            let new_coll_len = eng.state.collection.len();
                                            if new_coll_len > 0 { sel_collection.set(new_coll_len - 1); }
                                            let new_hand_len = eng.state.hand.len();
                                            sel_hand.set(if new_hand_len == 0 { 0 } else { idx.min(new_hand_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.hand.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderHand { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Hand, index: idx }));
                                            focus.set(FocusZone::Hand);
                                            sel_hand.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Hand => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapHand { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(drop_idx);
                                                    }
                                                    FocusZone::Deck => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.hand.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderHand { from, to });
                                                        focus.set(FocusZone::Hand);
                                                        sel_hand.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Deck at the bottom: this is your owned collection of cards you can put into your hand.
                div { class: "deckbar", "data-testid": "deck-zone",
                    div { class: "hand-title",
                        span { "Deck" }
                        span { class: "hint", "{collection_count} cards" }
                    }

                    if state.collection.is_empty() {
                        div { class: "row-scroll",
                            div { class: "row center",
                                div {
                                    class: "ghost-card dropzone",
                                    ondragover: move |evt| evt.prevent_default(),
                                    ondrop: move |evt| {
                                        evt.prevent_default();
                                        if let Some(payload) = drag() {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if payload.zone == FocusZone::Hand {
                                                if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                    eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                }
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                            }
                                            anim::play_flip(before, 280.0);
                                        }
                                        drag.set(None);
                                    },
                                    div { class: "ghost-plus", "+" }
                                    div { class: "ghost-hint", "Drop to add" }
                                }
                            }
                        }
                    } else {
                        div {
                            class: "row-scroll",
                            ondragover: move |evt| evt.prevent_default(),
                            ondrop: move |evt| {
                                evt.prevent_default();
                                if let Some(payload) = drag() {
                                    let before = {
                                        let st = engine.read();
                                        let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                        anim::capture_rects(&ids)
                                    };
                                    let mut eng = engine.write();
                                    match payload.zone {
                                        FocusZone::Deck => {
                                            let len = eng.state.collection.len();
                                            if len > 0 {
                                                let to = len - 1;
                                                let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                focus.set(FocusZone::Deck);
                                                sel_collection.set(to);
                                            }
                                        }
                                        FocusZone::Hand => {
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(eng.state.collection.len().saturating_sub(1));
                                        }
                                        FocusZone::Sidebar => {}
                                    }
                                    anim::play_flip(before, 280.0);
                                }
                                drag.set(None);
                            },
                            div { class: "row",
                                for slot in 0..=state.collection.len() {
                                    div {
                                        key: "deck-slot-{slot}",
                                        class: "drop-slot",
                                        ondragover: move |evt| evt.prevent_default(),
                                        ondrop: move |evt| {
                                            evt.prevent_default();
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let mut to = slot;
                                                        if payload.index < to { to = to.saturating_sub(1); }
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: payload.index, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to.min(eng.state.collection.len().saturating_sub(1)));
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = slot.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 320.0);
                                            }
                                            drag.set(None);
                                        }
                                    }
                                    if slot < state.collection.len() {
                                        crate::ui::views::CardView {
                                            index: slot,
                                            card: state.collection[slot].clone(),
                                            selected: focus_value == FocusZone::Deck && selected_collection == slot,
                                            primary_icon: "↑",
                                            on_select: move |idx| { focus.set(FocusZone::Deck); sel_collection.set(idx); },
                                            on_primary: move |idx| {
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            if let Err(e) = eng.dispatch(kardinality::Action::MoveCollectionToHand { index: idx }) {
                                                eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                            }
                                            focus.set(FocusZone::Hand);
                                            let new_hand_len = eng.state.hand.len();
                                            if new_hand_len > 0 { sel_hand.set(new_hand_len - 1); }
                                            let new_coll_len = eng.state.collection.len();
                                            sel_collection.set(if new_coll_len == 0 { 0 } else { idx.min(new_coll_len - 1) });
                                            anim::play_flip(before, 280.0);
                                        },
                                        on_move_left: move |idx| {
                                            if idx == 0 { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx - 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx - 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_move_right: move |idx| {
                                            let len = engine.read().state.collection.len();
                                            if idx + 1 >= len { return; }
                                            let before = {
                                                let st = engine.read();
                                                let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                anim::capture_rects(&ids)
                                            };
                                            let mut eng = engine.write();
                                            let _ = eng.dispatch(kardinality::Action::ReorderCollection { from: idx, to: idx + 1 });
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx + 1);
                                            anim::play_flip(before, 260.0);
                                        },
                                        on_docs: move |id| {
                                            kardinomicon_target.set(Some(id));
                                            kardinomicon_open.set(true);
                                        },
                                        on_drag_start: move |idx| {
                                            drag.set(Some(DragPayload { zone: FocusZone::Deck, index: idx }));
                                            focus.set(FocusZone::Deck);
                                            sel_collection.set(idx);
                                        },
                                        on_drag_end: move |_| drag.set(None),
                                            on_drop: move |drop_idx| {
                                            if let Some(payload) = drag() {
                                                let before = {
                                                    let st = engine.read();
                                                    let ids = anim::visible_card_ids(&st.state.collection, &st.state.hand);
                                                    anim::capture_rects(&ids)
                                                };
                                                let mut eng = engine.write();
                                                match payload.zone {
                                                    FocusZone::Deck => {
                                                        let _ = eng.dispatch(kardinality::Action::SwapCollection { a: payload.index, b: drop_idx });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(drop_idx);
                                                    }
                                                    FocusZone::Hand => {
                                                        if let Err(e) = eng.dispatch(kardinality::Action::MoveHandToCollection { index: payload.index }) {
                                                            eng.state.trace.push(kardinality::TraceEvent::Error(e.to_string()));
                                                        }
                                                        let from = eng.state.collection.len().saturating_sub(1);
                                                        let to = drop_idx.min(from);
                                                        let _ = eng.dispatch(kardinality::Action::ReorderCollection { from, to });
                                                        focus.set(FocusZone::Deck);
                                                        sel_collection.set(to);
                                                    }
                                                    FocusZone::Sidebar => {}
                                                }
                                                anim::play_flip(before, 280.0);
                                            }
                                            drag.set(None);
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            KardinomiconModal {
                open: kardinomicon_open(),
                target: kardinomicon_target(),
                on_close: move |_| {
                    kardinomicon_open.set(false);
                    kardinomicon_target.set(None);
                }
            }
        }
    }
}



```

```json
{
  "name": "kardinality-e2e",
  "private": true,
  "devDependencies": {
    "@playwright/test": "^1.50.0"
  },
  "scripts": {
    "e2e": "bash ./scripts/e2e.sh",
    "e2e:ui": "bash ./scripts/e2e.sh --ui"
  }
}


```

```typescript
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: "e2e",
  timeout: 30_000,
  expect: { timeout: 10_000 },
  use: {
    baseURL: process.env.E2E_BASE_URL || "http://127.0.0.1:8080",
    headless: process.env.E2E_HEADLESS !== "false",
    viewport: { width: 1280, height: 720 },
    trace: "retain-on-failure",
    video: "retain-on-failure",
  },
});


```

```typescript
import { test, expect } from "@playwright/test";

test("boots with starter deck visible", async ({ page }) => {
  await page.goto("/");

  const deck = page.getByTestId("deck-zone");
  await expect(deck).toBeVisible();

  // Starter deck should be present immediately.
  await expect(deck.locator(".card")).toHaveCount(3);
});

test("move Score card to hand and play hand updates score", async ({ page }) => {
  await page.goto("/");

  const deck = page.getByTestId("deck-zone");
  const hand = page.getByTestId("hand-zone");

  // Select the "Score +4" card and move it into hand via keyboard (ArrowUp).
  const scoreCard = deck.locator(".card", { hasText: "Score +4" }).first();
  await scoreCard.click();
  await page.keyboard.press("ArrowUp");

  await expect(hand.locator(".card")).toHaveCount(1);

  // Play hand via the big right-rail button.
  await page.getByTestId("play-hand").click();

  await expect(page.getByTestId("score-value")).toHaveText("4");
  await expect(hand.locator(".card")).toHaveCount(0);
});

test("kardinomicon has the requested tabs", async ({ page }) => {
  await page.goto("/");
  await page.getByTestId("open-docs").click();

  await expect(page.getByText("Kardinomicon")).toBeVisible();
  await expect(page.getByRole("button", { name: "Overview" })).toBeVisible();
  await expect(page.getByRole("button", { name: "Functions" })).toBeVisible();
  await expect(page.getByRole("button", { name: "Examples" })).toBeVisible();
  await expect(page.getByRole("button", { name: "Reference" })).toBeVisible();
});


```

```shellscript
#!/usr/bin/env bash
set -euo pipefail

PORT="${E2E_PORT:-8080}"
ADDR="${E2E_ADDR:-127.0.0.1}"
BASE_URL="${E2E_BASE_URL:-http://${ADDR}:${PORT}}"

UI="${1:-}"

cleanup() {
  if [[ -n "${DX_PID:-}" ]]; then
    kill "${DX_PID}" >/dev/null 2>&1 || true
  fi
}
trap cleanup EXIT

echo "Starting dx serve at ${BASE_URL} ..."
dx serve --addr "${ADDR}" --port "${PORT}" --open false --interactive false --watch false >/dev/null 2>&1 &
DX_PID="$!"

echo "Waiting for server..."
for _ in $(seq 1 80); do
  if curl -fsS "${BASE_URL}" >/dev/null 2>&1; then
    break
  fi
  sleep 0.1
done

if ! curl -fsS "${BASE_URL}" >/dev/null 2>&1; then
  echo "Server did not become ready at ${BASE_URL}"
  exit 1
fi

echo "Running Playwright tests..."
export E2E_BASE_URL="${BASE_URL}"

if [[ "${UI}" == "--ui" ]]; then
  npx --yes playwright test --ui
else
  npx --yes playwright test
fi


```

```markdown
## Kardinality

Kardinality is a **single‑player, browser‑deployed** card game where your “hand” is an ordered stack of executable code‑cards. The vibe is roguelike deck‑building (Balatro‑adjacent), but the mechanics are intentionally **programming‑shaped**: cards compose, control flow exists, and you win by hitting ever‑higher score targets.

### Tech stack

* **Rust**: all game logic (rules, state, interpreter)
* **WASM (web)**: cross‑platform browser deploy
* **Dioxus**: UI rendered via **HTML DOM + CSS**, no traditional rendering engine
* **Browser APIs**: accessed from Rust (`web_sys` / `wasm_bindgen`) with minimal/no hand‑written JS

### Quick start (dev)

Recommended workflow:

* Install Rust (stable) and add the WASM target:
  * `rustup target add wasm32-unknown-unknown`
* Install Dioxus CLI:
  * `cargo install dioxus-cli`
  * (optional, faster installs) `cargo install cargo-binstall && cargo binstall dioxus-cli`
* Run the dev server:
  * `dx serve`
* Build for release:
  * `dx build --release`
* Run core logic tests:
  * `cargo test`

### Automated GUI smoke tests (E2E)

This repo includes a headless browser harness (Playwright) that can boot the WASM app and drive the UI.
It’s intended for regression checks and future automated deployment confidence.

Prereqs:

* Node.js 18+
* `dioxus-cli` installed (`dx serve` must work)

Install deps:

* `npm install`

Run E2E tests (headless):

* `npm run e2e`

Run E2E tests with the Playwright UI:

* `npm run e2e:ui`

### Docs

* `AGENTS.md`: guidance for future AI agents (commands, constraints, conventions)
* `KARDLANG.md`: language philosophy + cost model + registers + function reference



```

```yaml
name: e2e

on:
  push:
  pull_request:

jobs:
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install Dioxus CLI
        run: cargo install dioxus-cli

      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Playwright deps
        run: |
          npm ci
          npx playwright install --with-deps

      - name: Run E2E
        run: npm run e2e


```

